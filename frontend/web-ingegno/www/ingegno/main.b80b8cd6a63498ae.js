"use strict";
(self.webpackChunkweb_ingegno = self.webpackChunkweb_ingegno || []).push([
  [179],
  {
    141: () => {
      function gt(n) {
        return "function" == typeof n;
      }
      function sc(n) {
        const t = n((i) => {
          Error.call(i), (i.stack = new Error().stack);
        });
        return (
          (t.prototype = Object.create(Error.prototype)),
          (t.prototype.constructor = t),
          t
        );
      }
      const pd = sc(
        (n) =>
          function (t) {
            n(this),
              (this.message = t
                ? `${t.length} errors occurred during unsubscription:\n${t
                    .map((i, r) => `${r + 1}) ${i.toString()}`)
                    .join("\n  ")}`
                : ""),
              (this.name = "UnsubscriptionError"),
              (this.errors = t);
          },
      );
      function ua(n, e) {
        if (n) {
          const t = n.indexOf(e);
          0 <= t && n.splice(t, 1);
        }
      }
      class Un {
        constructor(e) {
          (this.initialTeardown = e),
            (this.closed = !1),
            (this._parentage = null),
            (this._finalizers = null);
        }
        unsubscribe() {
          let e;
          if (!this.closed) {
            this.closed = !0;
            const { _parentage: t } = this;
            if (t)
              if (((this._parentage = null), Array.isArray(t)))
                for (const s of t) s.remove(this);
              else t.remove(this);
            const { initialTeardown: i } = this;
            if (gt(i))
              try {
                i();
              } catch (s) {
                e = s instanceof pd ? s.errors : [s];
              }
            const { _finalizers: r } = this;
            if (r) {
              this._finalizers = null;
              for (const s of r)
                try {
                  lM(s);
                } catch (o) {
                  (e = e ?? []),
                    o instanceof pd ? (e = [...e, ...o.errors]) : e.push(o);
                }
            }
            if (e) throw new pd(e);
          }
        }
        add(e) {
          var t;
          if (e && e !== this)
            if (this.closed) lM(e);
            else {
              if (e instanceof Un) {
                if (e.closed || e._hasParent(this)) return;
                e._addParent(this);
              }
              (this._finalizers =
                null !== (t = this._finalizers) && void 0 !== t ? t : []).push(
                e,
              );
            }
        }
        _hasParent(e) {
          const { _parentage: t } = this;
          return t === e || (Array.isArray(t) && t.includes(e));
        }
        _addParent(e) {
          const { _parentage: t } = this;
          this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
        }
        _removeParent(e) {
          const { _parentage: t } = this;
          t === e ? (this._parentage = null) : Array.isArray(t) && ua(t, e);
        }
        remove(e) {
          const { _finalizers: t } = this;
          t && ua(t, e), e instanceof Un && e._removeParent(this);
        }
      }
      Un.EMPTY = (() => {
        const n = new Un();
        return (n.closed = !0), n;
      })();
      const oM = Un.EMPTY;
      function aM(n) {
        return (
          n instanceof Un ||
          (n && "closed" in n && gt(n.remove) && gt(n.add) && gt(n.unsubscribe))
        );
      }
      function lM(n) {
        gt(n) ? n() : n.unsubscribe();
      }
      const ro = {
          onUnhandledError: null,
          onStoppedNotification: null,
          Promise: void 0,
          useDeprecatedSynchronousErrorHandling: !1,
          useDeprecatedNextContext: !1,
        },
        md = {
          setTimeout(n, e, ...t) {
            const { delegate: i } = md;
            return i?.setTimeout
              ? i.setTimeout(n, e, ...t)
              : setTimeout(n, e, ...t);
          },
          clearTimeout(n) {
            const { delegate: e } = md;
            return (e?.clearTimeout || clearTimeout)(n);
          },
          delegate: void 0,
        };
      function cM(n) {
        md.setTimeout(() => {
          const { onUnhandledError: e } = ro;
          if (!e) throw n;
          e(n);
        });
      }
      function vm() {}
      const eL = ym("C", void 0, void 0);
      function ym(n, e, t) {
        return { kind: n, value: e, error: t };
      }
      let so = null;
      function gd(n) {
        if (ro.useDeprecatedSynchronousErrorHandling) {
          const e = !so;
          if ((e && (so = { errorThrown: !1, error: null }), n(), e)) {
            const { errorThrown: t, error: i } = so;
            if (((so = null), t)) throw i;
          }
        } else n();
      }
      class bm extends Un {
        constructor(e) {
          super(),
            (this.isStopped = !1),
            e
              ? ((this.destination = e), aM(e) && e.add(this))
              : (this.destination = aL);
        }
        static create(e, t, i) {
          return new oc(e, t, i);
        }
        next(e) {
          this.isStopped
            ? Sm(
                (function nL(n) {
                  return ym("N", n, void 0);
                })(e),
                this,
              )
            : this._next(e);
        }
        error(e) {
          this.isStopped
            ? Sm(
                (function tL(n) {
                  return ym("E", void 0, n);
                })(e),
                this,
              )
            : ((this.isStopped = !0), this._error(e));
        }
        complete() {
          this.isStopped
            ? Sm(eL, this)
            : ((this.isStopped = !0), this._complete());
        }
        unsubscribe() {
          this.closed ||
            ((this.isStopped = !0),
            super.unsubscribe(),
            (this.destination = null));
        }
        _next(e) {
          this.destination.next(e);
        }
        _error(e) {
          try {
            this.destination.error(e);
          } finally {
            this.unsubscribe();
          }
        }
        _complete() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        }
      }
      const rL = Function.prototype.bind;
      function Mm(n, e) {
        return rL.call(n, e);
      }
      class sL {
        constructor(e) {
          this.partialObserver = e;
        }
        next(e) {
          const { partialObserver: t } = this;
          if (t.next)
            try {
              t.next(e);
            } catch (i) {
              _d(i);
            }
        }
        error(e) {
          const { partialObserver: t } = this;
          if (t.error)
            try {
              t.error(e);
            } catch (i) {
              _d(i);
            }
          else _d(e);
        }
        complete() {
          const { partialObserver: e } = this;
          if (e.complete)
            try {
              e.complete();
            } catch (t) {
              _d(t);
            }
        }
      }
      class oc extends bm {
        constructor(e, t, i) {
          let r;
          if ((super(), gt(e) || !e))
            r = {
              next: e ?? void 0,
              error: t ?? void 0,
              complete: i ?? void 0,
            };
          else {
            let s;
            this && ro.useDeprecatedNextContext
              ? ((s = Object.create(e)),
                (s.unsubscribe = () => this.unsubscribe()),
                (r = {
                  next: e.next && Mm(e.next, s),
                  error: e.error && Mm(e.error, s),
                  complete: e.complete && Mm(e.complete, s),
                }))
              : (r = e);
          }
          this.destination = new sL(r);
        }
      }
      function _d(n) {
        ro.useDeprecatedSynchronousErrorHandling
          ? (function iL(n) {
              ro.useDeprecatedSynchronousErrorHandling &&
                so &&
                ((so.errorThrown = !0), (so.error = n));
            })(n)
          : cM(n);
      }
      function Sm(n, e) {
        const { onStoppedNotification: t } = ro;
        t && md.setTimeout(() => t(n, e));
      }
      const aL = {
          closed: !0,
          next: vm,
          error: function oL(n) {
            throw n;
          },
          complete: vm,
        },
        wm =
          ("function" == typeof Symbol && Symbol.observable) || "@@observable";
      function Ss(n) {
        return n;
      }
      function uM(n) {
        return 0 === n.length
          ? Ss
          : 1 === n.length
          ? n[0]
          : function (t) {
              return n.reduce((i, r) => r(i), t);
            };
      }
      let Yt = (() => {
        class n {
          constructor(t) {
            t && (this._subscribe = t);
          }
          lift(t) {
            const i = new n();
            return (i.source = this), (i.operator = t), i;
          }
          subscribe(t, i, r) {
            const s = (function uL(n) {
              return (
                (n && n instanceof bm) ||
                ((function cL(n) {
                  return n && gt(n.next) && gt(n.error) && gt(n.complete);
                })(n) &&
                  aM(n))
              );
            })(t)
              ? t
              : new oc(t, i, r);
            return (
              gd(() => {
                const { operator: o, source: a } = this;
                s.add(
                  o
                    ? o.call(s, a)
                    : a
                    ? this._subscribe(s)
                    : this._trySubscribe(s),
                );
              }),
              s
            );
          }
          _trySubscribe(t) {
            try {
              return this._subscribe(t);
            } catch (i) {
              t.error(i);
            }
          }
          forEach(t, i) {
            return new (i = dM(i))((r, s) => {
              const o = new oc({
                next: (a) => {
                  try {
                    t(a);
                  } catch (l) {
                    s(l), o.unsubscribe();
                  }
                },
                error: s,
                complete: r,
              });
              this.subscribe(o);
            });
          }
          _subscribe(t) {
            var i;
            return null === (i = this.source) || void 0 === i
              ? void 0
              : i.subscribe(t);
          }
          [wm]() {
            return this;
          }
          pipe(...t) {
            return uM(t)(this);
          }
          toPromise(t) {
            return new (t = dM(t))((i, r) => {
              let s;
              this.subscribe(
                (o) => (s = o),
                (o) => r(o),
                () => i(s),
              );
            });
          }
        }
        return (n.create = (e) => new n(e)), n;
      })();
      function dM(n) {
        var e;
        return null !== (e = n ?? ro.Promise) && void 0 !== e ? e : Promise;
      }
      const dL = sc(
        (n) =>
          function () {
            n(this),
              (this.name = "ObjectUnsubscribedError"),
              (this.message = "object unsubscribed");
          },
      );
      let en = (() => {
        class n extends Yt {
          constructor() {
            super(),
              (this.closed = !1),
              (this.currentObservers = null),
              (this.observers = []),
              (this.isStopped = !1),
              (this.hasError = !1),
              (this.thrownError = null);
          }
          lift(t) {
            const i = new hM(this, this);
            return (i.operator = t), i;
          }
          _throwIfClosed() {
            if (this.closed) throw new dL();
          }
          next(t) {
            gd(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.currentObservers ||
                  (this.currentObservers = Array.from(this.observers));
                for (const i of this.currentObservers) i.next(t);
              }
            });
          }
          error(t) {
            gd(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                (this.hasError = this.isStopped = !0), (this.thrownError = t);
                const { observers: i } = this;
                for (; i.length; ) i.shift().error(t);
              }
            });
          }
          complete() {
            gd(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.isStopped = !0;
                const { observers: t } = this;
                for (; t.length; ) t.shift().complete();
              }
            });
          }
          unsubscribe() {
            (this.isStopped = this.closed = !0),
              (this.observers = this.currentObservers = null);
          }
          get observed() {
            var t;
            return (
              (null === (t = this.observers) || void 0 === t
                ? void 0
                : t.length) > 0
            );
          }
          _trySubscribe(t) {
            return this._throwIfClosed(), super._trySubscribe(t);
          }
          _subscribe(t) {
            return (
              this._throwIfClosed(),
              this._checkFinalizedStatuses(t),
              this._innerSubscribe(t)
            );
          }
          _innerSubscribe(t) {
            const { hasError: i, isStopped: r, observers: s } = this;
            return i || r
              ? oM
              : ((this.currentObservers = null),
                s.push(t),
                new Un(() => {
                  (this.currentObservers = null), ua(s, t);
                }));
          }
          _checkFinalizedStatuses(t) {
            const { hasError: i, thrownError: r, isStopped: s } = this;
            i ? t.error(r) : s && t.complete();
          }
          asObservable() {
            const t = new Yt();
            return (t.source = this), t;
          }
        }
        return (n.create = (e, t) => new hM(e, t)), n;
      })();
      class hM extends en {
        constructor(e, t) {
          super(), (this.destination = e), (this.source = t);
        }
        next(e) {
          var t, i;
          null ===
            (i =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.next) ||
            void 0 === i ||
            i.call(t, e);
        }
        error(e) {
          var t, i;
          null ===
            (i =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.error) ||
            void 0 === i ||
            i.call(t, e);
        }
        complete() {
          var e, t;
          null ===
            (t =
              null === (e = this.destination) || void 0 === e
                ? void 0
                : e.complete) ||
            void 0 === t ||
            t.call(e);
        }
        _subscribe(e) {
          var t, i;
          return null !==
            (i =
              null === (t = this.source) || void 0 === t
                ? void 0
                : t.subscribe(e)) && void 0 !== i
            ? i
            : oM;
        }
      }
      class Ui extends en {
        constructor(e) {
          super(), (this._value = e);
        }
        get value() {
          return this.getValue();
        }
        _subscribe(e) {
          const t = super._subscribe(e);
          return !t.closed && e.next(this._value), t;
        }
        getValue() {
          const { hasError: e, thrownError: t, _value: i } = this;
          if (e) throw t;
          return this._throwIfClosed(), i;
        }
        next(e) {
          super.next((this._value = e));
        }
      }
      function fM(n) {
        return gt(n?.lift);
      }
      function fn(n) {
        return (e) => {
          if (fM(e))
            return e.lift(function (t) {
              try {
                return n(t, this);
              } catch (i) {
                this.error(i);
              }
            });
          throw new TypeError("Unable to lift unknown Observable type");
        };
      }
      function tn(n, e, t, i, r) {
        return new hL(n, e, t, i, r);
      }
      class hL extends bm {
        constructor(e, t, i, r, s, o) {
          super(e),
            (this.onFinalize = s),
            (this.shouldUnsubscribe = o),
            (this._next = t
              ? function (a) {
                  try {
                    t(a);
                  } catch (l) {
                    e.error(l);
                  }
                }
              : super._next),
            (this._error = r
              ? function (a) {
                  try {
                    r(a);
                  } catch (l) {
                    e.error(l);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._error),
            (this._complete = i
              ? function () {
                  try {
                    i();
                  } catch (a) {
                    e.error(a);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._complete);
        }
        unsubscribe() {
          var e;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            const { closed: t } = this;
            super.unsubscribe(),
              !t &&
                (null === (e = this.onFinalize) ||
                  void 0 === e ||
                  e.call(this));
          }
        }
      }
      function Bt(n, e) {
        return fn((t, i) => {
          let r = 0;
          t.subscribe(
            tn(i, (s) => {
              i.next(n.call(e, s, r++));
            }),
          );
        });
      }
      function ws(n) {
        return this instanceof ws ? ((this.v = n), this) : new ws(n);
      }
      function _M(n) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var t,
          e = n[Symbol.asyncIterator];
        return e
          ? e.call(n)
          : ((n = (function Tm(n) {
              var e = "function" == typeof Symbol && Symbol.iterator,
                t = e && n[e],
                i = 0;
              if (t) return t.call(n);
              if (n && "number" == typeof n.length)
                return {
                  next: function () {
                    return (
                      n && i >= n.length && (n = void 0),
                      { value: n && n[i++], done: !n }
                    );
                  },
                };
              throw new TypeError(
                e
                  ? "Object is not iterable."
                  : "Symbol.iterator is not defined.",
              );
            })(n)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(s) {
          t[s] =
            n[s] &&
            function (o) {
              return new Promise(function (a, l) {
                !(function r(s, o, a, l) {
                  Promise.resolve(l).then(function (c) {
                    s({ value: c, done: a });
                  }, o);
                })(a, l, (o = n[s](o)).done, o.value);
              });
            };
        }
      }
      "function" == typeof SuppressedError && SuppressedError;
      const Dm = (n) =>
        n && "number" == typeof n.length && "function" != typeof n;
      function vM(n) {
        return gt(n?.then);
      }
      function yM(n) {
        return gt(n[wm]);
      }
      function bM(n) {
        return Symbol.asyncIterator && gt(n?.[Symbol.asyncIterator]);
      }
      function MM(n) {
        return new TypeError(
          `You provided ${
            null !== n && "object" == typeof n ? "an invalid object" : `'${n}'`
          } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`,
        );
      }
      const SM = (function NL() {
        return "function" == typeof Symbol && Symbol.iterator
          ? Symbol.iterator
          : "@@iterator";
      })();
      function wM(n) {
        return gt(n?.[SM]);
      }
      function EM(n) {
        return (function gM(n, e, t) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var r,
            i = t.apply(n, e || []),
            s = [];
          return (
            (r = {}),
            o("next"),
            o("throw"),
            o("return"),
            (r[Symbol.asyncIterator] = function () {
              return this;
            }),
            r
          );
          function o(h) {
            i[h] &&
              (r[h] = function (f) {
                return new Promise(function (p, _) {
                  s.push([h, f, p, _]) > 1 || a(h, f);
                });
              });
          }
          function a(h, f) {
            try {
              !(function l(h) {
                h.value instanceof ws
                  ? Promise.resolve(h.value.v).then(c, u)
                  : d(s[0][2], h);
              })(i[h](f));
            } catch (p) {
              d(s[0][3], p);
            }
          }
          function c(h) {
            a("next", h);
          }
          function u(h) {
            a("throw", h);
          }
          function d(h, f) {
            h(f), s.shift(), s.length && a(s[0][0], s[0][1]);
          }
        })(this, arguments, function* () {
          const t = n.getReader();
          try {
            for (;;) {
              const { value: i, done: r } = yield ws(t.read());
              if (r) return yield ws(void 0);
              yield yield ws(i);
            }
          } finally {
            t.releaseLock();
          }
        });
      }
      function CM(n) {
        return gt(n?.getReader);
      }
      function qn(n) {
        if (n instanceof Yt) return n;
        if (null != n) {
          if (yM(n))
            return (function LL(n) {
              return new Yt((e) => {
                const t = n[wm]();
                if (gt(t.subscribe)) return t.subscribe(e);
                throw new TypeError(
                  "Provided object does not correctly implement Symbol.observable",
                );
              });
            })(n);
          if (Dm(n))
            return (function FL(n) {
              return new Yt((e) => {
                for (let t = 0; t < n.length && !e.closed; t++) e.next(n[t]);
                e.complete();
              });
            })(n);
          if (vM(n))
            return (function kL(n) {
              return new Yt((e) => {
                n.then(
                  (t) => {
                    e.closed || (e.next(t), e.complete());
                  },
                  (t) => e.error(t),
                ).then(null, cM);
              });
            })(n);
          if (bM(n)) return xM(n);
          if (wM(n))
            return (function UL(n) {
              return new Yt((e) => {
                for (const t of n) if ((e.next(t), e.closed)) return;
                e.complete();
              });
            })(n);
          if (CM(n))
            return (function BL(n) {
              return xM(EM(n));
            })(n);
        }
        throw MM(n);
      }
      function xM(n) {
        return new Yt((e) => {
          (function VL(n, e) {
            var t, i, r, s;
            return (function pM(n, e, t, i) {
              return new (t || (t = Promise))(function (s, o) {
                function a(u) {
                  try {
                    c(i.next(u));
                  } catch (d) {
                    o(d);
                  }
                }
                function l(u) {
                  try {
                    c(i.throw(u));
                  } catch (d) {
                    o(d);
                  }
                }
                function c(u) {
                  u.done
                    ? s(u.value)
                    : (function r(s) {
                        return s instanceof t
                          ? s
                          : new t(function (o) {
                              o(s);
                            });
                      })(u.value).then(a, l);
                }
                c((i = i.apply(n, e || [])).next());
              });
            })(this, void 0, void 0, function* () {
              try {
                for (t = _M(n); !(i = yield t.next()).done; )
                  if ((e.next(i.value), e.closed)) return;
              } catch (o) {
                r = { error: o };
              } finally {
                try {
                  i && !i.done && (s = t.return) && (yield s.call(t));
                } finally {
                  if (r) throw r.error;
                }
              }
              e.complete();
            });
          })(n, e).catch((t) => e.error(t));
        });
      }
      function Hr(n, e, t, i = 0, r = !1) {
        const s = e.schedule(function () {
          t(), r ? n.add(this.schedule(null, i)) : this.unsubscribe();
        }, i);
        if ((n.add(s), !r)) return s;
      }
      function An(n, e, t = 1 / 0) {
        return gt(e)
          ? An((i, r) => Bt((s, o) => e(i, s, r, o))(qn(n(i, r))), t)
          : ("number" == typeof e && (t = e),
            fn((i, r) =>
              (function HL(n, e, t, i, r, s, o, a) {
                const l = [];
                let c = 0,
                  u = 0,
                  d = !1;
                const h = () => {
                    d && !l.length && !c && e.complete();
                  },
                  f = (_) => (c < i ? p(_) : l.push(_)),
                  p = (_) => {
                    s && e.next(_), c++;
                    let g = !1;
                    qn(t(_, u++)).subscribe(
                      tn(
                        e,
                        (m) => {
                          r?.(m), s ? f(m) : e.next(m);
                        },
                        () => {
                          g = !0;
                        },
                        void 0,
                        () => {
                          if (g)
                            try {
                              for (c--; l.length && c < i; ) {
                                const m = l.shift();
                                o ? Hr(e, o, () => p(m)) : p(m);
                              }
                              h();
                            } catch (m) {
                              e.error(m);
                            }
                        },
                      ),
                    );
                  };
                return (
                  n.subscribe(
                    tn(e, f, () => {
                      (d = !0), h();
                    }),
                  ),
                  () => {
                    a?.();
                  }
                );
              })(i, r, n, t),
            ));
      }
      function da(n = 1 / 0) {
        return An(Ss, n);
      }
      const yr = new Yt((n) => n.complete());
      function TM(n) {
        return n && gt(n.schedule);
      }
      function Am(n) {
        return n[n.length - 1];
      }
      function ac(n) {
        return TM(Am(n)) ? n.pop() : void 0;
      }
      function AM(n, e = 0) {
        return fn((t, i) => {
          t.subscribe(
            tn(
              i,
              (r) => Hr(i, n, () => i.next(r), e),
              () => Hr(i, n, () => i.complete(), e),
              (r) => Hr(i, n, () => i.error(r), e),
            ),
          );
        });
      }
      function IM(n, e = 0) {
        return fn((t, i) => {
          i.add(n.schedule(() => t.subscribe(i), e));
        });
      }
      function RM(n, e) {
        if (!n) throw new Error("Iterable cannot be null");
        return new Yt((t) => {
          Hr(t, e, () => {
            const i = n[Symbol.asyncIterator]();
            Hr(
              t,
              e,
              () => {
                i.next().then((r) => {
                  r.done ? t.complete() : t.next(r.value);
                });
              },
              0,
              !0,
            );
          });
        });
      }
      function Sn(n, e) {
        return e
          ? (function YL(n, e) {
              if (null != n) {
                if (yM(n))
                  return (function WL(n, e) {
                    return qn(n).pipe(IM(e), AM(e));
                  })(n, e);
                if (Dm(n))
                  return (function jL(n, e) {
                    return new Yt((t) => {
                      let i = 0;
                      return e.schedule(function () {
                        i === n.length
                          ? t.complete()
                          : (t.next(n[i++]), t.closed || this.schedule());
                      });
                    });
                  })(n, e);
                if (vM(n))
                  return (function $L(n, e) {
                    return qn(n).pipe(IM(e), AM(e));
                  })(n, e);
                if (bM(n)) return RM(n, e);
                if (wM(n))
                  return (function qL(n, e) {
                    return new Yt((t) => {
                      let i;
                      return (
                        Hr(t, e, () => {
                          (i = n[SM]()),
                            Hr(
                              t,
                              e,
                              () => {
                                let r, s;
                                try {
                                  ({ value: r, done: s } = i.next());
                                } catch (o) {
                                  return void t.error(o);
                                }
                                s ? t.complete() : t.next(r);
                              },
                              0,
                              !0,
                            );
                        }),
                        () => gt(i?.return) && i.return()
                      );
                    });
                  })(n, e);
                if (CM(n))
                  return (function XL(n, e) {
                    return RM(EM(n), e);
                  })(n, e);
              }
              throw MM(n);
            })(n, e)
          : qn(n);
      }
      function PM(...n) {
        const e = ac(n),
          t = (function GL(n, e) {
            return "number" == typeof Am(n) ? n.pop() : e;
          })(n, 1 / 0),
          i = n;
        return i.length ? (1 === i.length ? qn(i[0]) : da(t)(Sn(i, e))) : yr;
      }
      function We(...n) {
        return Sn(n, ac(n));
      }
      function OM(n = {}) {
        const {
          connector: e = () => new en(),
          resetOnError: t = !0,
          resetOnComplete: i = !0,
          resetOnRefCountZero: r = !0,
        } = n;
        return (s) => {
          let o,
            a,
            l,
            c = 0,
            u = !1,
            d = !1;
          const h = () => {
              a?.unsubscribe(), (a = void 0);
            },
            f = () => {
              h(), (o = l = void 0), (u = d = !1);
            },
            p = () => {
              const _ = o;
              f(), _?.unsubscribe();
            };
          return fn((_, g) => {
            c++, !d && !u && h();
            const m = (l = l ?? e());
            g.add(() => {
              c--, 0 === c && !d && !u && (a = Im(p, r));
            }),
              m.subscribe(g),
              !o &&
                c > 0 &&
                ((o = new oc({
                  next: (y) => m.next(y),
                  error: (y) => {
                    (d = !0), h(), (a = Im(f, t, y)), m.error(y);
                  },
                  complete: () => {
                    (u = !0), h(), (a = Im(f, i)), m.complete();
                  },
                })),
                qn(_).subscribe(o));
          })(s);
        };
      }
      function Im(n, e, ...t) {
        if (!0 === e) return void n();
        if (!1 === e) return;
        const i = new oc({
          next: () => {
            i.unsubscribe(), n();
          },
        });
        return qn(e(...t)).subscribe(i);
      }
      function nr(n, e) {
        return fn((t, i) => {
          let r = null,
            s = 0,
            o = !1;
          const a = () => o && !r && i.complete();
          t.subscribe(
            tn(
              i,
              (l) => {
                r?.unsubscribe();
                let c = 0;
                const u = s++;
                qn(n(l, u)).subscribe(
                  (r = tn(
                    i,
                    (d) => i.next(e ? e(l, d, u, c++) : d),
                    () => {
                      (r = null), a();
                    },
                  )),
                );
              },
              () => {
                (o = !0), a();
              },
            ),
          );
        });
      }
      function KL(n, e) {
        return n === e;
      }
      function Pt(n) {
        for (let e in n) if (n[e] === Pt) return e;
        throw Error("Could not find renamed property on target object.");
      }
      function vd(n, e) {
        for (const t in e)
          e.hasOwnProperty(t) && !n.hasOwnProperty(t) && (n[t] = e[t]);
      }
      function wn(n) {
        if ("string" == typeof n) return n;
        if (Array.isArray(n)) return "[" + n.map(wn).join(", ") + "]";
        if (null == n) return "" + n;
        if (n.overriddenName) return `${n.overriddenName}`;
        if (n.name) return `${n.name}`;
        const e = n.toString();
        if (null == e) return "" + e;
        const t = e.indexOf("\n");
        return -1 === t ? e : e.substring(0, t);
      }
      function Rm(n, e) {
        return null == n || "" === n
          ? null === e
            ? ""
            : e
          : null == e || "" === e
          ? n
          : n + " " + e;
      }
      const QL = Pt({ __forward_ref__: Pt });
      function Ot(n) {
        return (
          (n.__forward_ref__ = Ot),
          (n.toString = function () {
            return wn(this());
          }),
          n
        );
      }
      function $e(n) {
        return Pm(n) ? n() : n;
      }
      function Pm(n) {
        return (
          "function" == typeof n &&
          n.hasOwnProperty(QL) &&
          n.__forward_ref__ === Ot
        );
      }
      function Om(n) {
        return n && !!n.ɵproviders;
      }
      const NM = "https://g.co/ng/security#xss";
      class Y extends Error {
        constructor(e, t) {
          super(
            (function yd(n, e) {
              return `NG0${Math.abs(n)}${e ? ": " + e : ""}`;
            })(e, t),
          ),
            (this.code = e);
        }
      }
      function qe(n) {
        return "string" == typeof n ? n : null == n ? "" : String(n);
      }
      function Nm(n, e) {
        throw new Y(-201, !1);
      }
      function Bi(n, e) {
        null == n &&
          (function wt(n, e, t, i) {
            throw new Error(
              `ASSERTION ERROR: ${n}` +
                (null == i ? "" : ` [Expected=> ${t} ${i} ${e} <=Actual]`),
            );
          })(e, n, null, "!=");
      }
      function Ee(n) {
        return {
          token: n.token,
          providedIn: n.providedIn || null,
          factory: n.factory,
          value: void 0,
        };
      }
      function bt(n) {
        return { providers: n.providers || [], imports: n.imports || [] };
      }
      function bd(n) {
        return LM(n, Md) || LM(n, kM);
      }
      function LM(n, e) {
        return n.hasOwnProperty(e) ? n[e] : null;
      }
      function FM(n) {
        return n && (n.hasOwnProperty(Lm) || n.hasOwnProperty(oF))
          ? n[Lm]
          : null;
      }
      const Md = Pt({ ɵprov: Pt }),
        Lm = Pt({ ɵinj: Pt }),
        kM = Pt({ ngInjectableDef: Pt }),
        oF = Pt({ ngInjectorDef: Pt });
      var ct = (function (n) {
        return (
          (n[(n.Default = 0)] = "Default"),
          (n[(n.Host = 1)] = "Host"),
          (n[(n.Self = 2)] = "Self"),
          (n[(n.SkipSelf = 4)] = "SkipSelf"),
          (n[(n.Optional = 8)] = "Optional"),
          n
        );
      })(ct || {});
      let Fm;
      function ai(n) {
        const e = Fm;
        return (Fm = n), e;
      }
      function BM(n, e, t) {
        const i = bd(n);
        return i && "root" == i.providedIn
          ? void 0 === i.value
            ? (i.value = i.factory())
            : i.value
          : t & ct.Optional
          ? null
          : void 0 !== e
          ? e
          : void Nm(wn(n));
      }
      const Vt = (() =>
          (typeof globalThis < "u" && globalThis) ||
          (typeof global < "u" && global) ||
          (typeof window < "u" && window) ||
          (typeof self < "u" &&
            typeof WorkerGlobalScope < "u" &&
            self instanceof WorkerGlobalScope &&
            self))(),
        lc = {},
        km = "__NG_DI_FLAG__",
        Sd = "ngTempTokenPath",
        lF = /\n/gm,
        VM = "__source";
      let ha;
      function Es(n) {
        const e = ha;
        return (ha = n), e;
      }
      function dF(n, e = ct.Default) {
        if (void 0 === ha) throw new Y(-203, !1);
        return null === ha
          ? BM(n, void 0, e)
          : ha.get(n, e & ct.Optional ? null : void 0, e);
      }
      function se(n, e = ct.Default) {
        return (
          (function UM() {
            return Fm;
          })() || dF
        )($e(n), e);
      }
      function Te(n, e = ct.Default) {
        return se(n, wd(e));
      }
      function wd(n) {
        return typeof n > "u" || "number" == typeof n
          ? n
          : 0 |
              (n.optional && 8) |
              (n.host && 1) |
              (n.self && 2) |
              (n.skipSelf && 4);
      }
      function Um(n) {
        const e = [];
        for (let t = 0; t < n.length; t++) {
          const i = $e(n[t]);
          if (Array.isArray(i)) {
            if (0 === i.length) throw new Y(900, !1);
            let r,
              s = ct.Default;
            for (let o = 0; o < i.length; o++) {
              const a = i[o],
                l = hF(a);
              "number" == typeof l
                ? -1 === l
                  ? (r = a.token)
                  : (s |= l)
                : (r = a);
            }
            e.push(se(r, s));
          } else e.push(se(i));
        }
        return e;
      }
      function cc(n, e) {
        return (n[km] = e), (n.prototype[km] = e), n;
      }
      function hF(n) {
        return n[km];
      }
      function zr(n) {
        return { toString: n }.toString();
      }
      var Ed = (function (n) {
          return (
            (n[(n.OnPush = 0)] = "OnPush"), (n[(n.Default = 1)] = "Default"), n
          );
        })(Ed || {}),
        Vi = (function (n) {
          return (
            (n[(n.Emulated = 0)] = "Emulated"),
            (n[(n.None = 2)] = "None"),
            (n[(n.ShadowDom = 3)] = "ShadowDom"),
            n
          );
        })(Vi || {});
      const br = {},
        Mt = [],
        Cd = Pt({ ɵcmp: Pt }),
        Bm = Pt({ ɵdir: Pt }),
        Vm = Pt({ ɵpipe: Pt }),
        zM = Pt({ ɵmod: Pt }),
        Gr = Pt({ ɵfac: Pt }),
        uc = Pt({ __NG_ELEMENT_ID__: Pt }),
        GM = Pt({ __NG_ENV_ID__: Pt });
      function WM(n, e, t) {
        let i = n.length;
        for (;;) {
          const r = n.indexOf(e, t);
          if (-1 === r) return r;
          if (0 === r || n.charCodeAt(r - 1) <= 32) {
            const s = e.length;
            if (r + s === i || n.charCodeAt(r + s) <= 32) return r;
          }
          t = r + 1;
        }
      }
      function Hm(n, e, t) {
        let i = 0;
        for (; i < t.length; ) {
          const r = t[i];
          if ("number" == typeof r) {
            if (0 !== r) break;
            i++;
            const s = t[i++],
              o = t[i++],
              a = t[i++];
            n.setAttribute(e, o, a, s);
          } else {
            const s = r,
              o = t[++i];
            jM(s) ? n.setProperty(e, s, o) : n.setAttribute(e, s, o), i++;
          }
        }
        return i;
      }
      function $M(n) {
        return 3 === n || 4 === n || 6 === n;
      }
      function jM(n) {
        return 64 === n.charCodeAt(0);
      }
      function dc(n, e) {
        if (null !== e && 0 !== e.length)
          if (null === n || 0 === n.length) n = e.slice();
          else {
            let t = -1;
            for (let i = 0; i < e.length; i++) {
              const r = e[i];
              "number" == typeof r
                ? (t = r)
                : 0 === t ||
                  qM(n, t, r, null, -1 === t || 2 === t ? e[++i] : null);
            }
          }
        return n;
      }
      function qM(n, e, t, i, r) {
        let s = 0,
          o = n.length;
        if (-1 === e) o = -1;
        else
          for (; s < n.length; ) {
            const a = n[s++];
            if ("number" == typeof a) {
              if (a === e) {
                o = -1;
                break;
              }
              if (a > e) {
                o = s - 1;
                break;
              }
            }
          }
        for (; s < n.length; ) {
          const a = n[s];
          if ("number" == typeof a) break;
          if (a === t) {
            if (null === i) return void (null !== r && (n[s + 1] = r));
            if (i === n[s + 1]) return void (n[s + 2] = r);
          }
          s++, null !== i && s++, null !== r && s++;
        }
        -1 !== o && (n.splice(o, 0, e), (s = o + 1)),
          n.splice(s++, 0, t),
          null !== i && n.splice(s++, 0, i),
          null !== r && n.splice(s++, 0, r);
      }
      const XM = "ng-template";
      function mF(n, e, t) {
        let i = 0,
          r = !0;
        for (; i < n.length; ) {
          let s = n[i++];
          if ("string" == typeof s && r) {
            const o = n[i++];
            if (t && "class" === s && -1 !== WM(o.toLowerCase(), e, 0))
              return !0;
          } else {
            if (1 === s) {
              for (; i < n.length && "string" == typeof (s = n[i++]); )
                if (s.toLowerCase() === e) return !0;
              return !1;
            }
            "number" == typeof s && (r = !1);
          }
        }
        return !1;
      }
      function YM(n) {
        return 4 === n.type && n.value !== XM;
      }
      function gF(n, e, t) {
        return e === (4 !== n.type || t ? n.value : XM);
      }
      function _F(n, e, t) {
        let i = 4;
        const r = n.attrs || [],
          s = (function bF(n) {
            for (let e = 0; e < n.length; e++) if ($M(n[e])) return e;
            return n.length;
          })(r);
        let o = !1;
        for (let a = 0; a < e.length; a++) {
          const l = e[a];
          if ("number" != typeof l) {
            if (!o)
              if (4 & i) {
                if (
                  ((i = 2 | (1 & i)),
                  ("" !== l && !gF(n, l, t)) || ("" === l && 1 === e.length))
                ) {
                  if (ir(i)) return !1;
                  o = !0;
                }
              } else {
                const c = 8 & i ? l : e[++a];
                if (8 & i && null !== n.attrs) {
                  if (!mF(n.attrs, c, t)) {
                    if (ir(i)) return !1;
                    o = !0;
                  }
                  continue;
                }
                const d = vF(8 & i ? "class" : l, r, YM(n), t);
                if (-1 === d) {
                  if (ir(i)) return !1;
                  o = !0;
                  continue;
                }
                if ("" !== c) {
                  let h;
                  h = d > s ? "" : r[d + 1].toLowerCase();
                  const f = 8 & i ? h : null;
                  if ((f && -1 !== WM(f, c, 0)) || (2 & i && c !== h)) {
                    if (ir(i)) return !1;
                    o = !0;
                  }
                }
              }
          } else {
            if (!o && !ir(i) && !ir(l)) return !1;
            if (o && ir(l)) continue;
            (o = !1), (i = l | (1 & i));
          }
        }
        return ir(i) || o;
      }
      function ir(n) {
        return 0 == (1 & n);
      }
      function vF(n, e, t, i) {
        if (null === e) return -1;
        let r = 0;
        if (i || !t) {
          let s = !1;
          for (; r < e.length; ) {
            const o = e[r];
            if (o === n) return r;
            if (3 === o || 6 === o) s = !0;
            else {
              if (1 === o || 2 === o) {
                let a = e[++r];
                for (; "string" == typeof a; ) a = e[++r];
                continue;
              }
              if (4 === o) break;
              if (0 === o) {
                r += 4;
                continue;
              }
            }
            r += s ? 1 : 2;
          }
          return -1;
        }
        return (function MF(n, e) {
          let t = n.indexOf(4);
          if (t > -1)
            for (t++; t < n.length; ) {
              const i = n[t];
              if ("number" == typeof i) return -1;
              if (i === e) return t;
              t++;
            }
          return -1;
        })(e, n);
      }
      function ZM(n, e, t = !1) {
        for (let i = 0; i < e.length; i++) if (_F(n, e[i], t)) return !0;
        return !1;
      }
      function KM(n, e) {
        return n ? ":not(" + e.trim() + ")" : e;
      }
      function wF(n) {
        let e = n[0],
          t = 1,
          i = 2,
          r = "",
          s = !1;
        for (; t < n.length; ) {
          let o = n[t];
          if ("string" == typeof o)
            if (2 & i) {
              const a = n[++t];
              r += "[" + o + (a.length > 0 ? '="' + a + '"' : "") + "]";
            } else 8 & i ? (r += "." + o) : 4 & i && (r += " " + o);
          else
            "" !== r && !ir(o) && ((e += KM(s, r)), (r = "")),
              (i = o),
              (s = s || !ir(i));
          t++;
        }
        return "" !== r && (e += KM(s, r)), e;
      }
      function Hi(n) {
        return zr(() => {
          const e = JM(n),
            t = {
              ...e,
              decls: n.decls,
              vars: n.vars,
              template: n.template,
              consts: n.consts || null,
              ngContentSelectors: n.ngContentSelectors,
              onPush: n.changeDetection === Ed.OnPush,
              directiveDefs: null,
              pipeDefs: null,
              dependencies: (e.standalone && n.dependencies) || null,
              getStandaloneInjector: null,
              signals: n.signals ?? !1,
              data: n.data || {},
              encapsulation: n.encapsulation || Vi.Emulated,
              styles: n.styles || Mt,
              _: null,
              schemas: n.schemas || null,
              tView: null,
              id: "",
            };
          eS(t);
          const i = n.dependencies;
          return (
            (t.directiveDefs = xd(i, !1)),
            (t.pipeDefs = xd(i, !0)),
            (t.id = (function RF(n) {
              let e = 0;
              const t = [
                n.selectors,
                n.ngContentSelectors,
                n.hostVars,
                n.hostAttrs,
                n.consts,
                n.vars,
                n.decls,
                n.encapsulation,
                n.standalone,
                n.signals,
                n.exportAs,
                JSON.stringify(n.inputs),
                JSON.stringify(n.outputs),
                Object.getOwnPropertyNames(n.type.prototype),
                !!n.contentQueries,
                !!n.viewQuery,
              ].join("|");
              for (const r of t) e = (Math.imul(31, e) + r.charCodeAt(0)) << 0;
              return (e += 2147483648), "c" + e;
            })(t)),
            t
          );
        });
      }
      function TF(n) {
        return Ct(n) || Bn(n);
      }
      function DF(n) {
        return null !== n;
      }
      function Et(n) {
        return zr(() => ({
          type: n.type,
          bootstrap: n.bootstrap || Mt,
          declarations: n.declarations || Mt,
          imports: n.imports || Mt,
          exports: n.exports || Mt,
          transitiveCompileScopes: null,
          schemas: n.schemas || null,
          id: n.id || null,
        }));
      }
      function QM(n, e) {
        if (null == n) return br;
        const t = {};
        for (const i in n)
          if (n.hasOwnProperty(i)) {
            let r = n[i],
              s = r;
            Array.isArray(r) && ((s = r[1]), (r = r[0])),
              (t[r] = i),
              e && (e[r] = s);
          }
        return t;
      }
      function Ue(n) {
        return zr(() => {
          const e = JM(n);
          return eS(e), e;
        });
      }
      function Ct(n) {
        return n[Cd] || null;
      }
      function Bn(n) {
        return n[Bm] || null;
      }
      function ci(n) {
        return n[Vm] || null;
      }
      function yi(n, e) {
        const t = n[zM] || null;
        if (!t && !0 === e)
          throw new Error(`Type ${wn(n)} does not have '\u0275mod' property.`);
        return t;
      }
      function JM(n) {
        const e = {};
        return {
          type: n.type,
          providersResolver: null,
          factory: null,
          hostBindings: n.hostBindings || null,
          hostVars: n.hostVars || 0,
          hostAttrs: n.hostAttrs || null,
          contentQueries: n.contentQueries || null,
          declaredInputs: e,
          inputTransforms: null,
          inputConfig: n.inputs || br,
          exportAs: n.exportAs || null,
          standalone: !0 === n.standalone,
          signals: !0 === n.signals,
          selectors: n.selectors || Mt,
          viewQuery: n.viewQuery || null,
          features: n.features || null,
          setInput: null,
          findHostDirectiveDefs: null,
          hostDirectives: null,
          inputs: QM(n.inputs, e),
          outputs: QM(n.outputs),
        };
      }
      function eS(n) {
        n.features?.forEach((e) => e(n));
      }
      function xd(n, e) {
        if (!n) return null;
        const t = e ? ci : TF;
        return () =>
          ("function" == typeof n ? n() : n).map((i) => t(i)).filter(DF);
      }
      const En = 0,
        we = 1,
        Ze = 2,
        Zt = 3,
        rr = 4,
        hc = 5,
        Vn = 6,
        pa = 7,
        an = 8,
        ma = 9,
        ao = 10,
        Ke = 11,
        fc = 12,
        tS = 13,
        ga = 14,
        ln = 15,
        pc = 16,
        _a = 17,
        Mr = 18,
        mc = 19,
        nS = 20,
        Cs = 21,
        Wr = 22,
        Td = 23,
        Dd = 24,
        dt = 25,
        zm = 1,
        iS = 2,
        Sr = 7,
        va = 9,
        Hn = 11;
      function bi(n) {
        return Array.isArray(n) && "object" == typeof n[zm];
      }
      function ui(n) {
        return Array.isArray(n) && !0 === n[zm];
      }
      function Gm(n) {
        return 0 != (4 & n.flags);
      }
      function lo(n) {
        return n.componentOffset > -1;
      }
      function Id(n) {
        return 1 == (1 & n.flags);
      }
      function sr(n) {
        return !!n.template;
      }
      function Wm(n) {
        return 0 != (512 & n[Ze]);
      }
      function co(n, e) {
        return n.hasOwnProperty(Gr) ? n[Gr] : null;
      }
      let kF =
          Vt.WeakRef ??
          class FF {
            constructor(e) {
              this.ref = e;
            }
            deref() {
              return this.ref;
            }
          },
        BF = 0,
        wr = null,
        Rd = !1;
      function In(n) {
        const e = wr;
        return (wr = n), e;
      }
      class lS {
        constructor() {
          (this.id = BF++),
            (this.ref = (function UF(n) {
              return new kF(n);
            })(this)),
            (this.producers = new Map()),
            (this.consumers = new Map()),
            (this.trackingVersion = 0),
            (this.valueVersion = 0);
        }
        consumerPollProducersForChange() {
          for (const [e, t] of this.producers) {
            const i = t.producerNode.deref();
            if (null != i && t.atTrackingVersion === this.trackingVersion) {
              if (i.producerPollStatus(t.seenValueVersion)) return !0;
            } else this.producers.delete(e), i?.consumers.delete(this.id);
          }
          return !1;
        }
        producerMayHaveChanged() {
          const e = Rd;
          Rd = !0;
          try {
            for (const [t, i] of this.consumers) {
              const r = i.consumerNode.deref();
              null != r && r.trackingVersion === i.atTrackingVersion
                ? r.onConsumerDependencyMayHaveChanged()
                : (this.consumers.delete(t), r?.producers.delete(this.id));
            }
          } finally {
            Rd = e;
          }
        }
        producerAccessed() {
          if (Rd) throw new Error("");
          if (null === wr) return;
          let e = wr.producers.get(this.id);
          void 0 === e
            ? ((e = {
                consumerNode: wr.ref,
                producerNode: this.ref,
                seenValueVersion: this.valueVersion,
                atTrackingVersion: wr.trackingVersion,
              }),
              wr.producers.set(this.id, e),
              this.consumers.set(wr.id, e))
            : ((e.seenValueVersion = this.valueVersion),
              (e.atTrackingVersion = wr.trackingVersion));
        }
        get hasProducers() {
          return this.producers.size > 0;
        }
        get producerUpdatesAllowed() {
          return !1 !== wr?.consumerAllowSignalWrites;
        }
        producerPollStatus(e) {
          return (
            this.valueVersion !== e ||
            (this.onProducerUpdateValueVersion(), this.valueVersion !== e)
          );
        }
      }
      let cS = null;
      const dS = () => {};
      class GF extends lS {
        constructor(e, t, i) {
          super(),
            (this.watch = e),
            (this.schedule = t),
            (this.dirty = !1),
            (this.cleanupFn = dS),
            (this.registerOnCleanup = (r) => {
              this.cleanupFn = r;
            }),
            (this.consumerAllowSignalWrites = i);
        }
        notify() {
          this.dirty || this.schedule(this), (this.dirty = !0);
        }
        onConsumerDependencyMayHaveChanged() {
          this.notify();
        }
        onProducerUpdateValueVersion() {}
        run() {
          if (
            ((this.dirty = !1),
            0 !== this.trackingVersion &&
              !this.consumerPollProducersForChange())
          )
            return;
          const e = In(this);
          this.trackingVersion++;
          try {
            this.cleanupFn(),
              (this.cleanupFn = dS),
              this.watch(this.registerOnCleanup);
          } finally {
            In(e);
          }
        }
        cleanup() {
          this.cleanupFn();
        }
      }
      class WF {
        constructor(e, t, i) {
          (this.previousValue = e),
            (this.currentValue = t),
            (this.firstChange = i);
        }
        isFirstChange() {
          return this.firstChange;
        }
      }
      function zi() {
        return hS;
      }
      function hS(n) {
        return n.type.prototype.ngOnChanges && (n.setInput = jF), $F;
      }
      function $F() {
        const n = pS(this),
          e = n?.current;
        if (e) {
          const t = n.previous;
          if (t === br) n.previous = e;
          else for (let i in e) t[i] = e[i];
          (n.current = null), this.ngOnChanges(e);
        }
      }
      function jF(n, e, t, i) {
        const r = this.declaredInputs[t],
          s =
            pS(n) ||
            (function qF(n, e) {
              return (n[fS] = e);
            })(n, { previous: br, current: null }),
          o = s.current || (s.current = {}),
          a = s.previous,
          l = a[r];
        (o[r] = new WF(l && l.currentValue, e, a === br)), (n[i] = e);
      }
      zi.ngInherit = !0;
      const fS = "__ngSimpleChanges__";
      function pS(n) {
        return n[fS] || null;
      }
      const Er = function (n, e, t) {};
      function jt(n) {
        for (; Array.isArray(n); ) n = n[En];
        return n;
      }
      function Nd(n, e) {
        return jt(e[n]);
      }
      function di(n, e) {
        return jt(e[n.index]);
      }
      function _S(n, e) {
        return n.data[e];
      }
      function Mi(n, e) {
        const t = e[n];
        return bi(t) ? t : t[En];
      }
      function xs(n, e) {
        return null == e ? null : n[e];
      }
      function vS(n) {
        n[_a] = 0;
      }
      function ek(n) {
        1024 & n[Ze] || ((n[Ze] |= 1024), bS(n, 1));
      }
      function yS(n) {
        1024 & n[Ze] && ((n[Ze] &= -1025), bS(n, -1));
      }
      function bS(n, e) {
        let t = n[Zt];
        if (null === t) return;
        t[hc] += e;
        let i = t;
        for (
          t = t[Zt];
          null !== t && ((1 === e && 1 === i[hc]) || (-1 === e && 0 === i[hc]));

        )
          (t[hc] += e), (i = t), (t = t[Zt]);
      }
      const Ge = {
        lFrame: OS(null),
        bindingsEnabled: !0,
        skipHydrationRootTNode: null,
      };
      function wS() {
        return Ge.bindingsEnabled;
      }
      function ne() {
        return Ge.lFrame.lView;
      }
      function vt() {
        return Ge.lFrame.tView;
      }
      function Nn() {
        let n = xS();
        for (; null !== n && 64 === n.type; ) n = n.parent;
        return n;
      }
      function xS() {
        return Ge.lFrame.currentTNode;
      }
      function Cr(n, e) {
        const t = Ge.lFrame;
        (t.currentTNode = n), (t.isParent = e);
      }
      function Zm() {
        return Ge.lFrame.isParent;
      }
      function Ma() {
        return Ge.lFrame.bindingIndex++;
      }
      function jr(n) {
        const e = Ge.lFrame,
          t = e.bindingIndex;
        return (e.bindingIndex = e.bindingIndex + n), t;
      }
      function hk(n, e) {
        const t = Ge.lFrame;
        (t.bindingIndex = t.bindingRootIndex = n), Qm(e);
      }
      function Qm(n) {
        Ge.lFrame.currentDirectiveIndex = n;
      }
      function IS() {
        return Ge.lFrame.currentQueryIndex;
      }
      function eg(n) {
        Ge.lFrame.currentQueryIndex = n;
      }
      function pk(n) {
        const e = n[we];
        return 2 === e.type ? e.declTNode : 1 === e.type ? n[Vn] : null;
      }
      function RS(n, e, t) {
        if (t & ct.SkipSelf) {
          let r = e,
            s = n;
          for (
            ;
            !((r = r.parent),
            null !== r ||
              t & ct.Host ||
              ((r = pk(s)), null === r || ((s = s[ga]), 10 & r.type)));

          );
          if (null === r) return !1;
          (e = r), (n = s);
        }
        const i = (Ge.lFrame = PS());
        return (i.currentTNode = e), (i.lView = n), !0;
      }
      function tg(n) {
        const e = PS(),
          t = n[we];
        (Ge.lFrame = e),
          (e.currentTNode = t.firstChild),
          (e.lView = n),
          (e.tView = t),
          (e.contextLView = n),
          (e.bindingIndex = t.bindingStartIndex),
          (e.inI18n = !1);
      }
      function PS() {
        const n = Ge.lFrame,
          e = null === n ? null : n.child;
        return null === e ? OS(n) : e;
      }
      function OS(n) {
        const e = {
          currentTNode: null,
          isParent: !0,
          lView: null,
          tView: null,
          selectedIndex: -1,
          contextLView: null,
          elementDepthCount: 0,
          currentNamespace: null,
          currentDirectiveIndex: -1,
          bindingRootIndex: -1,
          bindingIndex: -1,
          currentQueryIndex: 0,
          parent: n,
          child: null,
          inI18n: !1,
        };
        return null !== n && (n.child = e), e;
      }
      function NS() {
        const n = Ge.lFrame;
        return (
          (Ge.lFrame = n.parent), (n.currentTNode = null), (n.lView = null), n
        );
      }
      const LS = NS;
      function ng() {
        const n = NS();
        (n.isParent = !0),
          (n.tView = null),
          (n.selectedIndex = -1),
          (n.contextLView = null),
          (n.elementDepthCount = 0),
          (n.currentDirectiveIndex = -1),
          (n.currentNamespace = null),
          (n.bindingRootIndex = -1),
          (n.bindingIndex = -1),
          (n.currentQueryIndex = 0);
      }
      function Yn() {
        return Ge.lFrame.selectedIndex;
      }
      function uo(n) {
        Ge.lFrame.selectedIndex = n;
      }
      function Kt() {
        const n = Ge.lFrame;
        return _S(n.tView, n.selectedIndex);
      }
      let kS = !0;
      function Ld() {
        return kS;
      }
      function Ts(n) {
        kS = n;
      }
      function Fd(n, e) {
        for (let t = e.directiveStart, i = e.directiveEnd; t < i; t++) {
          const s = n.data[t].type.prototype,
            {
              ngAfterContentInit: o,
              ngAfterContentChecked: a,
              ngAfterViewInit: l,
              ngAfterViewChecked: c,
              ngOnDestroy: u,
            } = s;
          o && (n.contentHooks ??= []).push(-t, o),
            a &&
              ((n.contentHooks ??= []).push(t, a),
              (n.contentCheckHooks ??= []).push(t, a)),
            l && (n.viewHooks ??= []).push(-t, l),
            c &&
              ((n.viewHooks ??= []).push(t, c),
              (n.viewCheckHooks ??= []).push(t, c)),
            null != u && (n.destroyHooks ??= []).push(t, u);
        }
      }
      function kd(n, e, t) {
        US(n, e, 3, t);
      }
      function Ud(n, e, t, i) {
        (3 & n[Ze]) === t && US(n, e, t, i);
      }
      function ig(n, e) {
        let t = n[Ze];
        (3 & t) === e && ((t &= 8191), (t += 1), (n[Ze] = t));
      }
      function US(n, e, t, i) {
        const s = i ?? -1,
          o = e.length - 1;
        let a = 0;
        for (let l = void 0 !== i ? 65535 & n[_a] : 0; l < o; l++)
          if ("number" == typeof e[l + 1]) {
            if (((a = e[l]), null != i && a >= i)) break;
          } else
            e[l] < 0 && (n[_a] += 65536),
              (a < s || -1 == s) &&
                (Sk(n, t, e, l), (n[_a] = (4294901760 & n[_a]) + l + 2)),
              l++;
      }
      function BS(n, e) {
        Er(4, n, e);
        const t = In(null);
        try {
          e.call(n);
        } finally {
          In(t), Er(5, n, e);
        }
      }
      function Sk(n, e, t, i) {
        const r = t[i] < 0,
          s = t[i + 1],
          a = n[r ? -t[i] : t[i]];
        r
          ? n[Ze] >> 13 < n[_a] >> 16 &&
            (3 & n[Ze]) === e &&
            ((n[Ze] += 8192), BS(a, s))
          : BS(a, s);
      }
      const Sa = -1;
      class vc {
        constructor(e, t, i) {
          (this.factory = e),
            (this.resolving = !1),
            (this.canSeeViewProviders = t),
            (this.injectImpl = i);
        }
      }
      function VS(n) {
        return n !== Sa;
      }
      function Bd(n) {
        return 32767 & n;
      }
      function Vd(n, e) {
        let t = (function xk(n) {
            return n >> 16;
          })(n),
          i = e;
        for (; t > 0; ) (i = i[ga]), t--;
        return i;
      }
      let sg = !0;
      function Hd(n) {
        const e = sg;
        return (sg = n), e;
      }
      const HS = 255,
        zS = 5;
      let Tk = 0;
      const xr = {};
      function zd(n, e) {
        const t = GS(n, e);
        if (-1 !== t) return t;
        const i = e[we];
        i.firstCreatePass &&
          ((n.injectorIndex = e.length),
          og(i.data, n),
          og(e, null),
          og(i.blueprint, null));
        const r = ag(n, e),
          s = n.injectorIndex;
        if (VS(r)) {
          const o = Bd(r),
            a = Vd(r, e),
            l = a[we].data;
          for (let c = 0; c < 8; c++) e[s + c] = a[o + c] | l[o + c];
        }
        return (e[s + 8] = r), s;
      }
      function og(n, e) {
        n.push(0, 0, 0, 0, 0, 0, 0, 0, e);
      }
      function GS(n, e) {
        return -1 === n.injectorIndex ||
          (n.parent && n.parent.injectorIndex === n.injectorIndex) ||
          null === e[n.injectorIndex + 8]
          ? -1
          : n.injectorIndex;
      }
      function ag(n, e) {
        if (n.parent && -1 !== n.parent.injectorIndex)
          return n.parent.injectorIndex;
        let t = 0,
          i = null,
          r = e;
        for (; null !== r; ) {
          if (((i = ZS(r)), null === i)) return Sa;
          if ((t++, (r = r[ga]), -1 !== i.injectorIndex))
            return i.injectorIndex | (t << 16);
        }
        return Sa;
      }
      function lg(n, e, t) {
        !(function Dk(n, e, t) {
          let i;
          "string" == typeof t
            ? (i = t.charCodeAt(0) || 0)
            : t.hasOwnProperty(uc) && (i = t[uc]),
            null == i && (i = t[uc] = Tk++);
          const r = i & HS;
          e.data[n + (r >> zS)] |= 1 << r;
        })(n, e, t);
      }
      function WS(n, e, t) {
        if (t & ct.Optional || void 0 !== n) return n;
        Nm();
      }
      function $S(n, e, t, i) {
        if (
          (t & ct.Optional && void 0 === i && (i = null),
          !(t & (ct.Self | ct.Host)))
        ) {
          const r = n[ma],
            s = ai(void 0);
          try {
            return r ? r.get(e, i, t & ct.Optional) : BM(e, i, t & ct.Optional);
          } finally {
            ai(s);
          }
        }
        return WS(i, 0, t);
      }
      function jS(n, e, t, i = ct.Default, r) {
        if (null !== n) {
          if (2048 & e[Ze] && !(i & ct.Self)) {
            const o = (function Ok(n, e, t, i, r) {
              let s = n,
                o = e;
              for (
                ;
                null !== s && null !== o && 2048 & o[Ze] && !(512 & o[Ze]);

              ) {
                const a = qS(s, o, t, i | ct.Self, xr);
                if (a !== xr) return a;
                let l = s.parent;
                if (!l) {
                  const c = o[nS];
                  if (c) {
                    const u = c.get(t, xr, i);
                    if (u !== xr) return u;
                  }
                  (l = ZS(o)), (o = o[ga]);
                }
                s = l;
              }
              return r;
            })(n, e, t, i, xr);
            if (o !== xr) return o;
          }
          const s = qS(n, e, t, i, xr);
          if (s !== xr) return s;
        }
        return $S(e, t, i, r);
      }
      function qS(n, e, t, i, r) {
        const s = (function Rk(n) {
          if ("string" == typeof n) return n.charCodeAt(0) || 0;
          const e = n.hasOwnProperty(uc) ? n[uc] : void 0;
          return "number" == typeof e ? (e >= 0 ? e & HS : Pk) : e;
        })(t);
        if ("function" == typeof s) {
          if (!RS(e, n, i)) return i & ct.Host ? WS(r, 0, i) : $S(e, t, i, r);
          try {
            const o = s(i);
            if (null != o || i & ct.Optional) return o;
            Nm();
          } finally {
            LS();
          }
        } else if ("number" == typeof s) {
          let o = null,
            a = GS(n, e),
            l = Sa,
            c = i & ct.Host ? e[ln][Vn] : null;
          for (
            (-1 === a || i & ct.SkipSelf) &&
            ((l = -1 === a ? ag(n, e) : e[a + 8]),
            l !== Sa && YS(i, !1)
              ? ((o = e[we]), (a = Bd(l)), (e = Vd(l, e)))
              : (a = -1));
            -1 !== a;

          ) {
            const u = e[we];
            if (XS(s, a, u.data)) {
              const d = Ik(a, e, t, o, i, c);
              if (d !== xr) return d;
            }
            (l = e[a + 8]),
              l !== Sa && YS(i, e[we].data[a + 8] === c) && XS(s, a, e)
                ? ((o = u), (a = Bd(l)), (e = Vd(l, e)))
                : (a = -1);
          }
        }
        return r;
      }
      function Ik(n, e, t, i, r, s) {
        const o = e[we],
          a = o.data[n + 8],
          u = Gd(
            a,
            o,
            t,
            null == i ? lo(a) && sg : i != o && 0 != (3 & a.type),
            r & ct.Host && s === a,
          );
        return null !== u ? ho(e, o, u, a) : xr;
      }
      function Gd(n, e, t, i, r) {
        const s = n.providerIndexes,
          o = e.data,
          a = 1048575 & s,
          l = n.directiveStart,
          u = s >> 20,
          h = r ? a + u : n.directiveEnd;
        for (let f = i ? a : a + u; f < h; f++) {
          const p = o[f];
          if ((f < l && t === p) || (f >= l && p.type === t)) return f;
        }
        if (r) {
          const f = o[l];
          if (f && sr(f) && f.type === t) return l;
        }
        return null;
      }
      function ho(n, e, t, i) {
        let r = n[t];
        const s = e.data;
        if (
          (function wk(n) {
            return n instanceof vc;
          })(r)
        ) {
          const o = r;
          o.resolving &&
            (function JL(n, e) {
              const t = e ? `. Dependency path: ${e.join(" > ")} > ${n}` : "";
              throw new Y(
                -200,
                `Circular dependency in DI detected for ${n}${t}`,
              );
            })(
              (function At(n) {
                return "function" == typeof n
                  ? n.name || n.toString()
                  : "object" == typeof n &&
                    null != n &&
                    "function" == typeof n.type
                  ? n.type.name || n.type.toString()
                  : qe(n);
              })(s[t]),
            );
          const a = Hd(o.canSeeViewProviders);
          o.resolving = !0;
          const l = o.injectImpl ? ai(o.injectImpl) : null;
          RS(n, i, ct.Default);
          try {
            (r = n[t] = o.factory(void 0, s, n, i)),
              e.firstCreatePass &&
                t >= i.directiveStart &&
                (function Mk(n, e, t) {
                  const {
                    ngOnChanges: i,
                    ngOnInit: r,
                    ngDoCheck: s,
                  } = e.type.prototype;
                  if (i) {
                    const o = hS(e);
                    (t.preOrderHooks ??= []).push(n, o),
                      (t.preOrderCheckHooks ??= []).push(n, o);
                  }
                  r && (t.preOrderHooks ??= []).push(0 - n, r),
                    s &&
                      ((t.preOrderHooks ??= []).push(n, s),
                      (t.preOrderCheckHooks ??= []).push(n, s));
                })(t, s[t], e);
          } finally {
            null !== l && ai(l), Hd(a), (o.resolving = !1), LS();
          }
        }
        return r;
      }
      function XS(n, e, t) {
        return !!(t[e + (n >> zS)] & (1 << n));
      }
      function YS(n, e) {
        return !(n & ct.Self || (n & ct.Host && e));
      }
      class wa {
        constructor(e, t) {
          (this._tNode = e), (this._lView = t);
        }
        get(e, t, i) {
          return jS(this._tNode, this._lView, e, wd(i), t);
        }
      }
      function Pk() {
        return new wa(Nn(), ne());
      }
      function cg(n) {
        return Pm(n)
          ? () => {
              const e = cg($e(n));
              return e && e();
            }
          : co(n);
      }
      function ZS(n) {
        const e = n[we],
          t = e.type;
        return 2 === t ? e.declTNode : 1 === t ? n[Vn] : null;
      }
      const Ca = "__parameters__";
      function Ta(n, e, t) {
        return zr(() => {
          const i = (function ug(n) {
            return function (...t) {
              if (n) {
                const i = n(...t);
                for (const r in i) this[r] = i[r];
              }
            };
          })(e);
          function r(...s) {
            if (this instanceof r) return i.apply(this, s), this;
            const o = new r(...s);
            return (a.annotation = o), a;
            function a(l, c, u) {
              const d = l.hasOwnProperty(Ca)
                ? l[Ca]
                : Object.defineProperty(l, Ca, { value: [] })[Ca];
              for (; d.length <= u; ) d.push(null);
              return (d[u] = d[u] || []).push(o), l;
            }
          }
          return (
            t && (r.prototype = Object.create(t.prototype)),
            (r.prototype.ngMetadataName = n),
            (r.annotationCls = r),
            r
          );
        });
      }
      function bc(n, e) {
        n.forEach((t) => (Array.isArray(t) ? bc(t, e) : e(t)));
      }
      function QS(n, e, t) {
        e >= n.length ? n.push(t) : n.splice(e, 0, t);
      }
      function $d(n, e) {
        return e >= n.length - 1 ? n.pop() : n.splice(e, 1)[0];
      }
      function Si(n, e, t) {
        let i = Aa(n, e);
        return (
          i >= 0
            ? (n[1 | i] = t)
            : ((i = ~i),
              (function Vk(n, e, t, i) {
                let r = n.length;
                if (r == e) n.push(t, i);
                else if (1 === r) n.push(i, n[0]), (n[0] = t);
                else {
                  for (r--, n.push(n[r - 1], n[r]); r > e; )
                    (n[r] = n[r - 2]), r--;
                  (n[e] = t), (n[e + 1] = i);
                }
              })(n, i, e, t)),
          i
        );
      }
      function dg(n, e) {
        const t = Aa(n, e);
        if (t >= 0) return n[1 | t];
      }
      function Aa(n, e) {
        return (function JS(n, e, t) {
          let i = 0,
            r = n.length >> t;
          for (; r !== i; ) {
            const s = i + ((r - i) >> 1),
              o = n[s << t];
            if (e === o) return s << t;
            o > e ? (r = s) : (i = s + 1);
          }
          return ~(r << t);
        })(n, e, 1);
      }
      const qd = cc(Ta("Optional"), 8),
        Xd = cc(Ta("SkipSelf"), 4);
      function Jd(n) {
        return 128 == (128 & n.flags);
      }
      var Ds = (function (n) {
        return (
          (n[(n.Important = 1)] = "Important"),
          (n[(n.DashCase = 2)] = "DashCase"),
          n
        );
      })(Ds || {});
      const gg = new Map();
      let d2 = 0;
      const vg = "__ngContext__";
      function zn(n, e) {
        bi(e)
          ? ((n[vg] = e[mc]),
            (function f2(n) {
              gg.set(n[mc], n);
            })(e))
          : (n[vg] = e);
      }
      let yg;
      function bg(n, e) {
        return yg(n, e);
      }
      function Ec(n) {
        const e = n[Zt];
        return ui(e) ? e[Zt] : e;
      }
      function yw(n) {
        return Mw(n[fc]);
      }
      function bw(n) {
        return Mw(n[rr]);
      }
      function Mw(n) {
        for (; null !== n && !ui(n); ) n = n[rr];
        return n;
      }
      function Pa(n, e, t, i, r) {
        if (null != i) {
          let s,
            o = !1;
          ui(i) ? (s = i) : bi(i) && ((o = !0), (i = i[En]));
          const a = jt(i);
          0 === n && null !== t
            ? null == r
              ? xw(e, t, a)
              : fo(e, t, a, r || null, !0)
            : 1 === n && null !== t
            ? fo(e, t, a, r || null, !0)
            : 2 === n
            ? (function sh(n, e, t) {
                const i = ih(n, e);
                i &&
                  (function P2(n, e, t, i) {
                    n.removeChild(e, t, i);
                  })(n, i, e, t);
              })(e, a, o)
            : 3 === n && e.destroyNode(a),
            null != s &&
              (function L2(n, e, t, i, r) {
                const s = t[Sr];
                s !== jt(t) && Pa(e, n, i, s, r);
                for (let a = Hn; a < t.length; a++) {
                  const l = t[a];
                  xc(l[we], l, n, e, i, s);
                }
              })(e, n, s, t, r);
        }
      }
      function nh(n, e, t) {
        return n.createElement(e, t);
      }
      function ww(n, e) {
        const t = n[va],
          i = t.indexOf(e);
        yS(e), t.splice(i, 1);
      }
      function Sg(n, e) {
        if (n.length <= Hn) return;
        const t = Hn + e,
          i = n[t];
        if (i) {
          const r = i[pc];
          null !== r && r !== n && ww(r, i), e > 0 && (n[t - 1][rr] = i[rr]);
          const s = $d(n, Hn + e);
          !(function E2(n, e) {
            xc(n, e, e[Ke], 2, null, null), (e[En] = null), (e[Vn] = null);
          })(i[we], i);
          const o = s[Mr];
          null !== o && o.detachView(s[we]),
            (i[Zt] = null),
            (i[rr] = null),
            (i[Ze] &= -129);
        }
        return i;
      }
      function Ew(n, e) {
        if (!(256 & e[Ze])) {
          const t = e[Ke];
          e[Td]?.destroy(),
            e[Dd]?.destroy(),
            t.destroyNode && xc(n, e, t, 3, null, null),
            (function T2(n) {
              let e = n[fc];
              if (!e) return wg(n[we], n);
              for (; e; ) {
                let t = null;
                if (bi(e)) t = e[fc];
                else {
                  const i = e[Hn];
                  i && (t = i);
                }
                if (!t) {
                  for (; e && !e[rr] && e !== n; )
                    bi(e) && wg(e[we], e), (e = e[Zt]);
                  null === e && (e = n),
                    bi(e) && wg(e[we], e),
                    (t = e && e[rr]);
                }
                e = t;
              }
            })(e);
        }
      }
      function wg(n, e) {
        if (!(256 & e[Ze])) {
          (e[Ze] &= -129),
            (e[Ze] |= 256),
            (function R2(n, e) {
              let t;
              if (null != n && null != (t = n.destroyHooks))
                for (let i = 0; i < t.length; i += 2) {
                  const r = e[t[i]];
                  if (!(r instanceof vc)) {
                    const s = t[i + 1];
                    if (Array.isArray(s))
                      for (let o = 0; o < s.length; o += 2) {
                        const a = r[s[o]],
                          l = s[o + 1];
                        Er(4, a, l);
                        try {
                          l.call(a);
                        } finally {
                          Er(5, a, l);
                        }
                      }
                    else {
                      Er(4, r, s);
                      try {
                        s.call(r);
                      } finally {
                        Er(5, r, s);
                      }
                    }
                  }
                }
            })(n, e),
            (function I2(n, e) {
              const t = n.cleanup,
                i = e[pa];
              if (null !== t)
                for (let s = 0; s < t.length - 1; s += 2)
                  if ("string" == typeof t[s]) {
                    const o = t[s + 3];
                    o >= 0 ? i[o]() : i[-o].unsubscribe(), (s += 2);
                  } else t[s].call(i[t[s + 1]]);
              null !== i && (e[pa] = null);
              const r = e[Cs];
              if (null !== r) {
                e[Cs] = null;
                for (let s = 0; s < r.length; s++) (0, r[s])();
              }
            })(n, e),
            1 === e[we].type && e[Ke].destroy();
          const t = e[pc];
          if (null !== t && ui(e[Zt])) {
            t !== e[Zt] && ww(t, e);
            const i = e[Mr];
            null !== i && i.detachView(n);
          }
          !(function p2(n) {
            gg.delete(n[mc]);
          })(e);
        }
      }
      function Eg(n, e, t) {
        return (function Cw(n, e, t) {
          let i = e;
          for (; null !== i && 40 & i.type; ) i = (e = i).parent;
          if (null === i) return t[En];
          {
            const { componentOffset: r } = i;
            if (r > -1) {
              const { encapsulation: s } = n.data[i.directiveStart + r];
              if (s === Vi.None || s === Vi.Emulated) return null;
            }
            return di(i, t);
          }
        })(n, e.parent, t);
      }
      function fo(n, e, t, i, r) {
        n.insertBefore(e, t, i, r);
      }
      function xw(n, e, t) {
        n.appendChild(e, t);
      }
      function Tw(n, e, t, i, r) {
        null !== i ? fo(n, e, t, i, r) : xw(n, e, t);
      }
      function ih(n, e) {
        return n.parentNode(e);
      }
      let Cg,
        Ag,
        Iw = function Aw(n, e, t) {
          return 40 & n.type ? di(n, t) : null;
        };
      function rh(n, e, t, i) {
        const r = Eg(n, i, e),
          s = e[Ke],
          a = (function Dw(n, e, t) {
            return Iw(n, e, t);
          })(i.parent || e[Vn], i, e);
        if (null != r)
          if (Array.isArray(t))
            for (let l = 0; l < t.length; l++) Tw(s, r, t[l], a, !1);
          else Tw(s, r, t, a, !1);
        void 0 !== Cg && Cg(s, i, e, t, r);
      }
      function Cc(n, e) {
        if (null !== e) {
          const t = e.type;
          if (3 & t) return di(e, n);
          if (4 & t) return xg(-1, n[e.index]);
          if (8 & t) {
            const i = e.child;
            if (null !== i) return Cc(n, i);
            {
              const r = n[e.index];
              return ui(r) ? xg(-1, r) : jt(r);
            }
          }
          if (32 & t) return bg(e, n)() || jt(n[e.index]);
          {
            const i = Pw(n, e);
            return null !== i
              ? Array.isArray(i)
                ? i[0]
                : Cc(Ec(n[ln]), i)
              : Cc(n, e.next);
          }
        }
        return null;
      }
      function Pw(n, e) {
        return null !== e ? n[ln][Vn].projection[e.projection] : null;
      }
      function xg(n, e) {
        const t = Hn + n + 1;
        if (t < e.length) {
          const i = e[t],
            r = i[we].firstChild;
          if (null !== r) return Cc(i, r);
        }
        return e[Sr];
      }
      function Tg(n, e, t, i, r, s, o) {
        for (; null != t; ) {
          const a = i[t.index],
            l = t.type;
          if (
            (o && 0 === e && (a && zn(jt(a), i), (t.flags |= 2)),
            32 != (32 & t.flags))
          )
            if (8 & l) Tg(n, e, t.child, i, r, s, !1), Pa(e, n, r, a, s);
            else if (32 & l) {
              const c = bg(t, i);
              let u;
              for (; (u = c()); ) Pa(e, n, r, u, s);
              Pa(e, n, r, a, s);
            } else 16 & l ? Nw(n, e, i, t, r, s) : Pa(e, n, r, a, s);
          t = o ? t.projectionNext : t.next;
        }
      }
      function xc(n, e, t, i, r, s) {
        Tg(t, i, n.firstChild, e, r, s, !1);
      }
      function Nw(n, e, t, i, r, s) {
        const o = t[ln],
          l = o[Vn].projection[i.projection];
        if (Array.isArray(l))
          for (let c = 0; c < l.length; c++) Pa(e, n, r, l[c], s);
        else {
          let c = l;
          const u = o[Zt];
          Jd(i) && (c.flags |= 128), Tg(n, e, c, u, r, s, !0);
        }
      }
      function Lw(n, e, t) {
        "" === t
          ? n.removeAttribute(e, "class")
          : n.setAttribute(e, "class", t);
      }
      function Fw(n, e, t) {
        const { mergedAttrs: i, classes: r, styles: s } = t;
        null !== i && Hm(n, e, i),
          null !== r && Lw(n, e, r),
          null !== s &&
            (function k2(n, e, t) {
              n.setAttribute(e, "style", t);
            })(n, e, s);
      }
      class Vw {
        constructor(e) {
          this.changingThisBreaksApplicationSecurity = e;
        }
        toString() {
          return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${NM})`;
        }
      }
      function As(n) {
        return n instanceof Vw ? n.changingThisBreaksApplicationSecurity : n;
      }
      const K2 = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
      var Na = (function (n) {
        return (
          (n[(n.NONE = 0)] = "NONE"),
          (n[(n.HTML = 1)] = "HTML"),
          (n[(n.STYLE = 2)] = "STYLE"),
          (n[(n.SCRIPT = 3)] = "SCRIPT"),
          (n[(n.URL = 4)] = "URL"),
          (n[(n.RESOURCE_URL = 5)] = "RESOURCE_URL"),
          n
        );
      })(Na || {});
      function ch(n) {
        const e = (function Ic() {
          const n = ne();
          return n && n[ao].sanitizer;
        })();
        return e
          ? e.sanitize(Na.URL, n) || ""
          : (function Dc(n, e) {
              const t = (function q2(n) {
                return (n instanceof Vw && n.getTypeName()) || null;
              })(n);
              if (null != t && t !== e) {
                if ("ResourceURL" === t && "URL" === e) return !0;
                throw new Error(`Required a safe ${e}, got a ${t} (see ${NM})`);
              }
              return t === e;
            })(n, "URL")
          ? As(n)
          : (function Rg(n) {
              return (n = String(n)).match(K2) ? n : "unsafe:" + n;
            })(qe(n));
      }
      class ve {
        constructor(e, t) {
          (this._desc = e),
            (this.ngMetadataName = "InjectionToken"),
            (this.ɵprov = void 0),
            "number" == typeof t
              ? (this.__NG_ELEMENT_ID__ = t)
              : void 0 !== t &&
                (this.ɵprov = Ee({
                  token: this,
                  providedIn: t.providedIn || "root",
                  factory: t.factory,
                }));
        }
        get multi() {
          return this;
        }
        toString() {
          return `InjectionToken ${this._desc}`;
        }
      }
      const Rc = new ve("ENVIRONMENT_INITIALIZER"),
        Yw = new ve("INJECTOR", -1),
        Zw = new ve("INJECTOR_DEF_TYPES");
      class Kw {
        get(e, t = lc) {
          if (t === lc) {
            const i = new Error(`NullInjectorError: No provider for ${wn(e)}!`);
            throw ((i.name = "NullInjectorError"), i);
          }
          return t;
        }
      }
      function uU(...n) {
        return { ɵproviders: Jw(0, n), ɵfromNgModule: !0 };
      }
      function Jw(n, ...e) {
        const t = [],
          i = new Set();
        let r;
        return (
          bc(e, (s) => {
            const o = s;
            Lg(o, t, [], i) && ((r ||= []), r.push(o));
          }),
          void 0 !== r && eE(r, t),
          t
        );
      }
      function eE(n, e) {
        for (let t = 0; t < n.length; t++) {
          const { providers: r } = n[t];
          Fg(r, (s) => {
            e.push(s);
          });
        }
      }
      function Lg(n, e, t, i) {
        if (!(n = $e(n))) return !1;
        let r = null,
          s = FM(n);
        const o = !s && Ct(n);
        if (s || o) {
          if (o && !o.standalone) return !1;
          r = n;
        } else {
          const l = n.ngModule;
          if (((s = FM(l)), !s)) return !1;
          r = l;
        }
        const a = i.has(r);
        if (o) {
          if (a) return !1;
          if ((i.add(r), o.dependencies)) {
            const l =
              "function" == typeof o.dependencies
                ? o.dependencies()
                : o.dependencies;
            for (const c of l) Lg(c, e, t, i);
          }
        } else {
          if (!s) return !1;
          {
            if (null != s.imports && !a) {
              let c;
              i.add(r);
              try {
                bc(s.imports, (u) => {
                  Lg(u, e, t, i) && ((c ||= []), c.push(u));
                });
              } finally {
              }
              void 0 !== c && eE(c, e);
            }
            if (!a) {
              const c = co(r) || (() => new r());
              e.push(
                { provide: r, useFactory: c, deps: Mt },
                { provide: Zw, useValue: r, multi: !0 },
                { provide: Rc, useValue: () => se(r), multi: !0 },
              );
            }
            const l = s.providers;
            null == l ||
              a ||
              Fg(l, (u) => {
                e.push(u);
              });
          }
        }
        return r !== n && void 0 !== n.providers;
      }
      function Fg(n, e) {
        for (let t of n)
          Om(t) && (t = t.ɵproviders), Array.isArray(t) ? Fg(t, e) : e(t);
      }
      const dU = Pt({ provide: String, useValue: Pt });
      function kg(n) {
        return null !== n && "object" == typeof n && dU in n;
      }
      function po(n) {
        return "function" == typeof n;
      }
      const Ug = new ve("Set Injector scope."),
        uh = {},
        fU = {};
      let Bg;
      function dh() {
        return void 0 === Bg && (Bg = new Kw()), Bg;
      }
      class Xr {}
      class Vg extends Xr {
        get destroyed() {
          return this._destroyed;
        }
        constructor(e, t, i, r) {
          super(),
            (this.parent = t),
            (this.source = i),
            (this.scopes = r),
            (this.records = new Map()),
            (this._ngOnDestroyHooks = new Set()),
            (this._onDestroyHooks = []),
            (this._destroyed = !1),
            zg(e, (o) => this.processProvider(o)),
            this.records.set(Yw, La(void 0, this)),
            r.has("environment") && this.records.set(Xr, La(void 0, this));
          const s = this.records.get(Ug);
          null != s && "string" == typeof s.value && this.scopes.add(s.value),
            (this.injectorDefTypes = new Set(this.get(Zw.multi, Mt, ct.Self)));
        }
        destroy() {
          this.assertNotDestroyed(), (this._destroyed = !0);
          try {
            for (const t of this._ngOnDestroyHooks) t.ngOnDestroy();
            const e = this._onDestroyHooks;
            this._onDestroyHooks = [];
            for (const t of e) t();
          } finally {
            this.records.clear(),
              this._ngOnDestroyHooks.clear(),
              this.injectorDefTypes.clear();
          }
        }
        onDestroy(e) {
          return (
            this.assertNotDestroyed(),
            this._onDestroyHooks.push(e),
            () => this.removeOnDestroy(e)
          );
        }
        runInContext(e) {
          this.assertNotDestroyed();
          const t = Es(this),
            i = ai(void 0);
          try {
            return e();
          } finally {
            Es(t), ai(i);
          }
        }
        get(e, t = lc, i = ct.Default) {
          if ((this.assertNotDestroyed(), e.hasOwnProperty(GM)))
            return e[GM](this);
          i = wd(i);
          const r = Es(this),
            s = ai(void 0);
          try {
            if (!(i & ct.SkipSelf)) {
              let a = this.records.get(e);
              if (void 0 === a) {
                const l =
                  (function vU(n) {
                    return (
                      "function" == typeof n ||
                      ("object" == typeof n && n instanceof ve)
                    );
                  })(e) && bd(e);
                (a = l && this.injectableDefInScope(l) ? La(Hg(e), uh) : null),
                  this.records.set(e, a);
              }
              if (null != a) return this.hydrate(e, a);
            }
            return (i & ct.Self ? dh() : this.parent).get(
              e,
              (t = i & ct.Optional && t === lc ? null : t),
            );
          } catch (o) {
            if ("NullInjectorError" === o.name) {
              if (((o[Sd] = o[Sd] || []).unshift(wn(e)), r)) throw o;
              return (function fF(n, e, t, i) {
                const r = n[Sd];
                throw (
                  (e[VM] && r.unshift(e[VM]),
                  (n.message = (function pF(n, e, t, i = null) {
                    n =
                      n && "\n" === n.charAt(0) && "\u0275" == n.charAt(1)
                        ? n.slice(2)
                        : n;
                    let r = wn(e);
                    if (Array.isArray(e)) r = e.map(wn).join(" -> ");
                    else if ("object" == typeof e) {
                      let s = [];
                      for (let o in e)
                        if (e.hasOwnProperty(o)) {
                          let a = e[o];
                          s.push(
                            o +
                              ":" +
                              ("string" == typeof a
                                ? JSON.stringify(a)
                                : wn(a)),
                          );
                        }
                      r = `{${s.join(", ")}}`;
                    }
                    return `${t}${i ? "(" + i + ")" : ""}[${r}]: ${n.replace(
                      lF,
                      "\n  ",
                    )}`;
                  })("\n" + n.message, r, t, i)),
                  (n.ngTokenPath = r),
                  (n[Sd] = null),
                  n)
                );
              })(o, e, "R3InjectorError", this.source);
            }
            throw o;
          } finally {
            ai(s), Es(r);
          }
        }
        resolveInjectorInitializers() {
          const e = Es(this),
            t = ai(void 0);
          try {
            const i = this.get(Rc.multi, Mt, ct.Self);
            for (const r of i) r();
          } finally {
            Es(e), ai(t);
          }
        }
        toString() {
          const e = [],
            t = this.records;
          for (const i of t.keys()) e.push(wn(i));
          return `R3Injector[${e.join(", ")}]`;
        }
        assertNotDestroyed() {
          if (this._destroyed) throw new Y(205, !1);
        }
        processProvider(e) {
          let t = po((e = $e(e))) ? e : $e(e && e.provide);
          const i = (function mU(n) {
            return kg(n) ? La(void 0, n.useValue) : La(iE(n), uh);
          })(e);
          if (po(e) || !0 !== e.multi) this.records.get(t);
          else {
            let r = this.records.get(t);
            r ||
              ((r = La(void 0, uh, !0)),
              (r.factory = () => Um(r.multi)),
              this.records.set(t, r)),
              (t = e),
              r.multi.push(e);
          }
          this.records.set(t, i);
        }
        hydrate(e, t) {
          return (
            t.value === uh && ((t.value = fU), (t.value = t.factory())),
            "object" == typeof t.value &&
              t.value &&
              (function _U(n) {
                return (
                  null !== n &&
                  "object" == typeof n &&
                  "function" == typeof n.ngOnDestroy
                );
              })(t.value) &&
              this._ngOnDestroyHooks.add(t.value),
            t.value
          );
        }
        injectableDefInScope(e) {
          if (!e.providedIn) return !1;
          const t = $e(e.providedIn);
          return "string" == typeof t
            ? "any" === t || this.scopes.has(t)
            : this.injectorDefTypes.has(t);
        }
        removeOnDestroy(e) {
          const t = this._onDestroyHooks.indexOf(e);
          -1 !== t && this._onDestroyHooks.splice(t, 1);
        }
      }
      function Hg(n) {
        const e = bd(n),
          t = null !== e ? e.factory : co(n);
        if (null !== t) return t;
        if (n instanceof ve) throw new Y(204, !1);
        if (n instanceof Function)
          return (function pU(n) {
            const e = n.length;
            if (e > 0)
              throw (
                ((function Mc(n, e) {
                  const t = [];
                  for (let i = 0; i < n; i++) t.push(e);
                  return t;
                })(e, "?"),
                new Y(204, !1))
              );
            const t = (function sF(n) {
              return (n && (n[Md] || n[kM])) || null;
            })(n);
            return null !== t ? () => t.factory(n) : () => new n();
          })(n);
        throw new Y(204, !1);
      }
      function iE(n, e, t) {
        let i;
        if (po(n)) {
          const r = $e(n);
          return co(r) || Hg(r);
        }
        if (kg(n)) i = () => $e(n.useValue);
        else if (
          (function nE(n) {
            return !(!n || !n.useFactory);
          })(n)
        )
          i = () => n.useFactory(...Um(n.deps || []));
        else if (
          (function tE(n) {
            return !(!n || !n.useExisting);
          })(n)
        )
          i = () => se($e(n.useExisting));
        else {
          const r = $e(n && (n.useClass || n.provide));
          if (
            !(function gU(n) {
              return !!n.deps;
            })(n)
          )
            return co(r) || Hg(r);
          i = () => new r(...Um(n.deps));
        }
        return i;
      }
      function La(n, e, t = !1) {
        return { factory: n, value: e, multi: t ? [] : void 0 };
      }
      function zg(n, e) {
        for (const t of n)
          Array.isArray(t) ? zg(t, e) : t && Om(t) ? zg(t.ɵproviders, e) : e(t);
      }
      const hh = new ve("AppId", { providedIn: "root", factory: () => yU }),
        yU = "ng",
        rE = new ve("Platform Initializer"),
        mo = new ve("Platform ID", {
          providedIn: "platform",
          factory: () => "unknown",
        }),
        Gg = new ve("AnimationModuleType"),
        sE = new ve("CSP nonce", {
          providedIn: "root",
          factory: () =>
            (function Tc() {
              if (void 0 !== Ag) return Ag;
              if (typeof document < "u") return document;
              throw new Y(210, !1);
            })()
              .body?.querySelector("[ngCspNonce]")
              ?.getAttribute("ngCspNonce") || null,
        });
      let aE = (n, e) => null;
      function lE(n, e) {
        return aE(n, e);
      }
      class DU {}
      class dE {}
      class IU {
        resolveComponentFactory(e) {
          throw (function AU(n) {
            const e = Error(`No component factory found for ${wn(n)}.`);
            return (e.ngComponent = n), e;
          })(e);
        }
      }
      let go = (() => {
        class n {}
        return (n.NULL = new IU()), n;
      })();
      function RU() {
        return ka(Nn(), ne());
      }
      function ka(n, e) {
        return new Rn(di(n, e));
      }
      let Rn = (() => {
        class n {
          constructor(t) {
            this.nativeElement = t;
          }
        }
        return (n.__NG_ELEMENT_ID__ = RU), n;
      })();
      function PU(n) {
        return n instanceof Rn ? n.nativeElement : n;
      }
      class Nc {}
      let or = (() => {
          class n {
            constructor() {
              this.destroyNode = null;
            }
          }
          return (
            (n.__NG_ELEMENT_ID__ = () =>
              (function OU() {
                const n = ne(),
                  t = Mi(Nn().index, n);
                return (bi(t) ? t : n)[Ke];
              })()),
            n
          );
        })(),
        NU = (() => {
          class n {}
          return (
            (n.ɵprov = Ee({
              token: n,
              providedIn: "root",
              factory: () => null,
            })),
            n
          );
        })();
      class Lc {
        constructor(e) {
          (this.full = e),
            (this.major = e.split(".")[0]),
            (this.minor = e.split(".")[1]),
            (this.patch = e.split(".").slice(2).join("."));
        }
      }
      const LU = new Lc("16.1.8"),
        e_ = {};
      function Fc(n) {
        for (; n; ) {
          n[Ze] |= 64;
          const e = Ec(n);
          if (Wm(n) && !e) return n;
          n = e;
        }
        return null;
      }
      function t_(n) {
        return n.ngOriginalError;
      }
      class _o {
        constructor() {
          this._console = console;
        }
        handleError(e) {
          const t = this._findOriginalError(e);
          this._console.error("ERROR", e),
            t && this._console.error("ORIGINAL ERROR", t);
        }
        _findOriginalError(e) {
          let t = e && t_(e);
          for (; t && t_(t); ) t = t_(t);
          return t || null;
        }
      }
      const mE = new ve("", { providedIn: "root", factory: () => !1 });
      function gE(n) {
        return n.ownerDocument.defaultView;
      }
      function Yr(n) {
        return n instanceof Function ? n() : n;
      }
      class ME extends lS {
        constructor() {
          super(...arguments),
            (this.consumerAllowSignalWrites = !1),
            (this._lView = null);
        }
        set lView(e) {
          this._lView = e;
        }
        onConsumerDependencyMayHaveChanged() {
          Fc(this._lView);
        }
        onProducerUpdateValueVersion() {}
        get hasReadASignal() {
          return this.hasProducers;
        }
        runInContext(e, t, i) {
          const r = In(this);
          this.trackingVersion++;
          try {
            e(t, i);
          } finally {
            In(r);
          }
        }
        destroy() {
          this.trackingVersion++;
        }
      }
      let vh = null;
      function SE() {
        return (vh ??= new ME()), vh;
      }
      function wE(n, e) {
        return n[e] ?? SE();
      }
      function EE(n, e) {
        const t = SE();
        t.hasReadASignal && ((n[e] = vh), (t.lView = n), (vh = new ME()));
      }
      const Qe = {};
      function Wi(n) {
        CE(vt(), ne(), Yn() + n, !1);
      }
      function CE(n, e, t, i) {
        if (!i)
          if (3 == (3 & e[Ze])) {
            const s = n.preOrderCheckHooks;
            null !== s && kd(e, s, t);
          } else {
            const s = n.preOrderHooks;
            null !== s && Ud(e, s, 0, t);
          }
        uo(t);
      }
      function AE(n, e = null, t = null, i) {
        const r = IE(n, e, t, i);
        return r.resolveInjectorInitializers(), r;
      }
      function IE(n, e = null, t = null, i, r = new Set()) {
        const s = [t || Mt, uU(n)];
        return (
          (i = i || ("object" == typeof n ? void 0 : wn(n))),
          new Vg(s, e || dh(), i || null, r)
        );
      }
      let fi = (() => {
        class n {
          static create(t, i) {
            if (Array.isArray(t)) return AE({ name: "" }, i, t, "");
            {
              const r = t.name ?? "";
              return AE({ name: r }, t.parent, t.providers, r);
            }
          }
        }
        return (
          (n.THROW_IF_NOT_FOUND = lc),
          (n.NULL = new Kw()),
          (n.ɵprov = Ee({
            token: n,
            providedIn: "any",
            factory: () => se(Yw),
          })),
          (n.__NG_ELEMENT_ID__ = -1),
          n
        );
      })();
      function re(n, e = ct.Default) {
        const t = ne();
        return null === t ? se(n, e) : jS(Nn(), t, $e(n), e);
      }
      function yh(n, e, t, i, r, s, o, a, l, c, u) {
        const d = e.blueprint.slice();
        return (
          (d[En] = r),
          (d[Ze] = 140 | i),
          (null !== c || (n && 2048 & n[Ze])) && (d[Ze] |= 2048),
          vS(d),
          (d[Zt] = d[ga] = n),
          (d[an] = t),
          (d[ao] = o || (n && n[ao])),
          (d[Ke] = a || (n && n[Ke])),
          (d[ma] = l || (n && n[ma]) || null),
          (d[Vn] = s),
          (d[mc] = (function h2() {
            return d2++;
          })()),
          (d[Wr] = u),
          (d[nS] = c),
          (d[ln] = 2 == e.type ? n[ln] : d),
          d
        );
      }
      function Ba(n, e, t, i, r) {
        let s = n.data[e];
        if (null === s)
          (s = (function n_(n, e, t, i, r) {
            const s = xS(),
              o = Zm(),
              l = (n.data[e] = (function tB(n, e, t, i, r, s) {
                let o = e ? e.injectorIndex : -1,
                  a = 0;
                return (
                  (function ba() {
                    return null !== Ge.skipHydrationRootTNode;
                  })() && (a |= 128),
                  {
                    type: t,
                    index: i,
                    insertBeforeIndex: null,
                    injectorIndex: o,
                    directiveStart: -1,
                    directiveEnd: -1,
                    directiveStylingLast: -1,
                    componentOffset: -1,
                    propertyBindings: null,
                    flags: a,
                    providerIndexes: 0,
                    value: r,
                    attrs: s,
                    mergedAttrs: null,
                    localNames: null,
                    initialInputs: void 0,
                    inputs: null,
                    outputs: null,
                    tView: null,
                    next: null,
                    prev: null,
                    projectionNext: null,
                    child: null,
                    parent: e,
                    projection: null,
                    styles: null,
                    stylesWithoutHost: null,
                    residualStyles: void 0,
                    classes: null,
                    classesWithoutHost: null,
                    residualClasses: void 0,
                    classBindings: 0,
                    styleBindings: 0,
                  }
                );
              })(0, o ? s : s && s.parent, t, e, i, r));
            return (
              null === n.firstChild && (n.firstChild = l),
              null !== s &&
                (o
                  ? null == s.child && null !== l.parent && (s.child = l)
                  : null === s.next && ((s.next = l), (l.prev = s))),
              l
            );
          })(n, e, t, i, r)),
            (function dk() {
              return Ge.lFrame.inI18n;
            })() && (s.flags |= 32);
        else if (64 & s.type) {
          (s.type = t), (s.value = i), (s.attrs = r);
          const o = (function _c() {
            const n = Ge.lFrame,
              e = n.currentTNode;
            return n.isParent ? e : e.parent;
          })();
          s.injectorIndex = null === o ? -1 : o.injectorIndex;
        }
        return Cr(s, !0), s;
      }
      function kc(n, e, t, i) {
        if (0 === t) return -1;
        const r = e.length;
        for (let s = 0; s < t; s++)
          e.push(i), n.blueprint.push(i), n.data.push(null);
        return r;
      }
      function PE(n, e, t, i, r) {
        const s = wE(e, Td),
          o = Yn(),
          a = 2 & i;
        try {
          if (
            (uo(-1),
            a && e.length > dt && CE(n, e, dt, !1),
            Er(a ? 2 : 0, r),
            a)
          )
            s.runInContext(t, i, r);
          else {
            const c = In(null);
            try {
              t(i, r);
            } finally {
              In(c);
            }
          }
        } finally {
          a && null === e[Td] && EE(e, Td), uo(o), Er(a ? 3 : 1, r);
        }
      }
      function i_(n, e, t) {
        if (Gm(e)) {
          const i = In(null);
          try {
            const s = e.directiveEnd;
            for (let o = e.directiveStart; o < s; o++) {
              const a = n.data[o];
              a.contentQueries && a.contentQueries(1, t[o], o);
            }
          } finally {
            In(i);
          }
        }
      }
      function r_(n, e, t) {
        wS() &&
          ((function lB(n, e, t, i) {
            const r = t.directiveStart,
              s = t.directiveEnd;
            lo(t) &&
              (function mB(n, e, t) {
                const i = di(e, n),
                  r = OE(t);
                let o = 16;
                t.signals ? (o = 4096) : t.onPush && (o = 64);
                const a = bh(
                  n,
                  yh(
                    n,
                    r,
                    null,
                    o,
                    i,
                    e,
                    null,
                    n[ao].rendererFactory.createRenderer(i, t),
                    null,
                    null,
                    null,
                  ),
                );
                n[e.index] = a;
              })(e, t, n.data[r + t.componentOffset]),
              n.firstCreatePass || zd(t, e),
              zn(i, e);
            const o = t.initialInputs;
            for (let a = r; a < s; a++) {
              const l = n.data[a],
                c = ho(e, n, a, t);
              zn(c, e),
                null !== o && gB(0, a - r, c, l, 0, o),
                sr(l) && (Mi(t.index, e)[an] = ho(e, n, a, t));
            }
          })(n, e, t, di(t, e)),
          64 == (64 & t.flags) && UE(n, e, t));
      }
      function s_(n, e, t = di) {
        const i = e.localNames;
        if (null !== i) {
          let r = e.index + 1;
          for (let s = 0; s < i.length; s += 2) {
            const o = i[s + 1],
              a = -1 === o ? t(e, n) : n[o];
            n[r++] = a;
          }
        }
      }
      function OE(n) {
        const e = n.tView;
        return null === e || e.incompleteFirstPass
          ? (n.tView = o_(
              1,
              null,
              n.template,
              n.decls,
              n.vars,
              n.directiveDefs,
              n.pipeDefs,
              n.viewQuery,
              n.schemas,
              n.consts,
              n.id,
            ))
          : e;
      }
      function o_(n, e, t, i, r, s, o, a, l, c, u) {
        const d = dt + i,
          h = d + r,
          f = (function YU(n, e) {
            const t = [];
            for (let i = 0; i < e; i++) t.push(i < n ? null : Qe);
            return t;
          })(d, h),
          p = "function" == typeof c ? c() : c;
        return (f[we] = {
          type: n,
          blueprint: f,
          template: t,
          queries: null,
          viewQuery: a,
          declTNode: e,
          data: f.slice().fill(null, d),
          bindingStartIndex: d,
          expandoStartIndex: h,
          hostBindingOpCodes: null,
          firstCreatePass: !0,
          firstUpdatePass: !0,
          staticViewQueries: !1,
          staticContentQueries: !1,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: "function" == typeof s ? s() : s,
          pipeRegistry: "function" == typeof o ? o() : o,
          firstChild: null,
          schemas: l,
          consts: p,
          incompleteFirstPass: !1,
          ssrId: u,
        });
      }
      let NE = (n) => null;
      function LE(n, e, t, i) {
        for (let r in n)
          if (n.hasOwnProperty(r)) {
            t = null === t ? {} : t;
            const s = n[r];
            null === i
              ? FE(t, e, r, s)
              : i.hasOwnProperty(r) && FE(t, e, i[r], s);
          }
        return t;
      }
      function FE(n, e, t, i) {
        n.hasOwnProperty(t) ? n[t].push(e, i) : (n[t] = [e, i]);
      }
      function wi(n, e, t, i, r, s, o, a) {
        const l = di(e, t);
        let u,
          c = e.inputs;
        !a && null != c && (u = c[i])
          ? (d_(n, t, u, i, r),
            lo(e) &&
              (function rB(n, e) {
                const t = Mi(e, n);
                16 & t[Ze] || (t[Ze] |= 64);
              })(t, e.index))
          : 3 & e.type &&
            ((i = (function iB(n) {
              return "class" === n
                ? "className"
                : "for" === n
                ? "htmlFor"
                : "formaction" === n
                ? "formAction"
                : "innerHtml" === n
                ? "innerHTML"
                : "readonly" === n
                ? "readOnly"
                : "tabindex" === n
                ? "tabIndex"
                : n;
            })(i)),
            (r = null != o ? o(r, e.value || "", i) : r),
            s.setProperty(l, i, r));
      }
      function a_(n, e, t, i) {
        if (wS()) {
          const r = null === i ? null : { "": -1 },
            s = (function uB(n, e) {
              const t = n.directiveRegistry;
              let i = null,
                r = null;
              if (t)
                for (let s = 0; s < t.length; s++) {
                  const o = t[s];
                  if (ZM(e, o.selectors, !1))
                    if ((i || (i = []), sr(o)))
                      if (null !== o.findHostDirectiveDefs) {
                        const a = [];
                        (r = r || new Map()),
                          o.findHostDirectiveDefs(o, a, r),
                          i.unshift(...a, o),
                          l_(n, e, a.length);
                      } else i.unshift(o), l_(n, e, 0);
                    else
                      (r = r || new Map()),
                        o.findHostDirectiveDefs?.(o, i, r),
                        i.push(o);
                }
              return null === i ? null : [i, r];
            })(n, t);
          let o, a;
          null === s ? (o = a = null) : ([o, a] = s),
            null !== o && kE(n, e, t, o, r, a),
            r &&
              (function dB(n, e, t) {
                if (e) {
                  const i = (n.localNames = []);
                  for (let r = 0; r < e.length; r += 2) {
                    const s = t[e[r + 1]];
                    if (null == s) throw new Y(-301, !1);
                    i.push(e[r], s);
                  }
                }
              })(t, i, r);
        }
        t.mergedAttrs = dc(t.mergedAttrs, t.attrs);
      }
      function kE(n, e, t, i, r, s) {
        for (let c = 0; c < i.length; c++) lg(zd(t, e), n, i[c].type);
        !(function fB(n, e, t) {
          (n.flags |= 1),
            (n.directiveStart = e),
            (n.directiveEnd = e + t),
            (n.providerIndexes = e);
        })(t, n.data.length, i.length);
        for (let c = 0; c < i.length; c++) {
          const u = i[c];
          u.providersResolver && u.providersResolver(u);
        }
        let o = !1,
          a = !1,
          l = kc(n, e, i.length, null);
        for (let c = 0; c < i.length; c++) {
          const u = i[c];
          (t.mergedAttrs = dc(t.mergedAttrs, u.hostAttrs)),
            pB(n, t, e, l, u),
            hB(l, u, r),
            null !== u.contentQueries && (t.flags |= 4),
            (null !== u.hostBindings ||
              null !== u.hostAttrs ||
              0 !== u.hostVars) &&
              (t.flags |= 64);
          const d = u.type.prototype;
          !o &&
            (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) &&
            ((n.preOrderHooks ??= []).push(t.index), (o = !0)),
            !a &&
              (d.ngOnChanges || d.ngDoCheck) &&
              ((n.preOrderCheckHooks ??= []).push(t.index), (a = !0)),
            l++;
        }
        !(function nB(n, e, t) {
          const r = e.directiveEnd,
            s = n.data,
            o = e.attrs,
            a = [];
          let l = null,
            c = null;
          for (let u = e.directiveStart; u < r; u++) {
            const d = s[u],
              h = t ? t.get(d) : null,
              p = h ? h.outputs : null;
            (l = LE(d.inputs, u, l, h ? h.inputs : null)),
              (c = LE(d.outputs, u, c, p));
            const _ = null === l || null === o || YM(e) ? null : _B(l, u, o);
            a.push(_);
          }
          null !== l &&
            (l.hasOwnProperty("class") && (e.flags |= 8),
            l.hasOwnProperty("style") && (e.flags |= 16)),
            (e.initialInputs = a),
            (e.inputs = l),
            (e.outputs = c);
        })(n, t, s);
      }
      function UE(n, e, t) {
        const i = t.directiveStart,
          r = t.directiveEnd,
          s = t.index,
          o = (function fk() {
            return Ge.lFrame.currentDirectiveIndex;
          })();
        try {
          uo(s);
          for (let a = i; a < r; a++) {
            const l = n.data[a],
              c = e[a];
            Qm(a),
              (null !== l.hostBindings ||
                0 !== l.hostVars ||
                null !== l.hostAttrs) &&
                cB(l, c);
          }
        } finally {
          uo(-1), Qm(o);
        }
      }
      function cB(n, e) {
        null !== n.hostBindings && n.hostBindings(1, e);
      }
      function l_(n, e, t) {
        (e.componentOffset = t), (n.components ??= []).push(e.index);
      }
      function hB(n, e, t) {
        if (t) {
          if (e.exportAs)
            for (let i = 0; i < e.exportAs.length; i++) t[e.exportAs[i]] = n;
          sr(e) && (t[""] = n);
        }
      }
      function pB(n, e, t, i, r) {
        n.data[i] = r;
        const s = r.factory || (r.factory = co(r.type)),
          o = new vc(s, sr(r), re);
        (n.blueprint[i] = o),
          (t[i] = o),
          (function oB(n, e, t, i, r) {
            const s = r.hostBindings;
            if (s) {
              let o = n.hostBindingOpCodes;
              null === o && (o = n.hostBindingOpCodes = []);
              const a = ~e.index;
              (function aB(n) {
                let e = n.length;
                for (; e > 0; ) {
                  const t = n[--e];
                  if ("number" == typeof t && t < 0) return t;
                }
                return 0;
              })(o) != a && o.push(a),
                o.push(t, i, s);
            }
          })(n, e, i, kc(n, t, r.hostVars, Qe), r);
      }
      function Tr(n, e, t, i, r, s) {
        const o = di(n, e);
        !(function c_(n, e, t, i, r, s, o) {
          if (null == s) n.removeAttribute(e, r, t);
          else {
            const a = null == o ? qe(s) : o(s, i || "", r);
            n.setAttribute(e, r, a, t);
          }
        })(e[Ke], o, s, n.value, t, i, r);
      }
      function gB(n, e, t, i, r, s) {
        const o = s[e];
        if (null !== o)
          for (let a = 0; a < o.length; ) BE(i, t, o[a++], o[a++], o[a++]);
      }
      function BE(n, e, t, i, r) {
        const s = In(null);
        try {
          const o = n.inputTransforms;
          null !== o && o.hasOwnProperty(i) && (r = o[i].call(e, r)),
            null !== n.setInput ? n.setInput(e, r, t, i) : (e[i] = r);
        } finally {
          In(s);
        }
      }
      function _B(n, e, t) {
        let i = null,
          r = 0;
        for (; r < t.length; ) {
          const s = t[r];
          if (0 !== s)
            if (5 !== s) {
              if ("number" == typeof s) break;
              if (n.hasOwnProperty(s)) {
                null === i && (i = []);
                const o = n[s];
                for (let a = 0; a < o.length; a += 2)
                  if (o[a] === e) {
                    i.push(s, o[a + 1], t[r + 1]);
                    break;
                  }
              }
              r += 2;
            } else r += 2;
          else r += 4;
        }
        return i;
      }
      function VE(n, e, t, i) {
        return [n, !0, !1, e, null, 0, i, t, null, null, null];
      }
      function HE(n, e) {
        const t = n.contentQueries;
        if (null !== t)
          for (let i = 0; i < t.length; i += 2) {
            const s = t[i + 1];
            if (-1 !== s) {
              const o = n.data[s];
              eg(t[i]), o.contentQueries(2, e[s], s);
            }
          }
      }
      function bh(n, e) {
        return n[fc] ? (n[tS][rr] = e) : (n[fc] = e), (n[tS] = e), e;
      }
      function u_(n, e, t) {
        eg(0);
        const i = In(null);
        try {
          e(n, t);
        } finally {
          In(i);
        }
      }
      function zE(n) {
        return n[pa] || (n[pa] = []);
      }
      function GE(n) {
        return n.cleanup || (n.cleanup = []);
      }
      function $E(n, e) {
        const t = n[ma],
          i = t ? t.get(_o, null) : null;
        i && i.handleError(e);
      }
      function d_(n, e, t, i, r) {
        for (let s = 0; s < t.length; ) {
          const o = t[s++],
            a = t[s++];
          BE(n.data[o], e[o], i, a, r);
        }
      }
      function vB(n, e) {
        const t = Mi(e, n),
          i = t[we];
        !(function yB(n, e) {
          for (let t = e.length; t < n.blueprint.length; t++)
            e.push(n.blueprint[t]);
        })(i, t);
        const r = t[En];
        null !== r && null === t[Wr] && (t[Wr] = lE(r, t[ma])), h_(i, t, t[an]);
      }
      function h_(n, e, t) {
        tg(e);
        try {
          const i = n.viewQuery;
          null !== i && u_(1, i, t);
          const r = n.template;
          null !== r && PE(n, e, r, 1, t),
            n.firstCreatePass && (n.firstCreatePass = !1),
            n.staticContentQueries && HE(n, e),
            n.staticViewQueries && u_(2, n.viewQuery, t);
          const s = n.components;
          null !== s &&
            (function bB(n, e) {
              for (let t = 0; t < e.length; t++) vB(n, e[t]);
            })(e, s);
        } catch (i) {
          throw (
            (n.firstCreatePass &&
              ((n.incompleteFirstPass = !0), (n.firstCreatePass = !1)),
            i)
          );
        } finally {
          (e[Ze] &= -5), ng();
        }
      }
      let jE = (() => {
        class n {
          constructor() {
            (this.all = new Set()), (this.queue = new Map());
          }
          create(t, i, r) {
            const s = typeof Zone > "u" ? null : Zone.current,
              o = new GF(
                t,
                (c) => {
                  this.all.has(c) && this.queue.set(c, s);
                },
                r,
              );
            let a;
            this.all.add(o), o.notify();
            const l = () => {
              o.cleanup(), a?.(), this.all.delete(o), this.queue.delete(o);
            };
            return (a = i?.onDestroy(l)), { destroy: l };
          }
          flush() {
            if (0 !== this.queue.size)
              for (const [t, i] of this.queue)
                this.queue.delete(t), i ? i.run(() => t.run()) : t.run();
          }
          get isQueueEmpty() {
            return 0 === this.queue.size;
          }
        }
        return (
          (n.ɵprov = Ee({
            token: n,
            providedIn: "root",
            factory: () => new n(),
          })),
          n
        );
      })();
      function Mh(n, e, t) {
        let i = t ? n.styles : null,
          r = t ? n.classes : null,
          s = 0;
        if (null !== e)
          for (let o = 0; o < e.length; o++) {
            const a = e[o];
            "number" == typeof a
              ? (s = a)
              : 1 == s
              ? (r = Rm(r, a))
              : 2 == s && (i = Rm(i, a + ": " + e[++o] + ";"));
          }
        t ? (n.styles = i) : (n.stylesWithoutHost = i),
          t ? (n.classes = r) : (n.classesWithoutHost = r);
      }
      function Uc(n, e, t, i, r = !1) {
        for (; null !== t; ) {
          const s = e[t.index];
          if ((null !== s && i.push(jt(s)), ui(s))) {
            for (let a = Hn; a < s.length; a++) {
              const l = s[a],
                c = l[we].firstChild;
              null !== c && Uc(l[we], l, c, i);
            }
            s[Sr] !== s[En] && i.push(s[Sr]);
          }
          const o = t.type;
          if (8 & o) Uc(n, e, t.child, i);
          else if (32 & o) {
            const a = bg(t, e);
            let l;
            for (; (l = a()); ) i.push(l);
          } else if (16 & o) {
            const a = Pw(e, t);
            if (Array.isArray(a)) i.push(...a);
            else {
              const l = Ec(e[ln]);
              Uc(l[we], l, a, i, !0);
            }
          }
          t = r ? t.projectionNext : t.next;
        }
        return i;
      }
      function Sh(n, e, t, i = !0) {
        const r = e[ao].rendererFactory;
        r.begin && r.begin();
        try {
          qE(n, e, n.template, t);
        } catch (o) {
          throw (i && $E(e, o), o);
        } finally {
          r.end && r.end(), e[ao].effectManager?.flush();
        }
      }
      function qE(n, e, t, i) {
        const r = e[Ze];
        if (256 != (256 & r)) {
          e[ao].effectManager?.flush(), tg(e);
          try {
            vS(e),
              (function DS(n) {
                return (Ge.lFrame.bindingIndex = n);
              })(n.bindingStartIndex),
              null !== t && PE(n, e, t, 2, i);
            const o = 3 == (3 & r);
            if (o) {
              const c = n.preOrderCheckHooks;
              null !== c && kd(e, c, null);
            } else {
              const c = n.preOrderHooks;
              null !== c && Ud(e, c, 0, null), ig(e, 0);
            }
            if (
              ((function CB(n) {
                for (let e = yw(n); null !== e; e = bw(e)) {
                  if (!e[iS]) continue;
                  const t = e[va];
                  for (let i = 0; i < t.length; i++) {
                    ek(t[i]);
                  }
                }
              })(e),
              XE(e, 2),
              null !== n.contentQueries && HE(n, e),
              o)
            ) {
              const c = n.contentCheckHooks;
              null !== c && kd(e, c);
            } else {
              const c = n.contentHooks;
              null !== c && Ud(e, c, 1), ig(e, 1);
            }
            !(function XU(n, e) {
              const t = n.hostBindingOpCodes;
              if (null === t) return;
              const i = wE(e, Dd);
              try {
                for (let r = 0; r < t.length; r++) {
                  const s = t[r];
                  if (s < 0) uo(~s);
                  else {
                    const o = s,
                      a = t[++r],
                      l = t[++r];
                    hk(a, o), i.runInContext(l, 2, e[o]);
                  }
                }
              } finally {
                null === e[Dd] && EE(e, Dd), uo(-1);
              }
            })(n, e);
            const a = n.components;
            null !== a && ZE(e, a, 0);
            const l = n.viewQuery;
            if ((null !== l && u_(2, l, i), o)) {
              const c = n.viewCheckHooks;
              null !== c && kd(e, c);
            } else {
              const c = n.viewHooks;
              null !== c && Ud(e, c, 2), ig(e, 2);
            }
            !0 === n.firstUpdatePass && (n.firstUpdatePass = !1),
              (e[Ze] &= -73),
              yS(e);
          } finally {
            ng();
          }
        }
      }
      function XE(n, e) {
        for (let t = yw(n); null !== t; t = bw(t))
          for (let i = Hn; i < t.length; i++) YE(t[i], e);
      }
      function xB(n, e, t) {
        YE(Mi(e, n), t);
      }
      function YE(n, e) {
        if (
          !(function QF(n) {
            return 128 == (128 & n[Ze]);
          })(n)
        )
          return;
        const t = n[we];
        if ((80 & n[Ze] && 0 === e) || 1024 & n[Ze] || 2 === e)
          qE(t, n, t.template, n[an]);
        else if (n[hc] > 0) {
          XE(n, 1);
          const r = n[we].components;
          null !== r && ZE(n, r, 1);
        }
      }
      function ZE(n, e, t) {
        for (let i = 0; i < e.length; i++) xB(n, e[i], t);
      }
      class Bc {
        get rootNodes() {
          const e = this._lView,
            t = e[we];
          return Uc(t, e, t.firstChild, []);
        }
        constructor(e, t) {
          (this._lView = e),
            (this._cdRefInjectingView = t),
            (this._appRef = null),
            (this._attachedToViewContainer = !1);
        }
        get context() {
          return this._lView[an];
        }
        set context(e) {
          this._lView[an] = e;
        }
        get destroyed() {
          return 256 == (256 & this._lView[Ze]);
        }
        destroy() {
          if (this._appRef) this._appRef.detachView(this);
          else if (this._attachedToViewContainer) {
            const e = this._lView[Zt];
            if (ui(e)) {
              const t = e[8],
                i = t ? t.indexOf(this) : -1;
              i > -1 && (Sg(e, i), $d(t, i));
            }
            this._attachedToViewContainer = !1;
          }
          Ew(this._lView[we], this._lView);
        }
        onDestroy(e) {
          !(function MS(n, e) {
            if (256 == (256 & n[Ze])) throw new Y(911, !1);
            null === n[Cs] && (n[Cs] = []), n[Cs].push(e);
          })(this._lView, e);
        }
        markForCheck() {
          Fc(this._cdRefInjectingView || this._lView);
        }
        detach() {
          this._lView[Ze] &= -129;
        }
        reattach() {
          this._lView[Ze] |= 128;
        }
        detectChanges() {
          Sh(this._lView[we], this._lView, this.context);
        }
        checkNoChanges() {}
        attachToViewContainerRef() {
          if (this._appRef) throw new Y(902, !1);
          this._attachedToViewContainer = !0;
        }
        detachFromAppRef() {
          (this._appRef = null),
            (function x2(n, e) {
              xc(n, e, e[Ke], 2, null, null);
            })(this._lView[we], this._lView);
        }
        attachToAppRef(e) {
          if (this._attachedToViewContainer) throw new Y(902, !1);
          this._appRef = e;
        }
      }
      class TB extends Bc {
        constructor(e) {
          super(e), (this._view = e);
        }
        detectChanges() {
          const e = this._view;
          Sh(e[we], e, e[an], !1);
        }
        checkNoChanges() {}
        get context() {
          return null;
        }
      }
      class KE extends go {
        constructor(e) {
          super(), (this.ngModule = e);
        }
        resolveComponentFactory(e) {
          const t = Ct(e);
          return new Vc(t, this.ngModule);
        }
      }
      function QE(n) {
        const e = [];
        for (let t in n)
          n.hasOwnProperty(t) && e.push({ propName: n[t], templateName: t });
        return e;
      }
      class AB {
        constructor(e, t) {
          (this.injector = e), (this.parentInjector = t);
        }
        get(e, t, i) {
          i = wd(i);
          const r = this.injector.get(e, e_, i);
          return r !== e_ || t === e_ ? r : this.parentInjector.get(e, t, i);
        }
      }
      class Vc extends dE {
        get inputs() {
          const e = this.componentDef,
            t = e.inputTransforms,
            i = QE(e.inputs);
          if (null !== t)
            for (const r of i)
              t.hasOwnProperty(r.propName) && (r.transform = t[r.propName]);
          return i;
        }
        get outputs() {
          return QE(this.componentDef.outputs);
        }
        constructor(e, t) {
          super(),
            (this.componentDef = e),
            (this.ngModule = t),
            (this.componentType = e.type),
            (this.selector = (function EF(n) {
              return n.map(wF).join(",");
            })(e.selectors)),
            (this.ngContentSelectors = e.ngContentSelectors
              ? e.ngContentSelectors
              : []),
            (this.isBoundToModule = !!t);
        }
        create(e, t, i, r) {
          let s = (r = r || this.ngModule) instanceof Xr ? r : r?.injector;
          s &&
            null !== this.componentDef.getStandaloneInjector &&
            (s = this.componentDef.getStandaloneInjector(s) || s);
          const o = s ? new AB(e, s) : e,
            a = o.get(Nc, null);
          if (null === a) throw new Y(407, !1);
          const u = {
              rendererFactory: a,
              sanitizer: o.get(NU, null),
              effectManager: o.get(jE, null),
            },
            d = a.createRenderer(null, this.componentDef),
            h = this.componentDef.selectors[0][0] || "div",
            f = i
              ? (function ZU(n, e, t, i) {
                  const s = i.get(mE, !1) || t === Vi.ShadowDom,
                    o = n.selectRootElement(e, s);
                  return (
                    (function KU(n) {
                      NE(n);
                    })(o),
                    o
                  );
                })(d, i, this.componentDef.encapsulation, o)
              : nh(
                  d,
                  h,
                  (function DB(n) {
                    const e = n.toLowerCase();
                    return "svg" === e ? "svg" : "math" === e ? "math" : null;
                  })(h),
                ),
            g = this.componentDef.signals
              ? 4608
              : this.componentDef.onPush
              ? 576
              : 528,
            m = o_(0, null, null, 1, 0, null, null, null, null, null, null),
            y = yh(null, m, null, g, null, null, u, d, o, null, null);
          let v, b;
          tg(y);
          try {
            const S = this.componentDef;
            let E,
              x = null;
            S.findHostDirectiveDefs
              ? ((E = []),
                (x = new Map()),
                S.findHostDirectiveDefs(S, E, x),
                E.push(S))
              : (E = [S]);
            const P = (function RB(n, e) {
                const t = n[we],
                  i = dt;
                return (n[i] = e), Ba(t, i, 2, "#host", null);
              })(y, f),
              M = (function PB(n, e, t, i, r, s, o) {
                const a = r[we];
                !(function OB(n, e, t, i) {
                  for (const r of n)
                    e.mergedAttrs = dc(e.mergedAttrs, r.hostAttrs);
                  null !== e.mergedAttrs &&
                    (Mh(e, e.mergedAttrs, !0), null !== t && Fw(i, t, e));
                })(i, n, e, o);
                let l = null;
                null !== e && (l = lE(e, r[ma]));
                const c = s.rendererFactory.createRenderer(e, t);
                let u = 16;
                t.signals ? (u = 4096) : t.onPush && (u = 64);
                const d = yh(
                  r,
                  OE(t),
                  null,
                  u,
                  r[n.index],
                  n,
                  s,
                  c,
                  null,
                  null,
                  l,
                );
                return (
                  a.firstCreatePass && l_(a, n, i.length - 1),
                  bh(r, d),
                  (r[n.index] = d)
                );
              })(P, f, S, E, y, u, d);
            (b = _S(m, dt)),
              f &&
                (function LB(n, e, t, i) {
                  if (i) Hm(n, t, ["ng-version", LU.full]);
                  else {
                    const { attrs: r, classes: s } = (function CF(n) {
                      const e = [],
                        t = [];
                      let i = 1,
                        r = 2;
                      for (; i < n.length; ) {
                        let s = n[i];
                        if ("string" == typeof s)
                          2 === r
                            ? "" !== s && e.push(s, n[++i])
                            : 8 === r && t.push(s);
                        else {
                          if (!ir(r)) break;
                          r = s;
                        }
                        i++;
                      }
                      return { attrs: e, classes: t };
                    })(e.selectors[0]);
                    r && Hm(n, t, r),
                      s && s.length > 0 && Lw(n, t, s.join(" "));
                  }
                })(d, S, f, i),
              void 0 !== t &&
                (function FB(n, e, t) {
                  const i = (n.projection = []);
                  for (let r = 0; r < e.length; r++) {
                    const s = t[r];
                    i.push(null != s ? Array.from(s) : null);
                  }
                })(b, this.ngContentSelectors, t),
              (v = (function NB(n, e, t, i, r, s) {
                const o = Nn(),
                  a = r[we],
                  l = di(o, r);
                kE(a, r, o, t, null, i);
                for (let u = 0; u < t.length; u++)
                  zn(ho(r, a, o.directiveStart + u, o), r);
                UE(a, r, o), l && zn(l, r);
                const c = ho(r, a, o.directiveStart + o.componentOffset, o);
                if (((n[an] = r[an] = c), null !== s))
                  for (const u of s) u(c, e);
                return i_(a, o, n), c;
              })(M, S, E, x, y, [kB])),
              h_(m, y, null);
          } finally {
            ng();
          }
          return new IB(this.componentType, v, ka(b, y), y, b);
        }
      }
      class IB extends DU {
        constructor(e, t, i, r, s) {
          super(),
            (this.location = i),
            (this._rootLView = r),
            (this._tNode = s),
            (this.previousInputValues = null),
            (this.instance = t),
            (this.hostView = this.changeDetectorRef = new TB(r)),
            (this.componentType = e);
        }
        setInput(e, t) {
          const i = this._tNode.inputs;
          let r;
          if (null !== i && (r = i[e])) {
            if (
              ((this.previousInputValues ??= new Map()),
              this.previousInputValues.has(e) &&
                Object.is(this.previousInputValues.get(e), t))
            )
              return;
            const s = this._rootLView;
            d_(s[we], s, r, e, t),
              this.previousInputValues.set(e, t),
              Fc(Mi(this._tNode.index, s));
          }
        }
        get injector() {
          return new wa(this._tNode, this._rootLView);
        }
        destroy() {
          this.hostView.destroy();
        }
        onDestroy(e) {
          this.hostView.onDestroy(e);
        }
      }
      function kB() {
        const n = Nn();
        Fd(ne()[we], n);
      }
      function It(n) {
        let e = (function JE(n) {
            return Object.getPrototypeOf(n.prototype).constructor;
          })(n.type),
          t = !0;
        const i = [n];
        for (; e; ) {
          let r;
          if (sr(n)) r = e.ɵcmp || e.ɵdir;
          else {
            if (e.ɵcmp) throw new Y(903, !1);
            r = e.ɵdir;
          }
          if (r) {
            if (t) {
              i.push(r);
              const o = n;
              (o.inputs = wh(n.inputs)),
                (o.inputTransforms = wh(n.inputTransforms)),
                (o.declaredInputs = wh(n.declaredInputs)),
                (o.outputs = wh(n.outputs));
              const a = r.hostBindings;
              a && HB(n, a);
              const l = r.viewQuery,
                c = r.contentQueries;
              if (
                (l && BB(n, l),
                c && VB(n, c),
                vd(n.inputs, r.inputs),
                vd(n.declaredInputs, r.declaredInputs),
                vd(n.outputs, r.outputs),
                null !== r.inputTransforms &&
                  (null === o.inputTransforms && (o.inputTransforms = {}),
                  vd(o.inputTransforms, r.inputTransforms)),
                sr(r) && r.data.animation)
              ) {
                const u = n.data;
                u.animation = (u.animation || []).concat(r.data.animation);
              }
            }
            const s = r.features;
            if (s)
              for (let o = 0; o < s.length; o++) {
                const a = s[o];
                a && a.ngInherit && a(n), a === It && (t = !1);
              }
          }
          e = Object.getPrototypeOf(e);
        }
        !(function UB(n) {
          let e = 0,
            t = null;
          for (let i = n.length - 1; i >= 0; i--) {
            const r = n[i];
            (r.hostVars = e += r.hostVars),
              (r.hostAttrs = dc(r.hostAttrs, (t = dc(t, r.hostAttrs))));
          }
        })(i);
      }
      function wh(n) {
        return n === br ? {} : n === Mt ? [] : n;
      }
      function BB(n, e) {
        const t = n.viewQuery;
        n.viewQuery = t
          ? (i, r) => {
              e(i, r), t(i, r);
            }
          : e;
      }
      function VB(n, e) {
        const t = n.contentQueries;
        n.contentQueries = t
          ? (i, r, s) => {
              e(i, r, s), t(i, r, s);
            }
          : e;
      }
      function HB(n, e) {
        const t = n.hostBindings;
        n.hostBindings = t
          ? (i, r) => {
              e(i, r), t(i, r);
            }
          : e;
      }
      function Eh(n) {
        return (
          !!f_(n) &&
          (Array.isArray(n) || (!(n instanceof Map) && Symbol.iterator in n))
        );
      }
      function f_(n) {
        return null !== n && ("function" == typeof n || "object" == typeof n);
      }
      function Gn(n, e, t) {
        return !Object.is(n[e], t) && ((n[e] = t), !0);
      }
      function ar(n, e, t, i) {
        const r = ne();
        return Gn(r, Ma(), e) && (vt(), Tr(Kt(), r, n, e, t, i)), ar;
      }
      function Ha(n, e, t, i) {
        return Gn(n, Ma(), t) ? e + qe(t) + i : Qe;
      }
      function y_(n, e, t, i, r, s, o, a) {
        const l = ne(),
          c = vt(),
          u = n + dt,
          d = c.firstCreatePass
            ? (function hV(n, e, t, i, r, s, o, a, l) {
                const c = e.consts,
                  u = Ba(e, n, 4, o || null, xs(c, a));
                a_(e, t, u, xs(c, l)), Fd(e, u);
                const d = (u.tView = o_(
                  2,
                  u,
                  i,
                  r,
                  s,
                  e.directiveRegistry,
                  e.pipeRegistry,
                  null,
                  e.schemas,
                  c,
                  null,
                ));
                return (
                  null !== e.queries &&
                    (e.queries.template(e, u),
                    (d.queries = e.queries.embeddedTView(u))),
                  u
                );
              })(u, c, l, e, t, i, r, s, o)
            : c.data[u];
        Cr(d, !1);
        const h = gC(c, l, d, n);
        Ld() && rh(c, l, h, d),
          zn(h, l),
          bh(l, (l[u] = VE(h, l, h, d))),
          Id(d) && r_(c, l, d),
          null != o && s_(l, d, a);
      }
      let gC = function _C(n, e, t, i) {
        return Ts(!0), e[Ke].createComment("");
      };
      function yo(n, e, t) {
        const i = ne();
        return Gn(i, Ma(), e) && wi(vt(), Kt(), i, n, e, i[Ke], t, !1), yo;
      }
      function b_(n, e, t, i, r) {
        const o = r ? "class" : "style";
        d_(n, t, e.inputs[o], o, i);
      }
      function tt(n, e, t, i) {
        const r = ne(),
          s = vt(),
          o = dt + n,
          a = r[Ke],
          l = s.firstCreatePass
            ? (function gV(n, e, t, i, r, s) {
                const o = e.consts,
                  l = Ba(e, n, 2, i, xs(o, r));
                return (
                  a_(e, t, l, xs(o, s)),
                  null !== l.attrs && Mh(l, l.attrs, !1),
                  null !== l.mergedAttrs && Mh(l, l.mergedAttrs, !0),
                  null !== e.queries && e.queries.elementStart(e, l),
                  l
                );
              })(o, s, r, e, t, i)
            : s.data[o],
          c = yC(s, r, l, a, e, n);
        r[o] = c;
        const u = Id(l);
        return (
          Cr(l, !0),
          Fw(a, c, l),
          32 != (32 & l.flags) && Ld() && rh(s, r, c, l),
          0 ===
            (function nk() {
              return Ge.lFrame.elementDepthCount;
            })() && zn(c, r),
          (function ik() {
            Ge.lFrame.elementDepthCount++;
          })(),
          u && (r_(s, r, l), i_(s, l, r)),
          null !== i && s_(r, l),
          tt
        );
      }
      function ot() {
        let n = Nn();
        Zm()
          ? (function Km() {
              Ge.lFrame.isParent = !1;
            })()
          : ((n = n.parent), Cr(n, !1));
        const e = n;
        (function sk(n) {
          return Ge.skipHydrationRootTNode === n;
        })(e) &&
          (function ck() {
            Ge.skipHydrationRootTNode = null;
          })(),
          (function rk() {
            Ge.lFrame.elementDepthCount--;
          })();
        const t = vt();
        return (
          t.firstCreatePass && (Fd(t, n), Gm(n) && t.queries.elementEnd(n)),
          null != e.classesWithoutHost &&
            (function Ek(n) {
              return 0 != (8 & n.flags);
            })(e) &&
            b_(t, e, ne(), e.classesWithoutHost, !0),
          null != e.stylesWithoutHost &&
            (function Ck(n) {
              return 0 != (16 & n.flags);
            })(e) &&
            b_(t, e, ne(), e.stylesWithoutHost, !1),
          ot
        );
      }
      function xt(n, e, t, i) {
        return tt(n, e, t, i), ot(), xt;
      }
      let yC = (n, e, t, i, r, s) => (
        Ts(!0),
        nh(
          i,
          r,
          (function FS() {
            return Ge.lFrame.currentNamespace;
          })(),
        )
      );
      function $c(n) {
        return !!n && "function" == typeof n.then;
      }
      function wC(n) {
        return !!n && "function" == typeof n.subscribe;
      }
      function Fn(n, e, t, i) {
        const r = ne(),
          s = vt(),
          o = Nn();
        return (
          (function CC(n, e, t, i, r, s, o) {
            const a = Id(i),
              c = n.firstCreatePass && GE(n),
              u = e[an],
              d = zE(e);
            let h = !0;
            if (3 & i.type || o) {
              const _ = di(i, e),
                g = o ? o(_) : _,
                m = d.length,
                y = o ? (b) => o(jt(b[i.index])) : i.index;
              let v = null;
              if (
                (!o &&
                  a &&
                  (v = (function SV(n, e, t, i) {
                    const r = n.cleanup;
                    if (null != r)
                      for (let s = 0; s < r.length - 1; s += 2) {
                        const o = r[s];
                        if (o === t && r[s + 1] === i) {
                          const a = e[pa],
                            l = r[s + 2];
                          return a.length > l ? a[l] : null;
                        }
                        "string" == typeof o && (s += 2);
                      }
                    return null;
                  })(n, e, r, i.index)),
                null !== v)
              )
                ((v.__ngLastListenerFn__ || v).__ngNextListenerFn__ = s),
                  (v.__ngLastListenerFn__ = s),
                  (h = !1);
              else {
                s = TC(i, e, u, s, !1);
                const b = t.listen(g, r, s);
                d.push(s, b), c && c.push(r, y, m, m + 1);
              }
            } else s = TC(i, e, u, s, !1);
            const f = i.outputs;
            let p;
            if (h && null !== f && (p = f[r])) {
              const _ = p.length;
              if (_)
                for (let g = 0; g < _; g += 2) {
                  const S = e[p[g]][p[g + 1]].subscribe(s),
                    E = d.length;
                  d.push(s, S), c && c.push(r, i.index, E, -(E + 1));
                }
            }
          })(s, r, r[Ke], o, n, e, i),
          Fn
        );
      }
      function xC(n, e, t, i) {
        try {
          return Er(6, e, t), !1 !== t(i);
        } catch (r) {
          return $E(n, r), !1;
        } finally {
          Er(7, e, t);
        }
      }
      function TC(n, e, t, i, r) {
        return function s(o) {
          if (o === Function) return i;
          Fc(n.componentOffset > -1 ? Mi(n.index, e) : e);
          let l = xC(e, t, i, o),
            c = s.__ngNextListenerFn__;
          for (; c; ) (l = xC(e, t, c, o) && l), (c = c.__ngNextListenerFn__);
          return r && !1 === l && o.preventDefault(), l;
        };
      }
      function Ah(n, e, t) {
        return w_(n, "", e, "", t), Ah;
      }
      function w_(n, e, t, i, r) {
        const s = ne(),
          o = Ha(s, e, t, i);
        return o !== Qe && wi(vt(), Kt(), s, n, o, s[Ke], r, !1), w_;
      }
      function Ih(n, e) {
        return (n << 17) | (e << 2);
      }
      function Is(n) {
        return (n >> 17) & 32767;
      }
      function E_(n) {
        return 2 | n;
      }
      function bo(n) {
        return (131068 & n) >> 2;
      }
      function C_(n, e) {
        return (-131069 & n) | (e << 2);
      }
      function x_(n) {
        return 1 | n;
      }
      function FC(n, e, t, i, r) {
        const s = n[t + 1],
          o = null === e;
        let a = i ? Is(s) : bo(s),
          l = !1;
        for (; 0 !== a && (!1 === l || o); ) {
          const u = n[a + 1];
          PV(n[a], e) && ((l = !0), (n[a + 1] = i ? x_(u) : E_(u))),
            (a = i ? Is(u) : bo(u));
        }
        l && (n[t + 1] = i ? E_(s) : x_(s));
      }
      function PV(n, e) {
        return (
          null === n ||
          null == e ||
          (Array.isArray(n) ? n[1] : n) === e ||
          (!(!Array.isArray(n) || "string" != typeof e) && Aa(n, e) >= 0)
        );
      }
      const xn = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 };
      function kC(n) {
        return n.substring(xn.key, xn.keyEnd);
      }
      function UC(n, e) {
        const t = xn.textEnd;
        return t === e
          ? -1
          : ((e = xn.keyEnd =
              (function FV(n, e, t) {
                for (; e < t && n.charCodeAt(e) > 32; ) e++;
                return e;
              })(n, (xn.key = e), t)),
            Ya(n, e, t));
      }
      function Ya(n, e, t) {
        for (; e < t && n.charCodeAt(e) <= 32; ) e++;
        return e;
      }
      function Za(n, e) {
        return (
          (function lr(n, e, t, i) {
            const r = ne(),
              s = vt(),
              o = jr(2);
            s.firstUpdatePass && jC(s, n, o, i),
              e !== Qe &&
                Gn(r, o, e) &&
                XC(
                  s,
                  s.data[Yn()],
                  r,
                  r[Ke],
                  n,
                  (r[o + 1] = (function qV(n, e) {
                    return (
                      null == n ||
                        "" === n ||
                        ("string" == typeof e
                          ? (n += e)
                          : "object" == typeof n && (n = wn(As(n)))),
                      n
                    );
                  })(e, t)),
                  i,
                  o,
                );
          })(n, e, null, !0),
          Za
        );
      }
      function WC(n) {
        !(function cr(n, e, t, i) {
          const r = vt(),
            s = jr(2);
          r.firstUpdatePass && jC(r, null, s, i);
          const o = ne();
          if (t !== Qe && Gn(o, s, t)) {
            const a = r.data[Yn()];
            if (ZC(a, i) && !$C(r, s)) {
              let l = i ? a.classesWithoutHost : a.stylesWithoutHost;
              null !== l && (t = Rm(l, t || "")), b_(r, a, o, t, i);
            } else
              !(function jV(n, e, t, i, r, s, o, a) {
                r === Qe && (r = Mt);
                let l = 0,
                  c = 0,
                  u = 0 < r.length ? r[0] : null,
                  d = 0 < s.length ? s[0] : null;
                for (; null !== u || null !== d; ) {
                  const h = l < r.length ? r[l + 1] : void 0,
                    f = c < s.length ? s[c + 1] : void 0;
                  let _,
                    p = null;
                  u === d
                    ? ((l += 2), (c += 2), h !== f && ((p = d), (_ = f)))
                    : null === d || (null !== u && u < d)
                    ? ((l += 2), (p = u))
                    : ((c += 2), (p = d), (_ = f)),
                    null !== p && XC(n, e, t, i, p, _, o, a),
                    (u = l < r.length ? r[l] : null),
                    (d = c < s.length ? s[c] : null);
                }
              })(
                r,
                a,
                o,
                o[Ke],
                o[s + 1],
                (o[s + 1] = (function WV(n, e, t) {
                  if (null == t || "" === t) return Mt;
                  const i = [],
                    r = As(t);
                  if (Array.isArray(r))
                    for (let s = 0; s < r.length; s++) n(i, r[s], !0);
                  else if ("object" == typeof r)
                    for (const s in r) r.hasOwnProperty(s) && n(i, s, r[s]);
                  else "string" == typeof r && e(i, r);
                  return i;
                })(n, e, t)),
                i,
                s,
              );
          }
        })($V, Ir, n, !0);
      }
      function Ir(n, e) {
        for (
          let t = (function NV(n) {
            return (
              (function VC(n) {
                (xn.key = 0),
                  (xn.keyEnd = 0),
                  (xn.value = 0),
                  (xn.valueEnd = 0),
                  (xn.textEnd = n.length);
              })(n),
              UC(n, Ya(n, 0, xn.textEnd))
            );
          })(e);
          t >= 0;
          t = UC(e, t)
        )
          Si(n, kC(e), !0);
      }
      function $C(n, e) {
        return e >= n.expandoStartIndex;
      }
      function jC(n, e, t, i) {
        const r = n.data;
        if (null === r[t + 1]) {
          const s = r[Yn()],
            o = $C(n, t);
          ZC(s, i) && null === e && !o && (e = !1),
            (e = (function VV(n, e, t, i) {
              const r = (function Jm(n) {
                const e = Ge.lFrame.currentDirectiveIndex;
                return -1 === e ? null : n[e];
              })(n);
              let s = i ? e.residualClasses : e.residualStyles;
              if (null === r)
                0 === (i ? e.classBindings : e.styleBindings) &&
                  ((t = jc((t = T_(null, n, e, t, i)), e.attrs, i)),
                  (s = null));
              else {
                const o = e.directiveStylingLast;
                if (-1 === o || n[o] !== r)
                  if (((t = T_(r, n, e, t, i)), null === s)) {
                    let l = (function HV(n, e, t) {
                      const i = t ? e.classBindings : e.styleBindings;
                      if (0 !== bo(i)) return n[Is(i)];
                    })(n, e, i);
                    void 0 !== l &&
                      Array.isArray(l) &&
                      ((l = T_(null, n, e, l[1], i)),
                      (l = jc(l, e.attrs, i)),
                      (function zV(n, e, t, i) {
                        n[Is(t ? e.classBindings : e.styleBindings)] = i;
                      })(n, e, i, l));
                  } else
                    s = (function GV(n, e, t) {
                      let i;
                      const r = e.directiveEnd;
                      for (let s = 1 + e.directiveStylingLast; s < r; s++)
                        i = jc(i, n[s].hostAttrs, t);
                      return jc(i, e.attrs, t);
                    })(n, e, i);
              }
              return (
                void 0 !== s &&
                  (i ? (e.residualClasses = s) : (e.residualStyles = s)),
                t
              );
            })(r, s, e, i)),
            (function IV(n, e, t, i, r, s) {
              let o = s ? e.classBindings : e.styleBindings,
                a = Is(o),
                l = bo(o);
              n[i] = t;
              let u,
                c = !1;
              if (
                (Array.isArray(t)
                  ? ((u = t[1]), (null === u || Aa(t, u) > 0) && (c = !0))
                  : (u = t),
                r)
              )
                if (0 !== l) {
                  const h = Is(n[a + 1]);
                  (n[i + 1] = Ih(h, a)),
                    0 !== h && (n[h + 1] = C_(n[h + 1], i)),
                    (n[a + 1] = (function DV(n, e) {
                      return (131071 & n) | (e << 17);
                    })(n[a + 1], i));
                } else
                  (n[i + 1] = Ih(a, 0)),
                    0 !== a && (n[a + 1] = C_(n[a + 1], i)),
                    (a = i);
              else
                (n[i + 1] = Ih(l, 0)),
                  0 === a ? (a = i) : (n[l + 1] = C_(n[l + 1], i)),
                  (l = i);
              c && (n[i + 1] = E_(n[i + 1])),
                FC(n, u, i, !0),
                FC(n, u, i, !1),
                (function RV(n, e, t, i, r) {
                  const s = r ? n.residualClasses : n.residualStyles;
                  null != s &&
                    "string" == typeof e &&
                    Aa(s, e) >= 0 &&
                    (t[i + 1] = x_(t[i + 1]));
                })(e, u, n, i, s),
                (o = Ih(a, l)),
                s ? (e.classBindings = o) : (e.styleBindings = o);
            })(r, s, e, t, o, i);
        }
      }
      function T_(n, e, t, i, r) {
        let s = null;
        const o = t.directiveEnd;
        let a = t.directiveStylingLast;
        for (
          -1 === a ? (a = t.directiveStart) : a++;
          a < o && ((s = e[a]), (i = jc(i, s.hostAttrs, r)), s !== n);

        )
          a++;
        return null !== n && (t.directiveStylingLast = a), i;
      }
      function jc(n, e, t) {
        const i = t ? 1 : 2;
        let r = -1;
        if (null !== e)
          for (let s = 0; s < e.length; s++) {
            const o = e[s];
            "number" == typeof o
              ? (r = o)
              : r === i &&
                (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]),
                Si(n, o, !!t || e[++s]));
          }
        return void 0 === n ? null : n;
      }
      function $V(n, e, t) {
        const i = String(e);
        "" !== i && !i.includes(" ") && Si(n, i, t);
      }
      function XC(n, e, t, i, r, s, o, a) {
        if (!(3 & e.type)) return;
        const l = n.data,
          c = l[a + 1],
          u = (function AV(n) {
            return 1 == (1 & n);
          })(c)
            ? YC(l, e, t, r, bo(c), o)
            : void 0;
        Rh(u) ||
          (Rh(s) ||
            ((function TV(n) {
              return 2 == (2 & n);
            })(c) &&
              (s = YC(l, null, t, r, a, o))),
          (function F2(n, e, t, i, r) {
            if (e) r ? n.addClass(t, i) : n.removeClass(t, i);
            else {
              let s = -1 === i.indexOf("-") ? void 0 : Ds.DashCase;
              null == r
                ? n.removeStyle(t, i, s)
                : ("string" == typeof r &&
                    r.endsWith("!important") &&
                    ((r = r.slice(0, -10)), (s |= Ds.Important)),
                  n.setStyle(t, i, r, s));
            }
          })(i, o, Nd(Yn(), t), r, s));
      }
      function YC(n, e, t, i, r, s) {
        const o = null === e;
        let a;
        for (; r > 0; ) {
          const l = n[r],
            c = Array.isArray(l),
            u = c ? l[1] : l,
            d = null === u;
          let h = t[r + 1];
          h === Qe && (h = d ? Mt : void 0);
          let f = d ? dg(h, i) : u === i ? h : void 0;
          if ((c && !Rh(f) && (f = dg(l, i)), Rh(f) && ((a = f), o))) return a;
          const p = n[r + 1];
          r = o ? Is(p) : bo(p);
        }
        if (null !== e) {
          let l = s ? e.residualClasses : e.residualStyles;
          null != l && (a = dg(l, i));
        }
        return a;
      }
      function Rh(n) {
        return void 0 !== n;
      }
      function ZC(n, e) {
        return 0 != (n.flags & (e ? 8 : 16));
      }
      function Nt(n, e = "") {
        const t = ne(),
          i = vt(),
          r = n + dt,
          s = i.firstCreatePass ? Ba(i, r, 1, e, null) : i.data[r],
          o = KC(i, t, s, e, n);
        (t[r] = o), Ld() && rh(i, t, o, s), Cr(s, !1);
      }
      let KC = (n, e, t, i, r) => (
        Ts(!0),
        (function th(n, e) {
          return n.createText(e);
        })(e[Ke], i)
      );
      function Ka(n) {
        return D_("", n, ""), Ka;
      }
      function D_(n, e, t) {
        const i = ne(),
          r = Ha(i, n, e, t);
        return (
          r !== Qe &&
            (function Zr(n, e, t) {
              const i = Nd(e, n);
              !(function Sw(n, e, t) {
                n.setValue(e, t);
              })(n[Ke], i, t);
            })(i, Yn(), r),
          D_
        );
      }
      function Ph(n, e, t) {
        const i = ne();
        return Gn(i, Ma(), e) && wi(vt(), Kt(), i, n, e, i[Ke], t, !0), Ph;
      }
      const Ja = "en-US";
      let vx = Ja;
      function R_(n, e, t, i, r) {
        if (((n = $e(n)), Array.isArray(n)))
          for (let s = 0; s < n.length; s++) R_(n[s], e, t, i, r);
        else {
          const s = vt(),
            o = ne();
          let a = po(n) ? n : $e(n.provide),
            l = iE(n);
          const c = Nn(),
            u = 1048575 & c.providerIndexes,
            d = c.directiveStart,
            h = c.providerIndexes >> 20;
          if (po(n) || !n.multi) {
            const f = new vc(l, r, re),
              p = O_(a, e, r ? u : u + h, d);
            -1 === p
              ? (lg(zd(c, o), s, a),
                P_(s, n, e.length),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                t.push(f),
                o.push(f))
              : ((t[p] = f), (o[p] = f));
          } else {
            const f = O_(a, e, u + h, d),
              p = O_(a, e, u, u + h),
              g = p >= 0 && t[p];
            if ((r && !g) || (!r && !(f >= 0 && t[f]))) {
              lg(zd(c, o), s, a);
              const m = (function fH(n, e, t, i, r) {
                const s = new vc(n, t, re);
                return (
                  (s.multi = []),
                  (s.index = e),
                  (s.componentProviders = 0),
                  Gx(s, r, i && !t),
                  s
                );
              })(r ? hH : dH, t.length, r, i, l);
              !r && g && (t[p].providerFactory = m),
                P_(s, n, e.length, 0),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                t.push(m),
                o.push(m);
            } else P_(s, n, f > -1 ? f : p, Gx(t[r ? p : f], l, !r && i));
            !r && i && g && t[p].componentProviders++;
          }
        }
      }
      function P_(n, e, t, i) {
        const r = po(e),
          s = (function hU(n) {
            return !!n.useClass;
          })(e);
        if (r || s) {
          const l = (s ? $e(e.useClass) : e).prototype.ngOnDestroy;
          if (l) {
            const c = n.destroyHooks || (n.destroyHooks = []);
            if (!r && e.multi) {
              const u = c.indexOf(t);
              -1 === u ? c.push(t, [i, l]) : c[u + 1].push(i, l);
            } else c.push(t, l);
          }
        }
      }
      function Gx(n, e, t) {
        return t && n.componentProviders++, n.multi.push(e) - 1;
      }
      function O_(n, e, t, i) {
        for (let r = t; r < i; r++) if (e[r] === n) return r;
        return -1;
      }
      function dH(n, e, t, i) {
        return N_(this.multi, []);
      }
      function hH(n, e, t, i) {
        const r = this.multi;
        let s;
        if (this.providerFactory) {
          const o = this.providerFactory.componentProviders,
            a = ho(t, t[we], this.providerFactory.index, i);
          (s = a.slice(0, o)), N_(r, s);
          for (let l = o; l < a.length; l++) s.push(a[l]);
        } else (s = []), N_(r, s);
        return s;
      }
      function N_(n, e) {
        for (let t = 0; t < n.length; t++) e.push((0, n[t])());
        return e;
      }
      function Ht(n, e = []) {
        return (t) => {
          t.providersResolver = (i, r) =>
            (function uH(n, e, t) {
              const i = vt();
              if (i.firstCreatePass) {
                const r = sr(n);
                R_(t, i.data, i.blueprint, r, !0),
                  R_(e, i.data, i.blueprint, r, !1);
              }
            })(i, r ? r(n) : n, e);
        };
      }
      class el {}
      class Wx {}
      class L_ extends el {
        constructor(e, t, i) {
          super(),
            (this._parent = t),
            (this._bootstrapComponents = []),
            (this.destroyCbs = []),
            (this.componentFactoryResolver = new KE(this));
          const r = yi(e);
          (this._bootstrapComponents = Yr(r.bootstrap)),
            (this._r3Injector = IE(
              e,
              t,
              [
                { provide: el, useValue: this },
                { provide: go, useValue: this.componentFactoryResolver },
                ...i,
              ],
              wn(e),
              new Set(["environment"]),
            )),
            this._r3Injector.resolveInjectorInitializers(),
            (this.instance = this._r3Injector.get(e));
        }
        get injector() {
          return this._r3Injector;
        }
        destroy() {
          const e = this._r3Injector;
          !e.destroyed && e.destroy(),
            this.destroyCbs.forEach((t) => t()),
            (this.destroyCbs = null);
        }
        onDestroy(e) {
          this.destroyCbs.push(e);
        }
      }
      class F_ extends Wx {
        constructor(e) {
          super(), (this.moduleType = e);
        }
        create(e) {
          return new L_(this.moduleType, e, []);
        }
      }
      class $x extends el {
        constructor(e) {
          super(),
            (this.componentFactoryResolver = new KE(this)),
            (this.instance = null);
          const t = new Vg(
            [
              ...e.providers,
              { provide: el, useValue: this },
              { provide: go, useValue: this.componentFactoryResolver },
            ],
            e.parent || dh(),
            e.debugName,
            new Set(["environment"]),
          );
          (this.injector = t),
            e.runEnvironmentInitializers && t.resolveInjectorInitializers();
        }
        destroy() {
          this.injector.destroy();
        }
        onDestroy(e) {
          this.injector.onDestroy(e);
        }
      }
      function k_(n, e, t = null) {
        return new $x({
          providers: n,
          parent: e,
          debugName: t,
          runEnvironmentInitializers: !0,
        }).injector;
      }
      let gH = (() => {
        class n {
          constructor(t) {
            (this._injector = t), (this.cachedInjectors = new Map());
          }
          getOrCreateStandaloneInjector(t) {
            if (!t.standalone) return null;
            if (!this.cachedInjectors.has(t)) {
              const i = Jw(0, t.type),
                r =
                  i.length > 0
                    ? k_([i], this._injector, `Standalone[${t.type.name}]`)
                    : null;
              this.cachedInjectors.set(t, r);
            }
            return this.cachedInjectors.get(t);
          }
          ngOnDestroy() {
            try {
              for (const t of this.cachedInjectors.values())
                null !== t && t.destroy();
            } finally {
              this.cachedInjectors.clear();
            }
          }
        }
        return (
          (n.ɵprov = Ee({
            token: n,
            providedIn: "environment",
            factory: () => new n(se(Xr)),
          })),
          n
        );
      })();
      function jx(n) {
        n.getStandaloneInjector = (e) =>
          e.get(gH).getOrCreateStandaloneInjector(n);
      }
      function B_(n, e, t, i) {
        return (function Jx(n, e, t, i, r, s) {
          const o = e + t;
          return Gn(n, o, r)
            ? (function Dr(n, e, t) {
                return (n[e] = t);
              })(n, o + 1, s ? i.call(s, r) : i(r))
            : (function Qc(n, e) {
                const t = n[e];
                return t === Qe ? void 0 : t;
              })(n, o + 1);
        })(
          ne(),
          (function Xn() {
            const n = Ge.lFrame;
            let e = n.bindingRootIndex;
            return (
              -1 === e && (e = n.bindingRootIndex = n.tView.bindingStartIndex),
              e
            );
          })(),
          n,
          e,
          t,
          i,
        );
      }
      function V_(n) {
        return (e) => {
          setTimeout(n, void 0, e);
        };
      }
      const Rt = class HH extends en {
        constructor(e = !1) {
          super(), (this.__isAsync = e);
        }
        emit(e) {
          super.next(e);
        }
        subscribe(e, t, i) {
          let r = e,
            s = t || (() => null),
            o = i;
          if (e && "object" == typeof e) {
            const l = e;
            (r = l.next?.bind(l)),
              (s = l.error?.bind(l)),
              (o = l.complete?.bind(l));
          }
          this.__isAsync && ((s = V_(s)), r && (r = V_(r)), o && (o = V_(o)));
          const a = super.subscribe({ next: r, error: s, complete: o });
          return e instanceof Un && e.add(a), a;
        }
      };
      function zH() {
        return this._results[Symbol.iterator]();
      }
      class H_ {
        get changes() {
          return this._changes || (this._changes = new Rt());
        }
        constructor(e = !1) {
          (this._emitDistinctChangesOnly = e),
            (this.dirty = !0),
            (this._results = []),
            (this._changesDetected = !1),
            (this._changes = null),
            (this.length = 0),
            (this.first = void 0),
            (this.last = void 0);
          const t = H_.prototype;
          t[Symbol.iterator] || (t[Symbol.iterator] = zH);
        }
        get(e) {
          return this._results[e];
        }
        map(e) {
          return this._results.map(e);
        }
        filter(e) {
          return this._results.filter(e);
        }
        find(e) {
          return this._results.find(e);
        }
        reduce(e, t) {
          return this._results.reduce(e, t);
        }
        forEach(e) {
          this._results.forEach(e);
        }
        some(e) {
          return this._results.some(e);
        }
        toArray() {
          return this._results.slice();
        }
        toString() {
          return this._results.toString();
        }
        reset(e, t) {
          const i = this;
          i.dirty = !1;
          const r = (function Gi(n) {
            return n.flat(Number.POSITIVE_INFINITY);
          })(e);
          (this._changesDetected = !(function Uk(n, e, t) {
            if (n.length !== e.length) return !1;
            for (let i = 0; i < n.length; i++) {
              let r = n[i],
                s = e[i];
              if ((t && ((r = t(r)), (s = t(s))), s !== r)) return !1;
            }
            return !0;
          })(i._results, r, t)) &&
            ((i._results = r),
            (i.length = r.length),
            (i.last = r[this.length - 1]),
            (i.first = r[0]));
        }
        notifyOnChanges() {
          this._changes &&
            (this._changesDetected || !this._emitDistinctChangesOnly) &&
            this._changes.emit(this);
        }
        setDirty() {
          this.dirty = !0;
        }
        destroy() {
          this.changes.complete(), this.changes.unsubscribe();
        }
      }
      let Rr = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = $H), n;
      })();
      const GH = Rr,
        WH = class extends GH {
          constructor(e, t, i) {
            super(),
              (this._declarationLView = e),
              (this._declarationTContainer = t),
              (this.elementRef = i);
          }
          get ssrId() {
            return this._declarationTContainer.tView?.ssrId || null;
          }
          createEmbeddedView(e, t) {
            return this.createEmbeddedViewImpl(e, t, null);
          }
          createEmbeddedViewImpl(e, t, i) {
            const o = this._declarationTContainer.tView,
              a = yh(
                this._declarationLView,
                o,
                e,
                4096 & this._declarationLView[Ze] ? 4096 : 16,
                null,
                o.declTNode,
                null,
                null,
                null,
                t || null,
                i || null,
              );
            a[pc] = this._declarationLView[this._declarationTContainer.index];
            const c = this._declarationLView[Mr];
            return (
              null !== c && (a[Mr] = c.createEmbeddedView(o)),
              h_(o, a, e),
              new Bc(a)
            );
          }
        };
      function $H() {
        return kh(Nn(), ne());
      }
      function kh(n, e) {
        return 4 & n.type ? new WH(e, n, ka(n, e)) : null;
      }
      let ji = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = QH), n;
      })();
      function QH() {
        return cT(Nn(), ne());
      }
      const JH = ji,
        aT = class extends JH {
          constructor(e, t, i) {
            super(),
              (this._lContainer = e),
              (this._hostTNode = t),
              (this._hostLView = i);
          }
          get element() {
            return ka(this._hostTNode, this._hostLView);
          }
          get injector() {
            return new wa(this._hostTNode, this._hostLView);
          }
          get parentInjector() {
            const e = ag(this._hostTNode, this._hostLView);
            if (VS(e)) {
              const t = Vd(e, this._hostLView),
                i = Bd(e);
              return new wa(t[we].data[i + 8], t);
            }
            return new wa(null, this._hostLView);
          }
          clear() {
            for (; this.length > 0; ) this.remove(this.length - 1);
          }
          get(e) {
            const t = lT(this._lContainer);
            return (null !== t && t[e]) || null;
          }
          get length() {
            return this._lContainer.length - Hn;
          }
          createEmbeddedView(e, t, i) {
            let r, s;
            "number" == typeof i
              ? (r = i)
              : null != i && ((r = i.index), (s = i.injector));
            const a = e.createEmbeddedViewImpl(t || {}, s, null);
            return this.insertImpl(a, r, false), a;
          }
          createComponent(e, t, i, r, s) {
            const o =
              e &&
              !(function yc(n) {
                return "function" == typeof n;
              })(e);
            let a;
            if (o) a = t;
            else {
              const _ = t || {};
              (a = _.index),
                (i = _.injector),
                (r = _.projectableNodes),
                (s = _.environmentInjector || _.ngModuleRef);
            }
            const l = o ? e : new Vc(Ct(e)),
              c = i || this.parentInjector;
            if (!s && null == l.ngModule) {
              const g = (o ? c : this.parentInjector).get(Xr, null);
              g && (s = g);
            }
            Ct(l.componentType ?? {});
            const f = l.create(c, r, null, s);
            return this.insertImpl(f.hostView, a, false), f;
          }
          insert(e, t) {
            return this.insertImpl(e, t, !1);
          }
          insertImpl(e, t, i) {
            const r = e._lView,
              s = r[we];
            if (
              (function JF(n) {
                return ui(n[Zt]);
              })(r)
            ) {
              const l = this.indexOf(e);
              if (-1 !== l) this.detach(l);
              else {
                const c = r[Zt],
                  u = new aT(c, c[Vn], c[Zt]);
                u.detach(u.indexOf(e));
              }
            }
            const o = this._adjustIndex(t),
              a = this._lContainer;
            if (
              ((function D2(n, e, t, i) {
                const r = Hn + i,
                  s = t.length;
                i > 0 && (t[r - 1][rr] = e),
                  i < s - Hn
                    ? ((e[rr] = t[r]), QS(t, Hn + i, e))
                    : (t.push(e), (e[rr] = null)),
                  (e[Zt] = t);
                const o = e[pc];
                null !== o &&
                  t !== o &&
                  (function A2(n, e) {
                    const t = n[va];
                    e[ln] !== e[Zt][Zt][ln] && (n[iS] = !0),
                      null === t ? (n[va] = [e]) : t.push(e);
                  })(o, e);
                const a = e[Mr];
                null !== a && a.insertView(n), (e[Ze] |= 128);
              })(s, r, a, o),
              !i)
            ) {
              const l = xg(o, a),
                c = r[Ke],
                u = ih(c, a[Sr]);
              null !== u &&
                (function C2(n, e, t, i, r, s) {
                  (i[En] = r), (i[Vn] = e), xc(n, i, t, 1, r, s);
                })(s, a[Vn], c, r, u, l);
            }
            return e.attachToViewContainerRef(), QS(G_(a), o, e), e;
          }
          move(e, t) {
            return this.insert(e, t);
          }
          indexOf(e) {
            const t = lT(this._lContainer);
            return null !== t ? t.indexOf(e) : -1;
          }
          remove(e) {
            const t = this._adjustIndex(e, -1),
              i = Sg(this._lContainer, t);
            i && ($d(G_(this._lContainer), t), Ew(i[we], i));
          }
          detach(e) {
            const t = this._adjustIndex(e, -1),
              i = Sg(this._lContainer, t);
            return i && null != $d(G_(this._lContainer), t) ? new Bc(i) : null;
          }
          _adjustIndex(e, t = 0) {
            return e ?? this.length + t;
          }
        };
      function lT(n) {
        return n[8];
      }
      function G_(n) {
        return n[8] || (n[8] = []);
      }
      function cT(n, e) {
        let t;
        const i = e[n.index];
        return (
          ui(i)
            ? (t = i)
            : ((t = VE(i, e, null, n)), (e[n.index] = t), bh(e, t)),
          uT(t, e, n, i),
          new aT(t, n, e)
        );
      }
      let uT = function dT(n, e, t, i) {
        if (n[Sr]) return;
        let r;
        (r =
          8 & t.type
            ? jt(i)
            : (function ez(n, e) {
                const t = n[Ke],
                  i = t.createComment(""),
                  r = di(e, n);
                return (
                  fo(
                    t,
                    ih(t, r),
                    i,
                    (function O2(n, e) {
                      return n.nextSibling(e);
                    })(t, r),
                    !1,
                  ),
                  i
                );
              })(e, t)),
          (n[Sr] = r);
      };
      class W_ {
        constructor(e) {
          (this.queryList = e), (this.matches = null);
        }
        clone() {
          return new W_(this.queryList);
        }
        setDirty() {
          this.queryList.setDirty();
        }
      }
      class $_ {
        constructor(e = []) {
          this.queries = e;
        }
        createEmbeddedView(e) {
          const t = e.queries;
          if (null !== t) {
            const i =
                null !== e.contentQueries ? e.contentQueries[0] : t.length,
              r = [];
            for (let s = 0; s < i; s++) {
              const o = t.getByIndex(s);
              r.push(this.queries[o.indexInDeclarationView].clone());
            }
            return new $_(r);
          }
          return null;
        }
        insertView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        detachView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        dirtyQueriesWithMatches(e) {
          for (let t = 0; t < this.queries.length; t++)
            null !== gT(e, t).matches && this.queries[t].setDirty();
        }
      }
      class hT {
        constructor(e, t, i = null) {
          (this.predicate = e), (this.flags = t), (this.read = i);
        }
      }
      class j_ {
        constructor(e = []) {
          this.queries = e;
        }
        elementStart(e, t) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].elementStart(e, t);
        }
        elementEnd(e) {
          for (let t = 0; t < this.queries.length; t++)
            this.queries[t].elementEnd(e);
        }
        embeddedTView(e) {
          let t = null;
          for (let i = 0; i < this.length; i++) {
            const r = null !== t ? t.length : 0,
              s = this.getByIndex(i).embeddedTView(e, r);
            s &&
              ((s.indexInDeclarationView = i),
              null !== t ? t.push(s) : (t = [s]));
          }
          return null !== t ? new j_(t) : null;
        }
        template(e, t) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].template(e, t);
        }
        getByIndex(e) {
          return this.queries[e];
        }
        get length() {
          return this.queries.length;
        }
        track(e) {
          this.queries.push(e);
        }
      }
      class q_ {
        constructor(e, t = -1) {
          (this.metadata = e),
            (this.matches = null),
            (this.indexInDeclarationView = -1),
            (this.crossesNgTemplate = !1),
            (this._appliesToNextNode = !0),
            (this._declarationNodeIndex = t);
        }
        elementStart(e, t) {
          this.isApplyingToNode(t) && this.matchTNode(e, t);
        }
        elementEnd(e) {
          this._declarationNodeIndex === e.index &&
            (this._appliesToNextNode = !1);
        }
        template(e, t) {
          this.elementStart(e, t);
        }
        embeddedTView(e, t) {
          return this.isApplyingToNode(e)
            ? ((this.crossesNgTemplate = !0),
              this.addMatch(-e.index, t),
              new q_(this.metadata))
            : null;
        }
        isApplyingToNode(e) {
          if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
            const t = this._declarationNodeIndex;
            let i = e.parent;
            for (; null !== i && 8 & i.type && i.index !== t; ) i = i.parent;
            return t === (null !== i ? i.index : -1);
          }
          return this._appliesToNextNode;
        }
        matchTNode(e, t) {
          const i = this.metadata.predicate;
          if (Array.isArray(i))
            for (let r = 0; r < i.length; r++) {
              const s = i[r];
              this.matchTNodeWithReadOption(e, t, iz(t, s)),
                this.matchTNodeWithReadOption(e, t, Gd(t, e, s, !1, !1));
            }
          else
            i === Rr
              ? 4 & t.type && this.matchTNodeWithReadOption(e, t, -1)
              : this.matchTNodeWithReadOption(e, t, Gd(t, e, i, !1, !1));
        }
        matchTNodeWithReadOption(e, t, i) {
          if (null !== i) {
            const r = this.metadata.read;
            if (null !== r)
              if (r === Rn || r === ji || (r === Rr && 4 & t.type))
                this.addMatch(t.index, -2);
              else {
                const s = Gd(t, e, r, !1, !1);
                null !== s && this.addMatch(t.index, s);
              }
            else this.addMatch(t.index, i);
          }
        }
        addMatch(e, t) {
          null === this.matches
            ? (this.matches = [e, t])
            : this.matches.push(e, t);
        }
      }
      function iz(n, e) {
        const t = n.localNames;
        if (null !== t)
          for (let i = 0; i < t.length; i += 2) if (t[i] === e) return t[i + 1];
        return null;
      }
      function sz(n, e, t, i) {
        return -1 === t
          ? (function rz(n, e) {
              return 11 & n.type ? ka(n, e) : 4 & n.type ? kh(n, e) : null;
            })(e, n)
          : -2 === t
          ? (function oz(n, e, t) {
              return t === Rn
                ? ka(e, n)
                : t === Rr
                ? kh(e, n)
                : t === ji
                ? cT(e, n)
                : void 0;
            })(n, e, i)
          : ho(n, n[we], t, e);
      }
      function fT(n, e, t, i) {
        const r = e[Mr].queries[i];
        if (null === r.matches) {
          const s = n.data,
            o = t.matches,
            a = [];
          for (let l = 0; l < o.length; l += 2) {
            const c = o[l];
            a.push(c < 0 ? null : sz(e, s[c], o[l + 1], t.metadata.read));
          }
          r.matches = a;
        }
        return r.matches;
      }
      function X_(n, e, t, i) {
        const r = n.queries.getByIndex(t),
          s = r.matches;
        if (null !== s) {
          const o = fT(n, e, r, t);
          for (let a = 0; a < s.length; a += 2) {
            const l = s[a];
            if (l > 0) i.push(o[a / 2]);
            else {
              const c = s[a + 1],
                u = e[-l];
              for (let d = Hn; d < u.length; d++) {
                const h = u[d];
                h[pc] === h[Zt] && X_(h[we], h, c, i);
              }
              if (null !== u[va]) {
                const d = u[va];
                for (let h = 0; h < d.length; h++) {
                  const f = d[h];
                  X_(f[we], f, c, i);
                }
              }
            }
          }
        }
        return i;
      }
      function Kr(n) {
        const e = ne(),
          t = vt(),
          i = IS();
        eg(i + 1);
        const r = gT(t, i);
        if (
          n.dirty &&
          (function KF(n) {
            return 4 == (4 & n[Ze]);
          })(e) ===
            (2 == (2 & r.metadata.flags))
        ) {
          if (null === r.matches) n.reset([]);
          else {
            const s = r.crossesNgTemplate ? X_(t, e, i, []) : fT(t, e, r, i);
            n.reset(s, PU), n.notifyOnChanges();
          }
          return !0;
        }
        return !1;
      }
      function So(n, e, t) {
        const i = vt();
        i.firstCreatePass &&
          (mT(i, new hT(n, e, t), -1),
          2 == (2 & e) && (i.staticViewQueries = !0)),
          pT(i, ne(), e);
      }
      function Qr() {
        return (function az(n, e) {
          return n[Mr].queries[e].queryList;
        })(ne(), IS());
      }
      function pT(n, e, t) {
        const i = new H_(4 == (4 & t));
        (function eB(n, e, t, i) {
          const r = zE(e);
          r.push(t), n.firstCreatePass && GE(n).push(i, r.length - 1);
        })(n, e, i, i.destroy),
          null === e[Mr] && (e[Mr] = new $_()),
          e[Mr].queries.push(new W_(i));
      }
      function mT(n, e, t) {
        null === n.queries && (n.queries = new j_()),
          n.queries.track(new q_(e, t));
      }
      function gT(n, e) {
        return n.queries.getByIndex(e);
      }
      const tv = new ve("Application Initializer");
      let nv = (() => {
          class n {
            constructor() {
              (this.initialized = !1),
                (this.done = !1),
                (this.donePromise = new Promise((t, i) => {
                  (this.resolve = t), (this.reject = i);
                })),
                (this.appInits = Te(tv, { optional: !0 }) ?? []);
            }
            runInitializers() {
              if (this.initialized) return;
              const t = [];
              for (const r of this.appInits) {
                const s = r();
                if ($c(s)) t.push(s);
                else if (wC(s)) {
                  const o = new Promise((a, l) => {
                    s.subscribe({ complete: a, error: l });
                  });
                  t.push(o);
                }
              }
              const i = () => {
                (this.done = !0), this.resolve();
              };
              Promise.all(t)
                .then(() => {
                  i();
                })
                .catch((r) => {
                  this.reject(r);
                }),
                0 === t.length && i(),
                (this.initialized = !0);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        OT = (() => {
          class n {
            log(t) {
              console.log(t);
            }
            warn(t) {
              console.warn(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({
              token: n,
              factory: n.ɵfac,
              providedIn: "platform",
            })),
            n
          );
        })();
      const Jr = new ve("LocaleId", {
        providedIn: "root",
        factory: () =>
          Te(Jr, ct.Optional | ct.SkipSelf) ||
          (function Iz() {
            return (typeof $localize < "u" && $localize.locale) || Ja;
          })(),
      });
      let NT = (() => {
        class n {
          constructor() {
            (this.taskId = 0),
              (this.pendingTasks = new Set()),
              (this.hasPendingTasks = new Ui(!1));
          }
          add() {
            this.hasPendingTasks.next(!0);
            const t = this.taskId++;
            return this.pendingTasks.add(t), t;
          }
          remove(t) {
            this.pendingTasks.delete(t),
              0 === this.pendingTasks.size && this.hasPendingTasks.next(!1);
          }
          ngOnDestroy() {
            this.pendingTasks.clear(), this.hasPendingTasks.next(!1);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      class Oz {
        constructor(e, t) {
          (this.ngModuleFactory = e), (this.componentFactories = t);
        }
      }
      let LT = (() => {
        class n {
          compileModuleSync(t) {
            return new F_(t);
          }
          compileModuleAsync(t) {
            return Promise.resolve(this.compileModuleSync(t));
          }
          compileModuleAndAllComponentsSync(t) {
            const i = this.compileModuleSync(t),
              s = Yr(yi(t).declarations).reduce((o, a) => {
                const l = Ct(a);
                return l && o.push(new Vc(l)), o;
              }, []);
            return new Oz(i, s);
          }
          compileModuleAndAllComponentsAsync(t) {
            return Promise.resolve(this.compileModuleAndAllComponentsSync(t));
          }
          clearCache() {}
          clearCacheFor(t) {}
          getModuleId(t) {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function UT(...n) {}
      class yt {
        constructor({
          enableLongStackTrace: e = !1,
          shouldCoalesceEventChangeDetection: t = !1,
          shouldCoalesceRunChangeDetection: i = !1,
        }) {
          if (
            ((this.hasPendingMacrotasks = !1),
            (this.hasPendingMicrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new Rt(!1)),
            (this.onMicrotaskEmpty = new Rt(!1)),
            (this.onStable = new Rt(!1)),
            (this.onError = new Rt(!1)),
            typeof Zone > "u")
          )
            throw new Y(908, !1);
          Zone.assertZonePatched();
          const r = this;
          (r._nesting = 0),
            (r._outer = r._inner = Zone.current),
            Zone.TaskTrackingZoneSpec &&
              (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec())),
            e &&
              Zone.longStackTraceZoneSpec &&
              (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)),
            (r.shouldCoalesceEventChangeDetection = !i && t),
            (r.shouldCoalesceRunChangeDetection = i),
            (r.lastRequestAnimationFrameId = -1),
            (r.nativeRequestAnimationFrame = (function Fz() {
              const n = "function" == typeof Vt.requestAnimationFrame;
              let e = Vt[n ? "requestAnimationFrame" : "setTimeout"],
                t = Vt[n ? "cancelAnimationFrame" : "clearTimeout"];
              if (typeof Zone < "u" && e && t) {
                const i = e[Zone.__symbol__("OriginalDelegate")];
                i && (e = i);
                const r = t[Zone.__symbol__("OriginalDelegate")];
                r && (t = r);
              }
              return {
                nativeRequestAnimationFrame: e,
                nativeCancelAnimationFrame: t,
              };
            })().nativeRequestAnimationFrame),
            (function Bz(n) {
              const e = () => {
                !(function Uz(n) {
                  n.isCheckStableRunning ||
                    -1 !== n.lastRequestAnimationFrameId ||
                    ((n.lastRequestAnimationFrameId =
                      n.nativeRequestAnimationFrame.call(Vt, () => {
                        n.fakeTopEventTask ||
                          (n.fakeTopEventTask = Zone.root.scheduleEventTask(
                            "fakeTopEventTask",
                            () => {
                              (n.lastRequestAnimationFrameId = -1),
                                rv(n),
                                (n.isCheckStableRunning = !0),
                                iv(n),
                                (n.isCheckStableRunning = !1);
                            },
                            void 0,
                            () => {},
                            () => {},
                          )),
                          n.fakeTopEventTask.invoke();
                      })),
                    rv(n));
                })(n);
              };
              n._inner = n._inner.fork({
                name: "angular",
                properties: { isAngularZone: !0 },
                onInvokeTask: (t, i, r, s, o, a) => {
                  try {
                    return BT(n), t.invokeTask(r, s, o, a);
                  } finally {
                    ((n.shouldCoalesceEventChangeDetection &&
                      "eventTask" === s.type) ||
                      n.shouldCoalesceRunChangeDetection) &&
                      e(),
                      VT(n);
                  }
                },
                onInvoke: (t, i, r, s, o, a, l) => {
                  try {
                    return BT(n), t.invoke(r, s, o, a, l);
                  } finally {
                    n.shouldCoalesceRunChangeDetection && e(), VT(n);
                  }
                },
                onHasTask: (t, i, r, s) => {
                  t.hasTask(r, s),
                    i === r &&
                      ("microTask" == s.change
                        ? ((n._hasPendingMicrotasks = s.microTask),
                          rv(n),
                          iv(n))
                        : "macroTask" == s.change &&
                          (n.hasPendingMacrotasks = s.macroTask));
                },
                onHandleError: (t, i, r, s) => (
                  t.handleError(r, s),
                  n.runOutsideAngular(() => n.onError.emit(s)),
                  !1
                ),
              });
            })(r);
        }
        static isInAngularZone() {
          return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone");
        }
        static assertInAngularZone() {
          if (!yt.isInAngularZone()) throw new Y(909, !1);
        }
        static assertNotInAngularZone() {
          if (yt.isInAngularZone()) throw new Y(909, !1);
        }
        run(e, t, i) {
          return this._inner.run(e, t, i);
        }
        runTask(e, t, i, r) {
          const s = this._inner,
            o = s.scheduleEventTask("NgZoneEvent: " + r, e, kz, UT, UT);
          try {
            return s.runTask(o, t, i);
          } finally {
            s.cancelTask(o);
          }
        }
        runGuarded(e, t, i) {
          return this._inner.runGuarded(e, t, i);
        }
        runOutsideAngular(e) {
          return this._outer.run(e);
        }
      }
      const kz = {};
      function iv(n) {
        if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable)
          try {
            n._nesting++, n.onMicrotaskEmpty.emit(null);
          } finally {
            if ((n._nesting--, !n.hasPendingMicrotasks))
              try {
                n.runOutsideAngular(() => n.onStable.emit(null));
              } finally {
                n.isStable = !0;
              }
          }
      }
      function rv(n) {
        n.hasPendingMicrotasks = !!(
          n._hasPendingMicrotasks ||
          ((n.shouldCoalesceEventChangeDetection ||
            n.shouldCoalesceRunChangeDetection) &&
            -1 !== n.lastRequestAnimationFrameId)
        );
      }
      function BT(n) {
        n._nesting++,
          n.isStable && ((n.isStable = !1), n.onUnstable.emit(null));
      }
      function VT(n) {
        n._nesting--, iv(n);
      }
      class Vz {
        constructor() {
          (this.hasPendingMicrotasks = !1),
            (this.hasPendingMacrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new Rt()),
            (this.onMicrotaskEmpty = new Rt()),
            (this.onStable = new Rt()),
            (this.onError = new Rt());
        }
        run(e, t, i) {
          return e.apply(t, i);
        }
        runGuarded(e, t, i) {
          return e.apply(t, i);
        }
        runOutsideAngular(e) {
          return e();
        }
        runTask(e, t, i, r) {
          return e.apply(t, i);
        }
      }
      const HT = new ve("", { providedIn: "root", factory: zT });
      function zT() {
        const n = Te(yt);
        let e = !0;
        return PM(
          new Yt((r) => {
            (e =
              n.isStable && !n.hasPendingMacrotasks && !n.hasPendingMicrotasks),
              n.runOutsideAngular(() => {
                r.next(e), r.complete();
              });
          }),
          new Yt((r) => {
            let s;
            n.runOutsideAngular(() => {
              s = n.onStable.subscribe(() => {
                yt.assertNotInAngularZone(),
                  queueMicrotask(() => {
                    !e &&
                      !n.hasPendingMacrotasks &&
                      !n.hasPendingMicrotasks &&
                      ((e = !0), r.next(!0));
                  });
              });
            });
            const o = n.onUnstable.subscribe(() => {
              yt.assertInAngularZone(),
                e &&
                  ((e = !1),
                  n.runOutsideAngular(() => {
                    r.next(!1);
                  }));
            });
            return () => {
              s.unsubscribe(), o.unsubscribe();
            };
          }).pipe(OM()),
        );
      }
      const GT = new ve(""),
        Bh = new ve("");
      let av,
        sv = (() => {
          class n {
            constructor(t, i, r) {
              (this._ngZone = t),
                (this.registry = i),
                (this._pendingCount = 0),
                (this._isZoneStable = !0),
                (this._didWork = !1),
                (this._callbacks = []),
                (this.taskTrackingZone = null),
                av ||
                  ((function Hz(n) {
                    av = n;
                  })(r),
                  r.addToWindow(i)),
                this._watchAngularEvents(),
                t.run(() => {
                  this.taskTrackingZone =
                    typeof Zone > "u"
                      ? null
                      : Zone.current.get("TaskTrackingZone");
                });
            }
            _watchAngularEvents() {
              this._ngZone.onUnstable.subscribe({
                next: () => {
                  (this._didWork = !0), (this._isZoneStable = !1);
                },
              }),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable.subscribe({
                    next: () => {
                      yt.assertNotInAngularZone(),
                        queueMicrotask(() => {
                          (this._isZoneStable = !0),
                            this._runCallbacksIfReady();
                        });
                    },
                  });
                });
            }
            increasePendingRequestCount() {
              return (
                (this._pendingCount += 1),
                (this._didWork = !0),
                this._pendingCount
              );
            }
            decreasePendingRequestCount() {
              if (((this._pendingCount -= 1), this._pendingCount < 0))
                throw new Error("pending async requests below zero");
              return this._runCallbacksIfReady(), this._pendingCount;
            }
            isStable() {
              return (
                this._isZoneStable &&
                0 === this._pendingCount &&
                !this._ngZone.hasPendingMacrotasks
              );
            }
            _runCallbacksIfReady() {
              if (this.isStable())
                queueMicrotask(() => {
                  for (; 0 !== this._callbacks.length; ) {
                    let t = this._callbacks.pop();
                    clearTimeout(t.timeoutId), t.doneCb(this._didWork);
                  }
                  this._didWork = !1;
                });
              else {
                let t = this.getPendingTasks();
                (this._callbacks = this._callbacks.filter(
                  (i) =>
                    !i.updateCb ||
                    !i.updateCb(t) ||
                    (clearTimeout(i.timeoutId), !1),
                )),
                  (this._didWork = !0);
              }
            }
            getPendingTasks() {
              return this.taskTrackingZone
                ? this.taskTrackingZone.macroTasks.map((t) => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data,
                  }))
                : [];
            }
            addCallback(t, i, r) {
              let s = -1;
              i &&
                i > 0 &&
                (s = setTimeout(() => {
                  (this._callbacks = this._callbacks.filter(
                    (o) => o.timeoutId !== s,
                  )),
                    t(this._didWork, this.getPendingTasks());
                }, i)),
                this._callbacks.push({ doneCb: t, timeoutId: s, updateCb: r });
            }
            whenStable(t, i, r) {
              if (r && !this.taskTrackingZone)
                throw new Error(
                  'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?',
                );
              this.addCallback(t, i, r), this._runCallbacksIfReady();
            }
            getPendingRequestCount() {
              return this._pendingCount;
            }
            registerApplication(t) {
              this.registry.registerApplication(t, this);
            }
            unregisterApplication(t) {
              this.registry.unregisterApplication(t);
            }
            findProviders(t, i, r) {
              return [];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(yt), se(ov), se(Bh));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        ov = (() => {
          class n {
            constructor() {
              this._applications = new Map();
            }
            registerApplication(t, i) {
              this._applications.set(t, i);
            }
            unregisterApplication(t) {
              this._applications.delete(t);
            }
            unregisterAllApplications() {
              this._applications.clear();
            }
            getTestability(t) {
              return this._applications.get(t) || null;
            }
            getAllTestabilities() {
              return Array.from(this._applications.values());
            }
            getAllRootElements() {
              return Array.from(this._applications.keys());
            }
            findTestabilityInTree(t, i = !0) {
              return av?.findTestabilityInTree(this, t, i) ?? null;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({
              token: n,
              factory: n.ɵfac,
              providedIn: "platform",
            })),
            n
          );
        })(),
        Rs = null;
      const WT = new ve("AllowMultipleToken"),
        lv = new ve("PlatformDestroyListeners"),
        cv = new ve("appBootstrapListener");
      class jT {
        constructor(e, t) {
          (this.name = e), (this.token = t);
        }
      }
      function XT(n, e, t = []) {
        const i = `Platform: ${e}`,
          r = new ve(i);
        return (s = []) => {
          let o = uv();
          if (!o || o.injector.get(WT, !1)) {
            const a = [...t, ...s, { provide: r, useValue: !0 }];
            n
              ? n(a)
              : (function Wz(n) {
                  if (Rs && !Rs.get(WT, !1)) throw new Y(400, !1);
                  (function $T() {
                    !(function HF(n) {
                      cS = n;
                    })(() => {
                      throw new Y(600, !1);
                    });
                  })(),
                    (Rs = n);
                  const e = n.get(ZT);
                  (function qT(n) {
                    n.get(rE, null)?.forEach((t) => t());
                  })(n);
                })(
                  (function YT(n = [], e) {
                    return fi.create({
                      name: e,
                      providers: [
                        { provide: Ug, useValue: "platform" },
                        { provide: lv, useValue: new Set([() => (Rs = null)]) },
                        ...n,
                      ],
                    });
                  })(a, i),
                );
          }
          return (function jz(n) {
            const e = uv();
            if (!e) throw new Y(401, !1);
            return e;
          })();
        };
      }
      function uv() {
        return Rs?.get(ZT) ?? null;
      }
      let ZT = (() => {
        class n {
          constructor(t) {
            (this._injector = t),
              (this._modules = []),
              (this._destroyListeners = []),
              (this._destroyed = !1);
          }
          bootstrapModuleFactory(t, i) {
            const r = (function qz(n = "zone.js", e) {
              return "noop" === n ? new Vz() : "zone.js" === n ? new yt(e) : n;
            })(
              i?.ngZone,
              (function KT(n) {
                return {
                  enableLongStackTrace: !1,
                  shouldCoalesceEventChangeDetection: n?.eventCoalescing ?? !1,
                  shouldCoalesceRunChangeDetection: n?.runCoalescing ?? !1,
                };
              })({
                eventCoalescing: i?.ngZoneEventCoalescing,
                runCoalescing: i?.ngZoneRunCoalescing,
              }),
            );
            return r.run(() => {
              const s = (function mH(n, e, t) {
                  return new L_(n, e, t);
                })(
                  t.moduleType,
                  this.injector,
                  (function nD(n) {
                    return [
                      { provide: yt, useFactory: n },
                      {
                        provide: Rc,
                        multi: !0,
                        useFactory: () => {
                          const e = Te(Yz, { optional: !0 });
                          return () => e.initialize();
                        },
                      },
                      { provide: tD, useFactory: Xz },
                      { provide: HT, useFactory: zT },
                    ];
                  })(() => r),
                ),
                o = s.injector.get(_o, null);
              return (
                r.runOutsideAngular(() => {
                  const a = r.onError.subscribe({
                    next: (l) => {
                      o.handleError(l);
                    },
                  });
                  s.onDestroy(() => {
                    Vh(this._modules, s), a.unsubscribe();
                  });
                }),
                (function QT(n, e, t) {
                  try {
                    const i = t();
                    return $c(i)
                      ? i.catch((r) => {
                          throw (
                            (e.runOutsideAngular(() => n.handleError(r)), r)
                          );
                        })
                      : i;
                  } catch (i) {
                    throw (e.runOutsideAngular(() => n.handleError(i)), i);
                  }
                })(o, r, () => {
                  const a = s.injector.get(nv);
                  return (
                    a.runInitializers(),
                    a.donePromise.then(
                      () => (
                        (function yx(n) {
                          Bi(n, "Expected localeId to be defined"),
                            "string" == typeof n &&
                              (vx = n.toLowerCase().replace(/_/g, "-"));
                        })(s.injector.get(Jr, Ja) || Ja),
                        this._moduleDoBootstrap(s),
                        s
                      ),
                    )
                  );
                })
              );
            });
          }
          bootstrapModule(t, i = []) {
            const r = JT({}, i);
            return (function zz(n, e, t) {
              const i = new F_(t);
              return Promise.resolve(i);
            })(0, 0, t).then((s) => this.bootstrapModuleFactory(s, r));
          }
          _moduleDoBootstrap(t) {
            const i = t.injector.get(Ps);
            if (t._bootstrapComponents.length > 0)
              t._bootstrapComponents.forEach((r) => i.bootstrap(r));
            else {
              if (!t.instance.ngDoBootstrap) throw new Y(-403, !1);
              t.instance.ngDoBootstrap(i);
            }
            this._modules.push(t);
          }
          onDestroy(t) {
            this._destroyListeners.push(t);
          }
          get injector() {
            return this._injector;
          }
          destroy() {
            if (this._destroyed) throw new Y(404, !1);
            this._modules.slice().forEach((i) => i.destroy()),
              this._destroyListeners.forEach((i) => i());
            const t = this._injector.get(lv, null);
            t && (t.forEach((i) => i()), t.clear()), (this._destroyed = !0);
          }
          get destroyed() {
            return this._destroyed;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se(fi));
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "platform" })),
          n
        );
      })();
      function JT(n, e) {
        return Array.isArray(e) ? e.reduce(JT, n) : { ...n, ...e };
      }
      let Ps = (() => {
        class n {
          constructor() {
            (this._bootstrapListeners = []),
              (this._runningTick = !1),
              (this._destroyed = !1),
              (this._destroyListeners = []),
              (this._views = []),
              (this.internalErrorHandler = Te(tD)),
              (this.zoneIsStable = Te(HT)),
              (this.componentTypes = []),
              (this.components = []),
              (this.isStable = Te(NT).hasPendingTasks.pipe(
                nr((t) => (t ? We(!1) : this.zoneIsStable)),
                (function ZL(n, e = Ss) {
                  return (
                    (n = n ?? KL),
                    fn((t, i) => {
                      let r,
                        s = !0;
                      t.subscribe(
                        tn(i, (o) => {
                          const a = e(o);
                          (s || !n(r, a)) && ((s = !1), (r = a), i.next(o));
                        }),
                      );
                    })
                  );
                })(),
                OM(),
              )),
              (this._injector = Te(Xr));
          }
          get destroyed() {
            return this._destroyed;
          }
          get injector() {
            return this._injector;
          }
          bootstrap(t, i) {
            const r = t instanceof dE;
            if (!this._injector.get(nv).done)
              throw (
                (!r &&
                  (function fa(n) {
                    const e = Ct(n) || Bn(n) || ci(n);
                    return null !== e && e.standalone;
                  })(t),
                new Y(405, !1))
              );
            let o;
            (o = r ? t : this._injector.get(go).resolveComponentFactory(t)),
              this.componentTypes.push(o.componentType);
            const a = (function Gz(n) {
                return n.isBoundToModule;
              })(o)
                ? void 0
                : this._injector.get(el),
              c = o.create(fi.NULL, [], i || o.selector, a),
              u = c.location.nativeElement,
              d = c.injector.get(GT, null);
            return (
              d?.registerApplication(u),
              c.onDestroy(() => {
                this.detachView(c.hostView),
                  Vh(this.components, c),
                  d?.unregisterApplication(u);
              }),
              this._loadComponent(c),
              c
            );
          }
          tick() {
            if (this._runningTick) throw new Y(101, !1);
            try {
              this._runningTick = !0;
              for (let t of this._views) t.detectChanges();
            } catch (t) {
              this.internalErrorHandler(t);
            } finally {
              this._runningTick = !1;
            }
          }
          attachView(t) {
            const i = t;
            this._views.push(i), i.attachToAppRef(this);
          }
          detachView(t) {
            const i = t;
            Vh(this._views, i), i.detachFromAppRef();
          }
          _loadComponent(t) {
            this.attachView(t.hostView), this.tick(), this.components.push(t);
            const i = this._injector.get(cv, []);
            i.push(...this._bootstrapListeners), i.forEach((r) => r(t));
          }
          ngOnDestroy() {
            if (!this._destroyed)
              try {
                this._destroyListeners.forEach((t) => t()),
                  this._views.slice().forEach((t) => t.destroy());
              } finally {
                (this._destroyed = !0),
                  (this._views = []),
                  (this._bootstrapListeners = []),
                  (this._destroyListeners = []);
              }
          }
          onDestroy(t) {
            return (
              this._destroyListeners.push(t),
              () => Vh(this._destroyListeners, t)
            );
          }
          destroy() {
            if (this._destroyed) throw new Y(406, !1);
            const t = this._injector;
            t.destroy && !t.destroyed && t.destroy();
          }
          get viewCount() {
            return this._views.length;
          }
          warnIfDestroyed() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function Vh(n, e) {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1);
      }
      const tD = new ve("", {
        providedIn: "root",
        factory: () => Te(_o).handleError.bind(void 0),
      });
      function Xz() {
        const n = Te(yt),
          e = Te(_o);
        return (t) => n.runOutsideAngular(() => e.handleError(t));
      }
      let Yz = (() => {
        class n {
          constructor() {
            (this.zone = Te(yt)), (this.applicationRef = Te(Ps));
          }
          initialize() {
            this._onMicrotaskEmptySubscription ||
              (this._onMicrotaskEmptySubscription =
                this.zone.onMicrotaskEmpty.subscribe({
                  next: () => {
                    this.zone.run(() => {
                      this.applicationRef.tick();
                    });
                  },
                }));
          }
          ngOnDestroy() {
            this._onMicrotaskEmptySubscription?.unsubscribe();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      let tu = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = Kz), n;
      })();
      function Kz(n) {
        return (function Qz(n, e, t) {
          if (lo(n) && !t) {
            const i = Mi(n.index, e);
            return new Bc(i, i);
          }
          return 47 & n.type ? new Bc(e[ln], e) : null;
        })(Nn(), ne(), 16 == (16 & n));
      }
      class oD {
        constructor() {}
        supports(e) {
          return Eh(e);
        }
        create(e) {
          return new rG(e);
        }
      }
      const iG = (n, e) => e;
      class rG {
        constructor(e) {
          (this.length = 0),
            (this._linkedRecords = null),
            (this._unlinkedRecords = null),
            (this._previousItHead = null),
            (this._itHead = null),
            (this._itTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._movesHead = null),
            (this._movesTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null),
            (this._identityChangesHead = null),
            (this._identityChangesTail = null),
            (this._trackByFn = e || iG);
        }
        forEachItem(e) {
          let t;
          for (t = this._itHead; null !== t; t = t._next) e(t);
        }
        forEachOperation(e) {
          let t = this._itHead,
            i = this._removalsHead,
            r = 0,
            s = null;
          for (; t || i; ) {
            const o = !i || (t && t.currentIndex < lD(i, r, s)) ? t : i,
              a = lD(o, r, s),
              l = o.currentIndex;
            if (o === i) r--, (i = i._nextRemoved);
            else if (((t = t._next), null == o.previousIndex)) r++;
            else {
              s || (s = []);
              const c = a - r,
                u = l - r;
              if (c != u) {
                for (let h = 0; h < c; h++) {
                  const f = h < s.length ? s[h] : (s[h] = 0),
                    p = f + h;
                  u <= p && p < c && (s[h] = f + 1);
                }
                s[o.previousIndex] = u - c;
              }
            }
            a !== l && e(o, a, l);
          }
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousItHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachMovedItem(e) {
          let t;
          for (t = this._movesHead; null !== t; t = t._nextMoved) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        forEachIdentityChange(e) {
          let t;
          for (
            t = this._identityChangesHead;
            null !== t;
            t = t._nextIdentityChange
          )
            e(t);
        }
        diff(e) {
          if ((null == e && (e = []), !Eh(e))) throw new Y(900, !1);
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let r,
            s,
            o,
            t = this._itHead,
            i = !1;
          if (Array.isArray(e)) {
            this.length = e.length;
            for (let a = 0; a < this.length; a++)
              (s = e[a]),
                (o = this._trackByFn(a, s)),
                null !== t && Object.is(t.trackById, o)
                  ? (i && (t = this._verifyReinsertion(t, s, o, a)),
                    Object.is(t.item, s) || this._addIdentityChange(t, s))
                  : ((t = this._mismatch(t, s, o, a)), (i = !0)),
                (t = t._next);
          } else
            (r = 0),
              (function XB(n, e) {
                if (Array.isArray(n))
                  for (let t = 0; t < n.length; t++) e(n[t]);
                else {
                  const t = n[Symbol.iterator]();
                  let i;
                  for (; !(i = t.next()).done; ) e(i.value);
                }
              })(e, (a) => {
                (o = this._trackByFn(r, a)),
                  null !== t && Object.is(t.trackById, o)
                    ? (i && (t = this._verifyReinsertion(t, a, o, r)),
                      Object.is(t.item, a) || this._addIdentityChange(t, a))
                    : ((t = this._mismatch(t, a, o, r)), (i = !0)),
                  (t = t._next),
                  r++;
              }),
              (this.length = r);
          return this._truncate(t), (this.collection = e), this.isDirty;
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._movesHead ||
            null !== this._removalsHead ||
            null !== this._identityChangesHead
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              e = this._previousItHead = this._itHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._additionsHead; null !== e; e = e._nextAdded)
              e.previousIndex = e.currentIndex;
            for (
              this._additionsHead = this._additionsTail = null,
                e = this._movesHead;
              null !== e;
              e = e._nextMoved
            )
              e.previousIndex = e.currentIndex;
            (this._movesHead = this._movesTail = null),
              (this._removalsHead = this._removalsTail = null),
              (this._identityChangesHead = this._identityChangesTail = null);
          }
        }
        _mismatch(e, t, i, r) {
          let s;
          return (
            null === e ? (s = this._itTail) : ((s = e._prev), this._remove(e)),
            null !==
            (e =
              null === this._unlinkedRecords
                ? null
                : this._unlinkedRecords.get(i, null))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._reinsertAfter(e, s, r))
              : null !==
                (e =
                  null === this._linkedRecords
                    ? null
                    : this._linkedRecords.get(i, r))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._moveAfter(e, s, r))
              : (e = this._addAfter(new sG(t, i), s, r)),
            e
          );
        }
        _verifyReinsertion(e, t, i, r) {
          let s =
            null === this._unlinkedRecords
              ? null
              : this._unlinkedRecords.get(i, null);
          return (
            null !== s
              ? (e = this._reinsertAfter(s, e._prev, r))
              : e.currentIndex != r &&
                ((e.currentIndex = r), this._addToMoves(e, r)),
            e
          );
        }
        _truncate(e) {
          for (; null !== e; ) {
            const t = e._next;
            this._addToRemovals(this._unlink(e)), (e = t);
          }
          null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
            null !== this._additionsTail &&
              (this._additionsTail._nextAdded = null),
            null !== this._movesTail && (this._movesTail._nextMoved = null),
            null !== this._itTail && (this._itTail._next = null),
            null !== this._removalsTail &&
              (this._removalsTail._nextRemoved = null),
            null !== this._identityChangesTail &&
              (this._identityChangesTail._nextIdentityChange = null);
        }
        _reinsertAfter(e, t, i) {
          null !== this._unlinkedRecords && this._unlinkedRecords.remove(e);
          const r = e._prevRemoved,
            s = e._nextRemoved;
          return (
            null === r ? (this._removalsHead = s) : (r._nextRemoved = s),
            null === s ? (this._removalsTail = r) : (s._prevRemoved = r),
            this._insertAfter(e, t, i),
            this._addToMoves(e, i),
            e
          );
        }
        _moveAfter(e, t, i) {
          return (
            this._unlink(e),
            this._insertAfter(e, t, i),
            this._addToMoves(e, i),
            e
          );
        }
        _addAfter(e, t, i) {
          return (
            this._insertAfter(e, t, i),
            (this._additionsTail =
              null === this._additionsTail
                ? (this._additionsHead = e)
                : (this._additionsTail._nextAdded = e)),
            e
          );
        }
        _insertAfter(e, t, i) {
          const r = null === t ? this._itHead : t._next;
          return (
            (e._next = r),
            (e._prev = t),
            null === r ? (this._itTail = e) : (r._prev = e),
            null === t ? (this._itHead = e) : (t._next = e),
            null === this._linkedRecords && (this._linkedRecords = new aD()),
            this._linkedRecords.put(e),
            (e.currentIndex = i),
            e
          );
        }
        _remove(e) {
          return this._addToRemovals(this._unlink(e));
        }
        _unlink(e) {
          null !== this._linkedRecords && this._linkedRecords.remove(e);
          const t = e._prev,
            i = e._next;
          return (
            null === t ? (this._itHead = i) : (t._next = i),
            null === i ? (this._itTail = t) : (i._prev = t),
            e
          );
        }
        _addToMoves(e, t) {
          return (
            e.previousIndex === t ||
              (this._movesTail =
                null === this._movesTail
                  ? (this._movesHead = e)
                  : (this._movesTail._nextMoved = e)),
            e
          );
        }
        _addToRemovals(e) {
          return (
            null === this._unlinkedRecords &&
              (this._unlinkedRecords = new aD()),
            this._unlinkedRecords.put(e),
            (e.currentIndex = null),
            (e._nextRemoved = null),
            null === this._removalsTail
              ? ((this._removalsTail = this._removalsHead = e),
                (e._prevRemoved = null))
              : ((e._prevRemoved = this._removalsTail),
                (this._removalsTail = this._removalsTail._nextRemoved = e)),
            e
          );
        }
        _addIdentityChange(e, t) {
          return (
            (e.item = t),
            (this._identityChangesTail =
              null === this._identityChangesTail
                ? (this._identityChangesHead = e)
                : (this._identityChangesTail._nextIdentityChange = e)),
            e
          );
        }
      }
      class sG {
        constructor(e, t) {
          (this.item = e),
            (this.trackById = t),
            (this.currentIndex = null),
            (this.previousIndex = null),
            (this._nextPrevious = null),
            (this._prev = null),
            (this._next = null),
            (this._prevDup = null),
            (this._nextDup = null),
            (this._prevRemoved = null),
            (this._nextRemoved = null),
            (this._nextAdded = null),
            (this._nextMoved = null),
            (this._nextIdentityChange = null);
        }
      }
      class oG {
        constructor() {
          (this._head = null), (this._tail = null);
        }
        add(e) {
          null === this._head
            ? ((this._head = this._tail = e),
              (e._nextDup = null),
              (e._prevDup = null))
            : ((this._tail._nextDup = e),
              (e._prevDup = this._tail),
              (e._nextDup = null),
              (this._tail = e));
        }
        get(e, t) {
          let i;
          for (i = this._head; null !== i; i = i._nextDup)
            if (
              (null === t || t <= i.currentIndex) &&
              Object.is(i.trackById, e)
            )
              return i;
          return null;
        }
        remove(e) {
          const t = e._prevDup,
            i = e._nextDup;
          return (
            null === t ? (this._head = i) : (t._nextDup = i),
            null === i ? (this._tail = t) : (i._prevDup = t),
            null === this._head
          );
        }
      }
      class aD {
        constructor() {
          this.map = new Map();
        }
        put(e) {
          const t = e.trackById;
          let i = this.map.get(t);
          i || ((i = new oG()), this.map.set(t, i)), i.add(e);
        }
        get(e, t) {
          const r = this.map.get(e);
          return r ? r.get(e, t) : null;
        }
        remove(e) {
          const t = e.trackById;
          return this.map.get(t).remove(e) && this.map.delete(t), e;
        }
        get isEmpty() {
          return 0 === this.map.size;
        }
        clear() {
          this.map.clear();
        }
      }
      function lD(n, e, t) {
        const i = n.previousIndex;
        if (null === i) return i;
        let r = 0;
        return t && i < t.length && (r = t[i]), i + e + r;
      }
      class cD {
        constructor() {}
        supports(e) {
          return e instanceof Map || f_(e);
        }
        create() {
          return new aG();
        }
      }
      class aG {
        constructor() {
          (this._records = new Map()),
            (this._mapHead = null),
            (this._appendAfter = null),
            (this._previousMapHead = null),
            (this._changesHead = null),
            (this._changesTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null);
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._changesHead ||
            null !== this._removalsHead
          );
        }
        forEachItem(e) {
          let t;
          for (t = this._mapHead; null !== t; t = t._next) e(t);
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousMapHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachChangedItem(e) {
          let t;
          for (t = this._changesHead; null !== t; t = t._nextChanged) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        diff(e) {
          if (e) {
            if (!(e instanceof Map || f_(e))) throw new Y(900, !1);
          } else e = new Map();
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let t = this._mapHead;
          if (
            ((this._appendAfter = null),
            this._forEach(e, (i, r) => {
              if (t && t.key === r)
                this._maybeAddToChanges(t, i),
                  (this._appendAfter = t),
                  (t = t._next);
              else {
                const s = this._getOrCreateRecordForKey(r, i);
                t = this._insertBeforeOrAppend(t, s);
              }
            }),
            t)
          ) {
            t._prev && (t._prev._next = null), (this._removalsHead = t);
            for (let i = t; null !== i; i = i._nextRemoved)
              i === this._mapHead && (this._mapHead = null),
                this._records.delete(i.key),
                (i._nextRemoved = i._next),
                (i.previousValue = i.currentValue),
                (i.currentValue = null),
                (i._prev = null),
                (i._next = null);
          }
          return (
            this._changesTail && (this._changesTail._nextChanged = null),
            this._additionsTail && (this._additionsTail._nextAdded = null),
            this.isDirty
          );
        }
        _insertBeforeOrAppend(e, t) {
          if (e) {
            const i = e._prev;
            return (
              (t._next = e),
              (t._prev = i),
              (e._prev = t),
              i && (i._next = t),
              e === this._mapHead && (this._mapHead = t),
              (this._appendAfter = e),
              e
            );
          }
          return (
            this._appendAfter
              ? ((this._appendAfter._next = t), (t._prev = this._appendAfter))
              : (this._mapHead = t),
            (this._appendAfter = t),
            null
          );
        }
        _getOrCreateRecordForKey(e, t) {
          if (this._records.has(e)) {
            const r = this._records.get(e);
            this._maybeAddToChanges(r, t);
            const s = r._prev,
              o = r._next;
            return (
              s && (s._next = o),
              o && (o._prev = s),
              (r._next = null),
              (r._prev = null),
              r
            );
          }
          const i = new lG(e);
          return (
            this._records.set(e, i),
            (i.currentValue = t),
            this._addToAdditions(i),
            i
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              this._previousMapHead = this._mapHead, e = this._previousMapHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._changesHead; null !== e; e = e._nextChanged)
              e.previousValue = e.currentValue;
            for (e = this._additionsHead; null != e; e = e._nextAdded)
              e.previousValue = e.currentValue;
            (this._changesHead = this._changesTail = null),
              (this._additionsHead = this._additionsTail = null),
              (this._removalsHead = null);
          }
        }
        _maybeAddToChanges(e, t) {
          Object.is(t, e.currentValue) ||
            ((e.previousValue = e.currentValue),
            (e.currentValue = t),
            this._addToChanges(e));
        }
        _addToAdditions(e) {
          null === this._additionsHead
            ? (this._additionsHead = this._additionsTail = e)
            : ((this._additionsTail._nextAdded = e), (this._additionsTail = e));
        }
        _addToChanges(e) {
          null === this._changesHead
            ? (this._changesHead = this._changesTail = e)
            : ((this._changesTail._nextChanged = e), (this._changesTail = e));
        }
        _forEach(e, t) {
          e instanceof Map
            ? e.forEach(t)
            : Object.keys(e).forEach((i) => t(e[i], i));
        }
      }
      class lG {
        constructor(e) {
          (this.key = e),
            (this.previousValue = null),
            (this.currentValue = null),
            (this._nextPrevious = null),
            (this._next = null),
            (this._prev = null),
            (this._nextAdded = null),
            (this._nextRemoved = null),
            (this._nextChanged = null);
        }
      }
      function uD() {
        return new Gh([new oD()]);
      }
      let Gh = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, i) {
            if (null != i) {
              const r = i.factories.slice();
              t = t.concat(r);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (i) => n.create(t, i || uD()),
              deps: [[n, new Xd(), new qd()]],
            };
          }
          find(t) {
            const i = this.factories.find((r) => r.supports(t));
            if (null != i) return i;
            throw new Y(901, !1);
          }
        }
        return (n.ɵprov = Ee({ token: n, providedIn: "root", factory: uD })), n;
      })();
      function dD() {
        return new nu([new cD()]);
      }
      let nu = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, i) {
            if (i) {
              const r = i.factories.slice();
              t = t.concat(r);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (i) => n.create(t, i || dD()),
              deps: [[n, new Xd(), new qd()]],
            };
          }
          find(t) {
            const i = this.factories.find((r) => r.supports(t));
            if (i) return i;
            throw new Y(901, !1);
          }
        }
        return (n.ɵprov = Ee({ token: n, providedIn: "root", factory: dD })), n;
      })();
      const dG = XT(null, "core", []);
      let hG = (() => {
          class n {
            constructor(t) {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(Ps));
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({})),
            n
          );
        })(),
        _v = null;
      function Os() {
        return _v;
      }
      class EG {}
      const kt = new ve("DocumentToken");
      let vv = (() => {
        class n {
          historyGo(t) {
            throw new Error("Not implemented");
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({
            token: n,
            factory: function () {
              return Te(xG);
            },
            providedIn: "platform",
          })),
          n
        );
      })();
      const CG = new ve("Location Initialized");
      let xG = (() => {
        class n extends vv {
          constructor() {
            super(),
              (this._doc = Te(kt)),
              (this._location = window.location),
              (this._history = window.history);
          }
          getBaseHrefFromDOM() {
            return Os().getBaseHref(this._doc);
          }
          onPopState(t) {
            const i = Os().getGlobalEventTarget(this._doc, "window");
            return (
              i.addEventListener("popstate", t, !1),
              () => i.removeEventListener("popstate", t)
            );
          }
          onHashChange(t) {
            const i = Os().getGlobalEventTarget(this._doc, "window");
            return (
              i.addEventListener("hashchange", t, !1),
              () => i.removeEventListener("hashchange", t)
            );
          }
          get href() {
            return this._location.href;
          }
          get protocol() {
            return this._location.protocol;
          }
          get hostname() {
            return this._location.hostname;
          }
          get port() {
            return this._location.port;
          }
          get pathname() {
            return this._location.pathname;
          }
          get search() {
            return this._location.search;
          }
          get hash() {
            return this._location.hash;
          }
          set pathname(t) {
            this._location.pathname = t;
          }
          pushState(t, i, r) {
            this._history.pushState(t, i, r);
          }
          replaceState(t, i, r) {
            this._history.replaceState(t, i, r);
          }
          forward() {
            this._history.forward();
          }
          back() {
            this._history.back();
          }
          historyGo(t = 0) {
            this._history.go(t);
          }
          getState() {
            return this._history.state;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({
            token: n,
            factory: function () {
              return new n();
            },
            providedIn: "platform",
          })),
          n
        );
      })();
      function yv(n, e) {
        if (0 == n.length) return e;
        if (0 == e.length) return n;
        let t = 0;
        return (
          n.endsWith("/") && t++,
          e.startsWith("/") && t++,
          2 == t ? n + e.substring(1) : 1 == t ? n + e : n + "/" + e
        );
      }
      function vD(n) {
        const e = n.match(/#|\?|$/),
          t = (e && e.index) || n.length;
        return n.slice(0, t - ("/" === n[t - 1] ? 1 : 0)) + n.slice(t);
      }
      function es(n) {
        return n && "?" !== n[0] ? "?" + n : n;
      }
      let Eo = (() => {
        class n {
          historyGo(t) {
            throw new Error("Not implemented");
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({
            token: n,
            factory: function () {
              return Te(bD);
            },
            providedIn: "root",
          })),
          n
        );
      })();
      const yD = new ve("appBaseHref");
      let bD = (() => {
          class n extends Eo {
            constructor(t, i) {
              super(),
                (this._platformLocation = t),
                (this._removeListenerFns = []),
                (this._baseHref =
                  i ??
                  this._platformLocation.getBaseHrefFromDOM() ??
                  Te(kt).location?.origin ??
                  "");
            }
            ngOnDestroy() {
              for (; this._removeListenerFns.length; )
                this._removeListenerFns.pop()();
            }
            onPopState(t) {
              this._removeListenerFns.push(
                this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t),
              );
            }
            getBaseHref() {
              return this._baseHref;
            }
            prepareExternalUrl(t) {
              return yv(this._baseHref, t);
            }
            path(t = !1) {
              const i =
                  this._platformLocation.pathname +
                  es(this._platformLocation.search),
                r = this._platformLocation.hash;
              return r && t ? `${i}${r}` : i;
            }
            pushState(t, i, r, s) {
              const o = this.prepareExternalUrl(r + es(s));
              this._platformLocation.pushState(t, i, o);
            }
            replaceState(t, i, r, s) {
              const o = this.prepareExternalUrl(r + es(s));
              this._platformLocation.replaceState(t, i, o);
            }
            forward() {
              this._platformLocation.forward();
            }
            back() {
              this._platformLocation.back();
            }
            getState() {
              return this._platformLocation.getState();
            }
            historyGo(t = 0) {
              this._platformLocation.historyGo?.(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(vv), se(yD, 8));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        TG = (() => {
          class n extends Eo {
            constructor(t, i) {
              super(),
                (this._platformLocation = t),
                (this._baseHref = ""),
                (this._removeListenerFns = []),
                null != i && (this._baseHref = i);
            }
            ngOnDestroy() {
              for (; this._removeListenerFns.length; )
                this._removeListenerFns.pop()();
            }
            onPopState(t) {
              this._removeListenerFns.push(
                this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t),
              );
            }
            getBaseHref() {
              return this._baseHref;
            }
            path(t = !1) {
              let i = this._platformLocation.hash;
              return null == i && (i = "#"), i.length > 0 ? i.substring(1) : i;
            }
            prepareExternalUrl(t) {
              const i = yv(this._baseHref, t);
              return i.length > 0 ? "#" + i : i;
            }
            pushState(t, i, r, s) {
              let o = this.prepareExternalUrl(r + es(s));
              0 == o.length && (o = this._platformLocation.pathname),
                this._platformLocation.pushState(t, i, o);
            }
            replaceState(t, i, r, s) {
              let o = this.prepareExternalUrl(r + es(s));
              0 == o.length && (o = this._platformLocation.pathname),
                this._platformLocation.replaceState(t, i, o);
            }
            forward() {
              this._platformLocation.forward();
            }
            back() {
              this._platformLocation.back();
            }
            getState() {
              return this._platformLocation.getState();
            }
            historyGo(t = 0) {
              this._platformLocation.historyGo?.(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(vv), se(yD, 8));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        $h = (() => {
          class n {
            constructor(t) {
              (this._subject = new Rt()),
                (this._urlChangeListeners = []),
                (this._urlChangeSubscription = null),
                (this._locationStrategy = t);
              const i = this._locationStrategy.getBaseHref();
              (this._basePath = (function IG(n) {
                if (new RegExp("^(https?:)?//").test(n)) {
                  const [, t] = n.split(/\/\/[^\/]+/);
                  return t;
                }
                return n;
              })(vD(MD(i)))),
                this._locationStrategy.onPopState((r) => {
                  this._subject.emit({
                    url: this.path(!0),
                    pop: !0,
                    state: r.state,
                    type: r.type,
                  });
                });
            }
            ngOnDestroy() {
              this._urlChangeSubscription?.unsubscribe(),
                (this._urlChangeListeners = []);
            }
            path(t = !1) {
              return this.normalize(this._locationStrategy.path(t));
            }
            getState() {
              return this._locationStrategy.getState();
            }
            isCurrentPathEqualTo(t, i = "") {
              return this.path() == this.normalize(t + es(i));
            }
            normalize(t) {
              return n.stripTrailingSlash(
                (function AG(n, e) {
                  if (!n || !e.startsWith(n)) return e;
                  const t = e.substring(n.length);
                  return "" === t || ["/", ";", "?", "#"].includes(t[0])
                    ? t
                    : e;
                })(this._basePath, MD(t)),
              );
            }
            prepareExternalUrl(t) {
              return (
                t && "/" !== t[0] && (t = "/" + t),
                this._locationStrategy.prepareExternalUrl(t)
              );
            }
            go(t, i = "", r = null) {
              this._locationStrategy.pushState(r, "", t, i),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + es(i)),
                  r,
                );
            }
            replaceState(t, i = "", r = null) {
              this._locationStrategy.replaceState(r, "", t, i),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + es(i)),
                  r,
                );
            }
            forward() {
              this._locationStrategy.forward();
            }
            back() {
              this._locationStrategy.back();
            }
            historyGo(t = 0) {
              this._locationStrategy.historyGo?.(t);
            }
            onUrlChange(t) {
              return (
                this._urlChangeListeners.push(t),
                this._urlChangeSubscription ||
                  (this._urlChangeSubscription = this.subscribe((i) => {
                    this._notifyUrlChangeListeners(i.url, i.state);
                  })),
                () => {
                  const i = this._urlChangeListeners.indexOf(t);
                  this._urlChangeListeners.splice(i, 1),
                    0 === this._urlChangeListeners.length &&
                      (this._urlChangeSubscription?.unsubscribe(),
                      (this._urlChangeSubscription = null));
                }
              );
            }
            _notifyUrlChangeListeners(t = "", i) {
              this._urlChangeListeners.forEach((r) => r(t, i));
            }
            subscribe(t, i, r) {
              return this._subject.subscribe({
                next: t,
                error: i,
                complete: r,
              });
            }
          }
          return (
            (n.normalizeQueryParams = es),
            (n.joinWithSlash = yv),
            (n.stripTrailingSlash = vD),
            (n.ɵfac = function (t) {
              return new (t || n)(se(Eo));
            }),
            (n.ɵprov = Ee({
              token: n,
              factory: function () {
                return (function DG() {
                  return new $h(se(Eo));
                })();
              },
              providedIn: "root",
            })),
            n
          );
        })();
      function MD(n) {
        return n.replace(/\/index.html$/, "");
      }
      const Av = /\s+/,
        ID = [];
      let Iv = (() => {
        class n {
          constructor(t, i, r, s) {
            (this._iterableDiffers = t),
              (this._keyValueDiffers = i),
              (this._ngEl = r),
              (this._renderer = s),
              (this.initialClasses = ID),
              (this.stateMap = new Map());
          }
          set klass(t) {
            this.initialClasses = null != t ? t.trim().split(Av) : ID;
          }
          set ngClass(t) {
            this.rawClass = "string" == typeof t ? t.trim().split(Av) : t;
          }
          ngDoCheck() {
            for (const i of this.initialClasses) this._updateState(i, !0);
            const t = this.rawClass;
            if (Array.isArray(t) || t instanceof Set)
              for (const i of t) this._updateState(i, !0);
            else if (null != t)
              for (const i of Object.keys(t)) this._updateState(i, !!t[i]);
            this._applyStateDiff();
          }
          _updateState(t, i) {
            const r = this.stateMap.get(t);
            void 0 !== r
              ? (r.enabled !== i && ((r.changed = !0), (r.enabled = i)),
                (r.touched = !0))
              : this.stateMap.set(t, { enabled: i, changed: !0, touched: !0 });
          }
          _applyStateDiff() {
            for (const t of this.stateMap) {
              const i = t[0],
                r = t[1];
              r.changed
                ? (this._toggleClass(i, r.enabled), (r.changed = !1))
                : r.touched ||
                  (r.enabled && this._toggleClass(i, !1),
                  this.stateMap.delete(i)),
                (r.touched = !1);
            }
          }
          _toggleClass(t, i) {
            (t = t.trim()).length > 0 &&
              t.split(Av).forEach((r) => {
                i
                  ? this._renderer.addClass(this._ngEl.nativeElement, r)
                  : this._renderer.removeClass(this._ngEl.nativeElement, r);
              });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(Gh), re(nu), re(Rn), re(or));
          }),
          (n.ɵdir = Ue({
            type: n,
            selectors: [["", "ngClass", ""]],
            inputs: { klass: ["class", "klass"], ngClass: "ngClass" },
            standalone: !0,
          })),
          n
        );
      })();
      class g4 {
        constructor(e, t, i, r) {
          (this.$implicit = e),
            (this.ngForOf = t),
            (this.index = i),
            (this.count = r);
        }
        get first() {
          return 0 === this.index;
        }
        get last() {
          return this.index === this.count - 1;
        }
        get even() {
          return this.index % 2 == 0;
        }
        get odd() {
          return !this.even;
        }
      }
      let PD = (() => {
        class n {
          set ngForOf(t) {
            (this._ngForOf = t), (this._ngForOfDirty = !0);
          }
          set ngForTrackBy(t) {
            this._trackByFn = t;
          }
          get ngForTrackBy() {
            return this._trackByFn;
          }
          constructor(t, i, r) {
            (this._viewContainer = t),
              (this._template = i),
              (this._differs = r),
              (this._ngForOf = null),
              (this._ngForOfDirty = !0),
              (this._differ = null);
          }
          set ngForTemplate(t) {
            t && (this._template = t);
          }
          ngDoCheck() {
            if (this._ngForOfDirty) {
              this._ngForOfDirty = !1;
              const t = this._ngForOf;
              !this._differ &&
                t &&
                (this._differ = this._differs
                  .find(t)
                  .create(this.ngForTrackBy));
            }
            if (this._differ) {
              const t = this._differ.diff(this._ngForOf);
              t && this._applyChanges(t);
            }
          }
          _applyChanges(t) {
            const i = this._viewContainer;
            t.forEachOperation((r, s, o) => {
              if (null == r.previousIndex)
                i.createEmbeddedView(
                  this._template,
                  new g4(r.item, this._ngForOf, -1, -1),
                  null === o ? void 0 : o,
                );
              else if (null == o) i.remove(null === s ? void 0 : s);
              else if (null !== s) {
                const a = i.get(s);
                i.move(a, o), OD(a, r);
              }
            });
            for (let r = 0, s = i.length; r < s; r++) {
              const a = i.get(r).context;
              (a.index = r), (a.count = s), (a.ngForOf = this._ngForOf);
            }
            t.forEachIdentityChange((r) => {
              OD(i.get(r.currentIndex), r);
            });
          }
          static ngTemplateContextGuard(t, i) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(ji), re(Rr), re(Gh));
          }),
          (n.ɵdir = Ue({
            type: n,
            selectors: [["", "ngFor", "", "ngForOf", ""]],
            inputs: {
              ngForOf: "ngForOf",
              ngForTrackBy: "ngForTrackBy",
              ngForTemplate: "ngForTemplate",
            },
            standalone: !0,
          })),
          n
        );
      })();
      function OD(n, e) {
        n.context.$implicit = e.item;
      }
      let FD = (() => {
          class n {
            constructor(t, i, r) {
              (this._ngEl = t),
                (this._differs = i),
                (this._renderer = r),
                (this._ngStyle = null),
                (this._differ = null);
            }
            set ngStyle(t) {
              (this._ngStyle = t),
                !this._differ &&
                  t &&
                  (this._differ = this._differs.find(t).create());
            }
            ngDoCheck() {
              if (this._differ) {
                const t = this._differ.diff(this._ngStyle);
                t && this._applyChanges(t);
              }
            }
            _setStyle(t, i) {
              const [r, s] = t.split("."),
                o = -1 === r.indexOf("-") ? void 0 : Ds.DashCase;
              null != i
                ? this._renderer.setStyle(
                    this._ngEl.nativeElement,
                    r,
                    s ? `${i}${s}` : i,
                    o,
                  )
                : this._renderer.removeStyle(this._ngEl.nativeElement, r, o);
            }
            _applyChanges(t) {
              t.forEachRemovedItem((i) => this._setStyle(i.key, null)),
                t.forEachAddedItem((i) =>
                  this._setStyle(i.key, i.currentValue),
                ),
                t.forEachChangedItem((i) =>
                  this._setStyle(i.key, i.currentValue),
                );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(Rn), re(nu), re(or));
            }),
            (n.ɵdir = Ue({
              type: n,
              selectors: [["", "ngStyle", ""]],
              inputs: { ngStyle: "ngStyle" },
              standalone: !0,
            })),
            n
          );
        })(),
        Ci = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({})),
            n
          );
        })();
      const UD = "browser";
      function BD(n) {
        return "server" === n;
      }
      let X4 = (() => {
        class n {}
        return (
          (n.ɵprov = Ee({
            token: n,
            providedIn: "root",
            factory: () => new Y4(se(kt), window),
          })),
          n
        );
      })();
      class Y4 {
        constructor(e, t) {
          (this.document = e), (this.window = t), (this.offset = () => [0, 0]);
        }
        setOffset(e) {
          this.offset = Array.isArray(e) ? () => e : e;
        }
        getScrollPosition() {
          return this.supportsScrolling()
            ? [this.window.pageXOffset, this.window.pageYOffset]
            : [0, 0];
        }
        scrollToPosition(e) {
          this.supportsScrolling() && this.window.scrollTo(e[0], e[1]);
        }
        scrollToAnchor(e) {
          if (!this.supportsScrolling()) return;
          const t = (function Z4(n, e) {
            const t = n.getElementById(e) || n.getElementsByName(e)[0];
            if (t) return t;
            if (
              "function" == typeof n.createTreeWalker &&
              n.body &&
              "function" == typeof n.body.attachShadow
            ) {
              const i = n.createTreeWalker(n.body, NodeFilter.SHOW_ELEMENT);
              let r = i.currentNode;
              for (; r; ) {
                const s = r.shadowRoot;
                if (s) {
                  const o =
                    s.getElementById(e) || s.querySelector(`[name="${e}"]`);
                  if (o) return o;
                }
                r = i.nextNode();
              }
            }
            return null;
          })(this.document, e);
          t && (this.scrollToElement(t), t.focus());
        }
        setHistoryScrollRestoration(e) {
          if (this.supportScrollRestoration()) {
            const t = this.window.history;
            t && t.scrollRestoration && (t.scrollRestoration = e);
          }
        }
        scrollToElement(e) {
          const t = e.getBoundingClientRect(),
            i = t.left + this.window.pageXOffset,
            r = t.top + this.window.pageYOffset,
            s = this.offset();
          this.window.scrollTo(i - s[0], r - s[1]);
        }
        supportScrollRestoration() {
          try {
            if (!this.supportsScrolling()) return !1;
            const e =
              VD(this.window.history) ||
              VD(Object.getPrototypeOf(this.window.history));
            return !(!e || (!e.writable && !e.set));
          } catch {
            return !1;
          }
        }
        supportsScrolling() {
          try {
            return (
              !!this.window &&
              !!this.window.scrollTo &&
              "pageXOffset" in this.window
            );
          } catch {
            return !1;
          }
        }
      }
      function VD(n) {
        return Object.getOwnPropertyDescriptor(n, "scrollRestoration");
      }
      class M5 extends EG {
        constructor() {
          super(...arguments), (this.supportsDOMEvents = !0);
        }
      }
      class kv extends M5 {
        static makeCurrent() {
          !(function wG(n) {
            _v || (_v = n);
          })(new kv());
        }
        onAndCancel(e, t, i) {
          return (
            e.addEventListener(t, i),
            () => {
              e.removeEventListener(t, i);
            }
          );
        }
        dispatchEvent(e, t) {
          e.dispatchEvent(t);
        }
        remove(e) {
          e.parentNode && e.parentNode.removeChild(e);
        }
        createElement(e, t) {
          return (t = t || this.getDefaultDocument()).createElement(e);
        }
        createHtmlDocument() {
          return document.implementation.createHTMLDocument("fakeTitle");
        }
        getDefaultDocument() {
          return document;
        }
        isElementNode(e) {
          return e.nodeType === Node.ELEMENT_NODE;
        }
        isShadowRoot(e) {
          return e instanceof DocumentFragment;
        }
        getGlobalEventTarget(e, t) {
          return "window" === t
            ? window
            : "document" === t
            ? e
            : "body" === t
            ? e.body
            : null;
        }
        getBaseHref(e) {
          const t = (function S5() {
            return (
              (ou = ou || document.querySelector("base")),
              ou ? ou.getAttribute("href") : null
            );
          })();
          return null == t
            ? null
            : (function w5(n) {
                (sf = sf || document.createElement("a")),
                  sf.setAttribute("href", n);
                const e = sf.pathname;
                return "/" === e.charAt(0) ? e : `/${e}`;
              })(t);
        }
        resetBaseElement() {
          ou = null;
        }
        getUserAgent() {
          return window.navigator.userAgent;
        }
        getCookie(e) {
          return (function p4(n, e) {
            e = encodeURIComponent(e);
            for (const t of n.split(";")) {
              const i = t.indexOf("="),
                [r, s] = -1 == i ? [t, ""] : [t.slice(0, i), t.slice(i + 1)];
              if (r.trim() === e) return decodeURIComponent(s);
            }
            return null;
          })(document.cookie, e);
        }
      }
      let sf,
        ou = null,
        C5 = (() => {
          class n {
            build() {
              return new XMLHttpRequest();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
            n
          );
        })();
      const Uv = new ve("EventManagerPlugins");
      let $D = (() => {
        class n {
          constructor(t, i) {
            (this._zone = i),
              (this._eventNameToPlugin = new Map()),
              t.forEach((r) => {
                r.manager = this;
              }),
              (this._plugins = t.slice().reverse());
          }
          addEventListener(t, i, r) {
            return this._findPluginFor(i).addEventListener(t, i, r);
          }
          getZone() {
            return this._zone;
          }
          _findPluginFor(t) {
            let i = this._eventNameToPlugin.get(t);
            if (i) return i;
            if (((i = this._plugins.find((s) => s.supports(t))), !i))
              throw new Y(5101, !1);
            return this._eventNameToPlugin.set(t, i), i;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se(Uv), se(yt));
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class jD {
        constructor(e) {
          this._doc = e;
        }
      }
      const Bv = "ng-app-id";
      let qD = (() => {
        class n {
          constructor(t, i, r, s = {}) {
            (this.doc = t),
              (this.appId = i),
              (this.nonce = r),
              (this.platformId = s),
              (this.styleRef = new Map()),
              (this.hostNodes = new Set()),
              (this.styleNodesInDOM = this.collectServerRenderedStyles()),
              (this.platformIsServer = BD(s)),
              this.resetHostNodes();
          }
          addStyles(t) {
            for (const i of t)
              1 === this.changeUsageCount(i, 1) && this.onStyleAdded(i);
          }
          removeStyles(t) {
            for (const i of t)
              this.changeUsageCount(i, -1) <= 0 && this.onStyleRemoved(i);
          }
          ngOnDestroy() {
            const t = this.styleNodesInDOM;
            t && (t.forEach((i) => i.remove()), t.clear());
            for (const i of this.getAllStyles()) this.onStyleRemoved(i);
            this.resetHostNodes();
          }
          addHost(t) {
            this.hostNodes.add(t);
            for (const i of this.getAllStyles()) this.addStyleToHost(t, i);
          }
          removeHost(t) {
            this.hostNodes.delete(t);
          }
          getAllStyles() {
            return this.styleRef.keys();
          }
          onStyleAdded(t) {
            for (const i of this.hostNodes) this.addStyleToHost(i, t);
          }
          onStyleRemoved(t) {
            const i = this.styleRef;
            i.get(t)?.elements?.forEach((r) => r.remove()), i.delete(t);
          }
          collectServerRenderedStyles() {
            const t = this.doc.head?.querySelectorAll(
              `style[${Bv}="${this.appId}"]`,
            );
            if (t?.length) {
              const i = new Map();
              return (
                t.forEach((r) => {
                  null != r.textContent && i.set(r.textContent, r);
                }),
                i
              );
            }
            return null;
          }
          changeUsageCount(t, i) {
            const r = this.styleRef;
            if (r.has(t)) {
              const s = r.get(t);
              return (s.usage += i), s.usage;
            }
            return r.set(t, { usage: i, elements: [] }), i;
          }
          getStyleElement(t, i) {
            const r = this.styleNodesInDOM,
              s = r?.get(i);
            if (s?.parentNode === t)
              return r.delete(i), s.removeAttribute(Bv), s;
            {
              const o = this.doc.createElement("style");
              return (
                this.nonce && o.setAttribute("nonce", this.nonce),
                (o.textContent = i),
                this.platformIsServer && o.setAttribute(Bv, this.appId),
                o
              );
            }
          }
          addStyleToHost(t, i) {
            const r = this.getStyleElement(t, i);
            t.appendChild(r);
            const s = this.styleRef,
              o = s.get(i)?.elements;
            o ? o.push(r) : s.set(i, { elements: [r], usage: 1 });
          }
          resetHostNodes() {
            const t = this.hostNodes;
            t.clear(), t.add(this.doc.head);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se(kt), se(hh), se(sE, 8), se(mo));
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const Vv = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: "http://www.w3.org/1999/xhtml",
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/",
          math: "http://www.w3.org/1998/MathML/",
        },
        Hv = /%COMP%/g,
        A5 = new ve("RemoveStylesOnCompDestroy", {
          providedIn: "root",
          factory: () => !1,
        });
      function YD(n, e) {
        return e.map((t) => t.replace(Hv, n));
      }
      let zv = (() => {
        class n {
          constructor(t, i, r, s, o, a, l, c = null) {
            (this.eventManager = t),
              (this.sharedStylesHost = i),
              (this.appId = r),
              (this.removeStylesOnCompDestroy = s),
              (this.doc = o),
              (this.platformId = a),
              (this.ngZone = l),
              (this.nonce = c),
              (this.rendererByCompId = new Map()),
              (this.platformIsServer = BD(a)),
              (this.defaultRenderer = new Gv(t, o, l, this.platformIsServer));
          }
          createRenderer(t, i) {
            if (!t || !i) return this.defaultRenderer;
            this.platformIsServer &&
              i.encapsulation === Vi.ShadowDom &&
              (i = { ...i, encapsulation: Vi.Emulated });
            const r = this.getOrCreateRenderer(t, i);
            return (
              r instanceof KD
                ? r.applyToHost(t)
                : r instanceof Wv && r.applyStyles(),
              r
            );
          }
          getOrCreateRenderer(t, i) {
            const r = this.rendererByCompId;
            let s = r.get(i.id);
            if (!s) {
              const o = this.doc,
                a = this.ngZone,
                l = this.eventManager,
                c = this.sharedStylesHost,
                u = this.removeStylesOnCompDestroy,
                d = this.platformIsServer;
              switch (i.encapsulation) {
                case Vi.Emulated:
                  s = new KD(l, c, i, this.appId, u, o, a, d);
                  break;
                case Vi.ShadowDom:
                  return new O5(l, c, t, i, o, a, this.nonce, d);
                default:
                  s = new Wv(l, c, i, u, o, a, d);
              }
              r.set(i.id, s);
            }
            return s;
          }
          ngOnDestroy() {
            this.rendererByCompId.clear();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(
              se($D),
              se(qD),
              se(hh),
              se(A5),
              se(kt),
              se(mo),
              se(yt),
              se(sE),
            );
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class Gv {
        constructor(e, t, i, r) {
          (this.eventManager = e),
            (this.doc = t),
            (this.ngZone = i),
            (this.platformIsServer = r),
            (this.data = Object.create(null)),
            (this.destroyNode = null);
        }
        destroy() {}
        createElement(e, t) {
          return t
            ? this.doc.createElementNS(Vv[t] || t, e)
            : this.doc.createElement(e);
        }
        createComment(e) {
          return this.doc.createComment(e);
        }
        createText(e) {
          return this.doc.createTextNode(e);
        }
        appendChild(e, t) {
          (ZD(e) ? e.content : e).appendChild(t);
        }
        insertBefore(e, t, i) {
          e && (ZD(e) ? e.content : e).insertBefore(t, i);
        }
        removeChild(e, t) {
          e && e.removeChild(t);
        }
        selectRootElement(e, t) {
          let i = "string" == typeof e ? this.doc.querySelector(e) : e;
          if (!i) throw new Y(-5104, !1);
          return t || (i.textContent = ""), i;
        }
        parentNode(e) {
          return e.parentNode;
        }
        nextSibling(e) {
          return e.nextSibling;
        }
        setAttribute(e, t, i, r) {
          if (r) {
            t = r + ":" + t;
            const s = Vv[r];
            s ? e.setAttributeNS(s, t, i) : e.setAttribute(t, i);
          } else e.setAttribute(t, i);
        }
        removeAttribute(e, t, i) {
          if (i) {
            const r = Vv[i];
            r ? e.removeAttributeNS(r, t) : e.removeAttribute(`${i}:${t}`);
          } else e.removeAttribute(t);
        }
        addClass(e, t) {
          e.classList.add(t);
        }
        removeClass(e, t) {
          e.classList.remove(t);
        }
        setStyle(e, t, i, r) {
          r & (Ds.DashCase | Ds.Important)
            ? e.style.setProperty(t, i, r & Ds.Important ? "important" : "")
            : (e.style[t] = i);
        }
        removeStyle(e, t, i) {
          i & Ds.DashCase ? e.style.removeProperty(t) : (e.style[t] = "");
        }
        setProperty(e, t, i) {
          e[t] = i;
        }
        setValue(e, t) {
          e.nodeValue = t;
        }
        listen(e, t, i) {
          if (
            "string" == typeof e &&
            !(e = Os().getGlobalEventTarget(this.doc, e))
          )
            throw new Error(`Unsupported event target ${e} for event ${t}`);
          return this.eventManager.addEventListener(
            e,
            t,
            this.decoratePreventDefault(i),
          );
        }
        decoratePreventDefault(e) {
          return (t) => {
            if ("__ngUnwrap__" === t) return e;
            !1 ===
              (this.platformIsServer
                ? this.ngZone.runGuarded(() => e(t))
                : e(t)) && t.preventDefault();
          };
        }
      }
      function ZD(n) {
        return "TEMPLATE" === n.tagName && void 0 !== n.content;
      }
      class O5 extends Gv {
        constructor(e, t, i, r, s, o, a, l) {
          super(e, s, o, l),
            (this.sharedStylesHost = t),
            (this.hostEl = i),
            (this.shadowRoot = i.attachShadow({ mode: "open" })),
            this.sharedStylesHost.addHost(this.shadowRoot);
          const c = YD(r.id, r.styles);
          for (const u of c) {
            const d = document.createElement("style");
            a && d.setAttribute("nonce", a),
              (d.textContent = u),
              this.shadowRoot.appendChild(d);
          }
        }
        nodeOrShadowRoot(e) {
          return e === this.hostEl ? this.shadowRoot : e;
        }
        appendChild(e, t) {
          return super.appendChild(this.nodeOrShadowRoot(e), t);
        }
        insertBefore(e, t, i) {
          return super.insertBefore(this.nodeOrShadowRoot(e), t, i);
        }
        removeChild(e, t) {
          return super.removeChild(this.nodeOrShadowRoot(e), t);
        }
        parentNode(e) {
          return this.nodeOrShadowRoot(
            super.parentNode(this.nodeOrShadowRoot(e)),
          );
        }
        destroy() {
          this.sharedStylesHost.removeHost(this.shadowRoot);
        }
      }
      class Wv extends Gv {
        constructor(e, t, i, r, s, o, a, l) {
          super(e, s, o, a),
            (this.sharedStylesHost = t),
            (this.removeStylesOnCompDestroy = r),
            (this.styles = l ? YD(l, i.styles) : i.styles);
        }
        applyStyles() {
          this.sharedStylesHost.addStyles(this.styles);
        }
        destroy() {
          this.removeStylesOnCompDestroy &&
            this.sharedStylesHost.removeStyles(this.styles);
        }
      }
      class KD extends Wv {
        constructor(e, t, i, r, s, o, a, l) {
          const c = r + "-" + i.id;
          super(e, t, i, s, o, a, l, c),
            (this.contentAttr = (function I5(n) {
              return "_ngcontent-%COMP%".replace(Hv, n);
            })(c)),
            (this.hostAttr = (function R5(n) {
              return "_nghost-%COMP%".replace(Hv, n);
            })(c));
        }
        applyToHost(e) {
          this.applyStyles(), this.setAttribute(e, this.hostAttr, "");
        }
        createElement(e, t) {
          const i = super.createElement(e, t);
          return super.setAttribute(i, this.contentAttr, ""), i;
        }
      }
      let N5 = (() => {
        class n extends jD {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return !0;
          }
          addEventListener(t, i, r) {
            return (
              t.addEventListener(i, r, !1),
              () => this.removeEventListener(t, i, r)
            );
          }
          removeEventListener(t, i, r) {
            return t.removeEventListener(i, r);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se(kt));
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const QD = ["alt", "control", "meta", "shift"],
        L5 = {
          "\b": "Backspace",
          "\t": "Tab",
          "\x7f": "Delete",
          "\x1b": "Escape",
          Del: "Delete",
          Esc: "Escape",
          Left: "ArrowLeft",
          Right: "ArrowRight",
          Up: "ArrowUp",
          Down: "ArrowDown",
          Menu: "ContextMenu",
          Scroll: "ScrollLock",
          Win: "OS",
        },
        F5 = {
          alt: (n) => n.altKey,
          control: (n) => n.ctrlKey,
          meta: (n) => n.metaKey,
          shift: (n) => n.shiftKey,
        };
      let k5 = (() => {
        class n extends jD {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return null != n.parseEventName(t);
          }
          addEventListener(t, i, r) {
            const s = n.parseEventName(i),
              o = n.eventCallback(s.fullKey, r, this.manager.getZone());
            return this.manager
              .getZone()
              .runOutsideAngular(() => Os().onAndCancel(t, s.domEventName, o));
          }
          static parseEventName(t) {
            const i = t.toLowerCase().split("."),
              r = i.shift();
            if (0 === i.length || ("keydown" !== r && "keyup" !== r))
              return null;
            const s = n._normalizeKey(i.pop());
            let o = "",
              a = i.indexOf("code");
            if (
              (a > -1 && (i.splice(a, 1), (o = "code.")),
              QD.forEach((c) => {
                const u = i.indexOf(c);
                u > -1 && (i.splice(u, 1), (o += c + "."));
              }),
              (o += s),
              0 != i.length || 0 === s.length)
            )
              return null;
            const l = {};
            return (l.domEventName = r), (l.fullKey = o), l;
          }
          static matchEventFullKeyCode(t, i) {
            let r = L5[t.key] || t.key,
              s = "";
            return (
              i.indexOf("code.") > -1 && ((r = t.code), (s = "code.")),
              !(null == r || !r) &&
                ((r = r.toLowerCase()),
                " " === r ? (r = "space") : "." === r && (r = "dot"),
                QD.forEach((o) => {
                  o !== r && (0, F5[o])(t) && (s += o + ".");
                }),
                (s += r),
                s === i)
            );
          }
          static eventCallback(t, i, r) {
            return (s) => {
              n.matchEventFullKeyCode(s, t) && r.runGuarded(() => i(s));
            };
          }
          static _normalizeKey(t) {
            return "esc" === t ? "escape" : t;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se(kt));
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const H5 = XT(dG, "browser", [
          { provide: mo, useValue: UD },
          {
            provide: rE,
            useValue: function U5() {
              kv.makeCurrent();
            },
            multi: !0,
          },
          {
            provide: kt,
            useFactory: function V5() {
              return (
                (function H2(n) {
                  Ag = n;
                })(document),
                document
              );
            },
            deps: [],
          },
        ]),
        z5 = new ve(""),
        tA = [
          {
            provide: Bh,
            useClass: class E5 {
              addToWindow(e) {
                (Vt.getAngularTestability = (i, r = !0) => {
                  const s = e.findTestabilityInTree(i, r);
                  if (null == s) throw new Y(5103, !1);
                  return s;
                }),
                  (Vt.getAllAngularTestabilities = () =>
                    e.getAllTestabilities()),
                  (Vt.getAllAngularRootElements = () => e.getAllRootElements()),
                  Vt.frameworkStabilizers || (Vt.frameworkStabilizers = []),
                  Vt.frameworkStabilizers.push((i) => {
                    const r = Vt.getAllAngularTestabilities();
                    let s = r.length,
                      o = !1;
                    const a = function (l) {
                      (o = o || l), s--, 0 == s && i(o);
                    };
                    r.forEach((l) => {
                      l.whenStable(a);
                    });
                  });
              }
              findTestabilityInTree(e, t, i) {
                return null == t
                  ? null
                  : e.getTestability(t) ??
                      (i
                        ? Os().isShadowRoot(t)
                          ? this.findTestabilityInTree(e, t.host, !0)
                          : this.findTestabilityInTree(e, t.parentElement, !0)
                        : null);
              }
            },
            deps: [],
          },
          { provide: GT, useClass: sv, deps: [yt, ov, Bh] },
          { provide: sv, useClass: sv, deps: [yt, ov, Bh] },
        ],
        nA = [
          { provide: Ug, useValue: "root" },
          {
            provide: _o,
            useFactory: function B5() {
              return new _o();
            },
            deps: [],
          },
          { provide: Uv, useClass: N5, multi: !0, deps: [kt, yt, mo] },
          { provide: Uv, useClass: k5, multi: !0, deps: [kt] },
          zv,
          qD,
          $D,
          { provide: Nc, useExisting: zv },
          { provide: class K4 {}, useClass: C5, deps: [] },
          [],
        ];
      let iA = (() => {
          class n {
            constructor(t) {}
            static withServerTransition(t) {
              return {
                ngModule: n,
                providers: [{ provide: hh, useValue: t.appId }],
              };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(z5, 12));
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({ providers: [...nA, ...tA], imports: [Ci, hG] })),
            n
          );
        })(),
        rA = (() => {
          class n {
            constructor(t) {
              this._doc = t;
            }
            getTitle() {
              return this._doc.title;
            }
            setTitle(t) {
              this._doc.title = t || "";
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(kt));
            }),
            (n.ɵprov = Ee({
              token: n,
              factory: function (t) {
                let i = null;
                return (
                  (i = t
                    ? new t()
                    : (function W5() {
                        return new rA(se(kt));
                      })()),
                  i
                );
              },
              providedIn: "root",
            })),
            n
          );
        })();
      typeof window < "u" && window;
      const { isArray: Z5 } = Array,
        { getPrototypeOf: K5, prototype: Q5, keys: J5 } = Object;
      const { isArray: tW } = Array;
      function jv(n) {
        return Bt((e) =>
          (function nW(n, e) {
            return tW(e) ? n(...e) : n(e);
          })(n, e),
        );
      }
      function qv(...n) {
        const e = ac(n),
          t = (function DM(n) {
            return gt(Am(n)) ? n.pop() : void 0;
          })(n),
          { args: i, keys: r } = (function lA(n) {
            if (1 === n.length) {
              const e = n[0];
              if (Z5(e)) return { args: e, keys: null };
              if (
                (function eW(n) {
                  return n && "object" == typeof n && K5(n) === Q5;
                })(e)
              ) {
                const t = J5(e);
                return { args: t.map((i) => e[i]), keys: t };
              }
            }
            return { args: n, keys: null };
          })(n);
        if (0 === i.length) return Sn([], e);
        const s = new Yt(
          (function iW(n, e, t = Ss) {
            return (i) => {
              uA(
                e,
                () => {
                  const { length: r } = n,
                    s = new Array(r);
                  let o = r,
                    a = r;
                  for (let l = 0; l < r; l++)
                    uA(
                      e,
                      () => {
                        const c = Sn(n[l], e);
                        let u = !1;
                        c.subscribe(
                          tn(
                            i,
                            (d) => {
                              (s[l] = d),
                                u || ((u = !0), a--),
                                a || i.next(t(s.slice()));
                            },
                            () => {
                              --o || i.complete();
                            },
                          ),
                        );
                      },
                      i,
                    );
                },
                i,
              );
            };
          })(
            i,
            e,
            r
              ? (o) =>
                  (function cA(n, e) {
                    return n.reduce((t, i, r) => ((t[i] = e[r]), t), {});
                  })(r, o)
              : Ss,
          ),
        );
        return t ? s.pipe(jv(t)) : s;
      }
      function uA(n, e, t) {
        n ? Hr(t, n, e) : e();
      }
      const af = sc(
        (n) =>
          function () {
            n(this),
              (this.name = "EmptyError"),
              (this.message = "no elements in sequence");
          },
      );
      function Xv(...n) {
        return (function rW() {
          return da(1);
        })()(Sn(n, ac(n)));
      }
      function dA(n) {
        return new Yt((e) => {
          qn(n()).subscribe(e);
        });
      }
      function au(n, e) {
        const t = gt(n) ? n : () => n,
          i = (r) => r.error(t());
        return new Yt(e ? (r) => e.schedule(i, 0, r) : i);
      }
      function Yv() {
        return fn((n, e) => {
          let t = null;
          n._refCount++;
          const i = tn(e, void 0, void 0, void 0, () => {
            if (!n || n._refCount <= 0 || 0 < --n._refCount)
              return void (t = null);
            const r = n._connection,
              s = t;
            (t = null),
              r && (!s || r === s) && r.unsubscribe(),
              e.unsubscribe();
          });
          n.subscribe(i), i.closed || (t = n.connect());
        });
      }
      class hA extends Yt {
        constructor(e, t) {
          super(),
            (this.source = e),
            (this.subjectFactory = t),
            (this._subject = null),
            (this._refCount = 0),
            (this._connection = null),
            fM(e) && (this.lift = e.lift);
        }
        _subscribe(e) {
          return this.getSubject().subscribe(e);
        }
        getSubject() {
          const e = this._subject;
          return (
            (!e || e.isStopped) && (this._subject = this.subjectFactory()),
            this._subject
          );
        }
        _teardown() {
          this._refCount = 0;
          const { _connection: e } = this;
          (this._subject = this._connection = null), e?.unsubscribe();
        }
        connect() {
          let e = this._connection;
          if (!e) {
            e = this._connection = new Un();
            const t = this.getSubject();
            e.add(
              this.source.subscribe(
                tn(
                  t,
                  void 0,
                  () => {
                    this._teardown(), t.complete();
                  },
                  (i) => {
                    this._teardown(), t.error(i);
                  },
                  () => this._teardown(),
                ),
              ),
            ),
              e.closed && ((this._connection = null), (e = Un.EMPTY));
          }
          return e;
        }
        refCount() {
          return Yv()(this);
        }
      }
      function xi(n) {
        return n <= 0
          ? () => yr
          : fn((e, t) => {
              let i = 0;
              e.subscribe(
                tn(t, (r) => {
                  ++i <= n && (t.next(r), n <= i && t.complete());
                }),
              );
            });
      }
      function fA(...n) {
        const e = ac(n);
        return fn((t, i) => {
          (e ? Xv(n, t, e) : Xv(n, t)).subscribe(i);
        });
      }
      function Yi(n, e) {
        return fn((t, i) => {
          let r = 0;
          t.subscribe(tn(i, (s) => n.call(e, s, r++) && i.next(s)));
        });
      }
      function lf(n) {
        return fn((e, t) => {
          let i = !1;
          e.subscribe(
            tn(
              t,
              (r) => {
                (i = !0), t.next(r);
              },
              () => {
                i || t.next(n), t.complete();
              },
            ),
          );
        });
      }
      function pA(n = sW) {
        return fn((e, t) => {
          let i = !1;
          e.subscribe(
            tn(
              t,
              (r) => {
                (i = !0), t.next(r);
              },
              () => (i ? t.complete() : t.error(n())),
            ),
          );
        });
      }
      function sW() {
        return new af();
      }
      function Co(n, e) {
        const t = arguments.length >= 2;
        return (i) =>
          i.pipe(
            n ? Yi((r, s) => n(r, s, i)) : Ss,
            xi(1),
            t ? lf(e) : pA(() => new af()),
          );
      }
      function lu(n, e) {
        return gt(e) ? An(n, e, 1) : An(n, 1);
      }
      function Jn(n, e, t) {
        const i = gt(n) || e || t ? { next: n, error: e, complete: t } : n;
        return i
          ? fn((r, s) => {
              var o;
              null === (o = i.subscribe) || void 0 === o || o.call(i);
              let a = !0;
              r.subscribe(
                tn(
                  s,
                  (l) => {
                    var c;
                    null === (c = i.next) || void 0 === c || c.call(i, l),
                      s.next(l);
                  },
                  () => {
                    var l;
                    (a = !1),
                      null === (l = i.complete) || void 0 === l || l.call(i),
                      s.complete();
                  },
                  (l) => {
                    var c;
                    (a = !1),
                      null === (c = i.error) || void 0 === c || c.call(i, l),
                      s.error(l);
                  },
                  () => {
                    var l, c;
                    a &&
                      (null === (l = i.unsubscribe) ||
                        void 0 === l ||
                        l.call(i)),
                      null === (c = i.finalize) || void 0 === c || c.call(i);
                  },
                ),
              );
            })
          : Ss;
      }
      function xo(n) {
        return fn((e, t) => {
          let s,
            i = null,
            r = !1;
          (i = e.subscribe(
            tn(t, void 0, void 0, (o) => {
              (s = qn(n(o, xo(n)(e)))),
                i ? (i.unsubscribe(), (i = null), s.subscribe(t)) : (r = !0);
            }),
          )),
            r && (i.unsubscribe(), (i = null), s.subscribe(t));
        });
      }
      function Zv(n) {
        return n <= 0
          ? () => yr
          : fn((e, t) => {
              let i = [];
              e.subscribe(
                tn(
                  t,
                  (r) => {
                    i.push(r), n < i.length && i.shift();
                  },
                  () => {
                    for (const r of i) t.next(r);
                    t.complete();
                  },
                  void 0,
                  () => {
                    i = null;
                  },
                ),
              );
            });
      }
      function Kv(n) {
        return fn((e, t) => {
          try {
            e.subscribe(t);
          } finally {
            t.add(n);
          }
        });
      }
      const nt = "primary",
        cu = Symbol("RouteTitle");
      class uW {
        constructor(e) {
          this.params = e || {};
        }
        has(e) {
          return Object.prototype.hasOwnProperty.call(this.params, e);
        }
        get(e) {
          if (this.has(e)) {
            const t = this.params[e];
            return Array.isArray(t) ? t[0] : t;
          }
          return null;
        }
        getAll(e) {
          if (this.has(e)) {
            const t = this.params[e];
            return Array.isArray(t) ? t : [t];
          }
          return [];
        }
        get keys() {
          return Object.keys(this.params);
        }
      }
      function sl(n) {
        return new uW(n);
      }
      function dW(n, e, t) {
        const i = t.path.split("/");
        if (
          i.length > n.length ||
          ("full" === t.pathMatch && (e.hasChildren() || i.length < n.length))
        )
          return null;
        const r = {};
        for (let s = 0; s < i.length; s++) {
          const o = i[s],
            a = n[s];
          if (o.startsWith(":")) r[o.substring(1)] = a;
          else if (o !== a.path) return null;
        }
        return { consumed: n.slice(0, i.length), posParams: r };
      }
      function Pr(n, e) {
        const t = n ? Object.keys(n) : void 0,
          i = e ? Object.keys(e) : void 0;
        if (!t || !i || t.length != i.length) return !1;
        let r;
        for (let s = 0; s < t.length; s++)
          if (((r = t[s]), !mA(n[r], e[r]))) return !1;
        return !0;
      }
      function mA(n, e) {
        if (Array.isArray(n) && Array.isArray(e)) {
          if (n.length !== e.length) return !1;
          const t = [...n].sort(),
            i = [...e].sort();
          return t.every((r, s) => i[s] === r);
        }
        return n === e;
      }
      function gA(n) {
        return n.length > 0 ? n[n.length - 1] : null;
      }
      function Ls(n) {
        return (function Y5(n) {
          return !!n && (n instanceof Yt || (gt(n.lift) && gt(n.subscribe)));
        })(n)
          ? n
          : $c(n)
          ? Sn(Promise.resolve(n))
          : We(n);
      }
      const fW = {
          exact: function yA(n, e, t) {
            if (
              !To(n.segments, e.segments) ||
              !cf(n.segments, e.segments, t) ||
              n.numberOfChildren !== e.numberOfChildren
            )
              return !1;
            for (const i in e.children)
              if (!n.children[i] || !yA(n.children[i], e.children[i], t))
                return !1;
            return !0;
          },
          subset: bA,
        },
        _A = {
          exact: function pW(n, e) {
            return Pr(n, e);
          },
          subset: function mW(n, e) {
            return (
              Object.keys(e).length <= Object.keys(n).length &&
              Object.keys(e).every((t) => mA(n[t], e[t]))
            );
          },
          ignored: () => !0,
        };
      function vA(n, e, t) {
        return (
          fW[t.paths](n.root, e.root, t.matrixParams) &&
          _A[t.queryParams](n.queryParams, e.queryParams) &&
          !("exact" === t.fragment && n.fragment !== e.fragment)
        );
      }
      function bA(n, e, t) {
        return MA(n, e, e.segments, t);
      }
      function MA(n, e, t, i) {
        if (n.segments.length > t.length) {
          const r = n.segments.slice(0, t.length);
          return !(!To(r, t) || e.hasChildren() || !cf(r, t, i));
        }
        if (n.segments.length === t.length) {
          if (!To(n.segments, t) || !cf(n.segments, t, i)) return !1;
          for (const r in e.children)
            if (!n.children[r] || !bA(n.children[r], e.children[r], i))
              return !1;
          return !0;
        }
        {
          const r = t.slice(0, n.segments.length),
            s = t.slice(n.segments.length);
          return (
            !!(To(n.segments, r) && cf(n.segments, r, i) && n.children[nt]) &&
            MA(n.children[nt], e, s, i)
          );
        }
      }
      function cf(n, e, t) {
        return e.every((i, r) => _A[t](n[r].parameters, i.parameters));
      }
      class ol {
        constructor(e = new Lt([], {}), t = {}, i = null) {
          (this.root = e), (this.queryParams = t), (this.fragment = i);
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = sl(this.queryParams)),
            this._queryParamMap
          );
        }
        toString() {
          return vW.serialize(this);
        }
      }
      class Lt {
        constructor(e, t) {
          (this.segments = e),
            (this.children = t),
            (this.parent = null),
            Object.values(t).forEach((i) => (i.parent = this));
        }
        hasChildren() {
          return this.numberOfChildren > 0;
        }
        get numberOfChildren() {
          return Object.keys(this.children).length;
        }
        toString() {
          return uf(this);
        }
      }
      class uu {
        constructor(e, t) {
          (this.path = e), (this.parameters = t);
        }
        get parameterMap() {
          return (
            this._parameterMap || (this._parameterMap = sl(this.parameters)),
            this._parameterMap
          );
        }
        toString() {
          return EA(this);
        }
      }
      function To(n, e) {
        return n.length === e.length && n.every((t, i) => t.path === e[i].path);
      }
      let du = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({
            token: n,
            factory: function () {
              return new Qv();
            },
            providedIn: "root",
          })),
          n
        );
      })();
      class Qv {
        parse(e) {
          const t = new AW(e);
          return new ol(
            t.parseRootSegment(),
            t.parseQueryParams(),
            t.parseFragment(),
          );
        }
        serialize(e) {
          const t = `/${hu(e.root, !0)}`,
            i = (function MW(n) {
              const e = Object.keys(n)
                .map((t) => {
                  const i = n[t];
                  return Array.isArray(i)
                    ? i.map((r) => `${df(t)}=${df(r)}`).join("&")
                    : `${df(t)}=${df(i)}`;
                })
                .filter((t) => !!t);
              return e.length ? `?${e.join("&")}` : "";
            })(e.queryParams);
          return `${t}${i}${
            "string" == typeof e.fragment
              ? `#${(function yW(n) {
                  return encodeURI(n);
                })(e.fragment)}`
              : ""
          }`;
        }
      }
      const vW = new Qv();
      function uf(n) {
        return n.segments.map((e) => EA(e)).join("/");
      }
      function hu(n, e) {
        if (!n.hasChildren()) return uf(n);
        if (e) {
          const t = n.children[nt] ? hu(n.children[nt], !1) : "",
            i = [];
          return (
            Object.entries(n.children).forEach(([r, s]) => {
              r !== nt && i.push(`${r}:${hu(s, !1)}`);
            }),
            i.length > 0 ? `${t}(${i.join("//")})` : t
          );
        }
        {
          const t = (function _W(n, e) {
            let t = [];
            return (
              Object.entries(n.children).forEach(([i, r]) => {
                i === nt && (t = t.concat(e(r, i)));
              }),
              Object.entries(n.children).forEach(([i, r]) => {
                i !== nt && (t = t.concat(e(r, i)));
              }),
              t
            );
          })(n, (i, r) =>
            r === nt ? [hu(n.children[nt], !1)] : [`${r}:${hu(i, !1)}`],
          );
          return 1 === Object.keys(n.children).length && null != n.children[nt]
            ? `${uf(n)}/${t[0]}`
            : `${uf(n)}/(${t.join("//")})`;
        }
      }
      function SA(n) {
        return encodeURIComponent(n)
          .replace(/%40/g, "@")
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",");
      }
      function df(n) {
        return SA(n).replace(/%3B/gi, ";");
      }
      function Jv(n) {
        return SA(n)
          .replace(/\(/g, "%28")
          .replace(/\)/g, "%29")
          .replace(/%26/gi, "&");
      }
      function hf(n) {
        return decodeURIComponent(n);
      }
      function wA(n) {
        return hf(n.replace(/\+/g, "%20"));
      }
      function EA(n) {
        return `${Jv(n.path)}${(function bW(n) {
          return Object.keys(n)
            .map((e) => `;${Jv(e)}=${Jv(n[e])}`)
            .join("");
        })(n.parameters)}`;
      }
      const SW = /^[^\/()?;#]+/;
      function ey(n) {
        const e = n.match(SW);
        return e ? e[0] : "";
      }
      const wW = /^[^\/()?;=#]+/,
        CW = /^[^=?&#]+/,
        TW = /^[^&#]+/;
      class AW {
        constructor(e) {
          (this.url = e), (this.remaining = e);
        }
        parseRootSegment() {
          return (
            this.consumeOptional("/"),
            "" === this.remaining ||
            this.peekStartsWith("?") ||
            this.peekStartsWith("#")
              ? new Lt([], {})
              : new Lt([], this.parseChildren())
          );
        }
        parseQueryParams() {
          const e = {};
          if (this.consumeOptional("?"))
            do {
              this.parseQueryParam(e);
            } while (this.consumeOptional("&"));
          return e;
        }
        parseFragment() {
          return this.consumeOptional("#")
            ? decodeURIComponent(this.remaining)
            : null;
        }
        parseChildren() {
          if ("" === this.remaining) return {};
          this.consumeOptional("/");
          const e = [];
          for (
            this.peekStartsWith("(") || e.push(this.parseSegment());
            this.peekStartsWith("/") &&
            !this.peekStartsWith("//") &&
            !this.peekStartsWith("/(");

          )
            this.capture("/"), e.push(this.parseSegment());
          let t = {};
          this.peekStartsWith("/(") &&
            (this.capture("/"), (t = this.parseParens(!0)));
          let i = {};
          return (
            this.peekStartsWith("(") && (i = this.parseParens(!1)),
            (e.length > 0 || Object.keys(t).length > 0) &&
              (i[nt] = new Lt(e, t)),
            i
          );
        }
        parseSegment() {
          const e = ey(this.remaining);
          if ("" === e && this.peekStartsWith(";")) throw new Y(4009, !1);
          return this.capture(e), new uu(hf(e), this.parseMatrixParams());
        }
        parseMatrixParams() {
          const e = {};
          for (; this.consumeOptional(";"); ) this.parseParam(e);
          return e;
        }
        parseParam(e) {
          const t = (function EW(n) {
            const e = n.match(wW);
            return e ? e[0] : "";
          })(this.remaining);
          if (!t) return;
          this.capture(t);
          let i = "";
          if (this.consumeOptional("=")) {
            const r = ey(this.remaining);
            r && ((i = r), this.capture(i));
          }
          e[hf(t)] = hf(i);
        }
        parseQueryParam(e) {
          const t = (function xW(n) {
            const e = n.match(CW);
            return e ? e[0] : "";
          })(this.remaining);
          if (!t) return;
          this.capture(t);
          let i = "";
          if (this.consumeOptional("=")) {
            const o = (function DW(n) {
              const e = n.match(TW);
              return e ? e[0] : "";
            })(this.remaining);
            o && ((i = o), this.capture(i));
          }
          const r = wA(t),
            s = wA(i);
          if (e.hasOwnProperty(r)) {
            let o = e[r];
            Array.isArray(o) || ((o = [o]), (e[r] = o)), o.push(s);
          } else e[r] = s;
        }
        parseParens(e) {
          const t = {};
          for (
            this.capture("(");
            !this.consumeOptional(")") && this.remaining.length > 0;

          ) {
            const i = ey(this.remaining),
              r = this.remaining[i.length];
            if ("/" !== r && ")" !== r && ";" !== r) throw new Y(4010, !1);
            let s;
            i.indexOf(":") > -1
              ? ((s = i.slice(0, i.indexOf(":"))),
                this.capture(s),
                this.capture(":"))
              : e && (s = nt);
            const o = this.parseChildren();
            (t[s] = 1 === Object.keys(o).length ? o[nt] : new Lt([], o)),
              this.consumeOptional("//");
          }
          return t;
        }
        peekStartsWith(e) {
          return this.remaining.startsWith(e);
        }
        consumeOptional(e) {
          return (
            !!this.peekStartsWith(e) &&
            ((this.remaining = this.remaining.substring(e.length)), !0)
          );
        }
        capture(e) {
          if (!this.consumeOptional(e)) throw new Y(4011, !1);
        }
      }
      function CA(n) {
        return n.segments.length > 0 ? new Lt([], { [nt]: n }) : n;
      }
      function xA(n) {
        const e = {};
        for (const i of Object.keys(n.children)) {
          const s = xA(n.children[i]);
          if (i === nt && 0 === s.segments.length && s.hasChildren())
            for (const [o, a] of Object.entries(s.children)) e[o] = a;
          else (s.segments.length > 0 || s.hasChildren()) && (e[i] = s);
        }
        return (function IW(n) {
          if (1 === n.numberOfChildren && n.children[nt]) {
            const e = n.children[nt];
            return new Lt(n.segments.concat(e.segments), e.children);
          }
          return n;
        })(new Lt(n.segments, e));
      }
      function Do(n) {
        return n instanceof ol;
      }
      function TA(n) {
        let e;
        const r = CA(
          (function t(s) {
            const o = {};
            for (const l of s.children) {
              const c = t(l);
              o[l.outlet] = c;
            }
            const a = new Lt(s.url, o);
            return s === n && (e = a), a;
          })(n.root),
        );
        return e ?? r;
      }
      function DA(n, e, t, i) {
        let r = n;
        for (; r.parent; ) r = r.parent;
        if (0 === e.length) return ty(r, r, r, t, i);
        const s = (function PW(n) {
          if ("string" == typeof n[0] && 1 === n.length && "/" === n[0])
            return new IA(!0, 0, n);
          let e = 0,
            t = !1;
          const i = n.reduce((r, s, o) => {
            if ("object" == typeof s && null != s) {
              if (s.outlets) {
                const a = {};
                return (
                  Object.entries(s.outlets).forEach(([l, c]) => {
                    a[l] = "string" == typeof c ? c.split("/") : c;
                  }),
                  [...r, { outlets: a }]
                );
              }
              if (s.segmentPath) return [...r, s.segmentPath];
            }
            return "string" != typeof s
              ? [...r, s]
              : 0 === o
              ? (s.split("/").forEach((a, l) => {
                  (0 == l && "." === a) ||
                    (0 == l && "" === a
                      ? (t = !0)
                      : ".." === a
                      ? e++
                      : "" != a && r.push(a));
                }),
                r)
              : [...r, s];
          }, []);
          return new IA(t, e, i);
        })(e);
        if (s.toRoot()) return ty(r, r, new Lt([], {}), t, i);
        const o = (function OW(n, e, t) {
            if (n.isAbsolute) return new pf(e, !0, 0);
            if (!t) return new pf(e, !1, NaN);
            if (null === t.parent) return new pf(t, !0, 0);
            const i = ff(n.commands[0]) ? 0 : 1;
            return (function NW(n, e, t) {
              let i = n,
                r = e,
                s = t;
              for (; s > r; ) {
                if (((s -= r), (i = i.parent), !i)) throw new Y(4005, !1);
                r = i.segments.length;
              }
              return new pf(i, !1, r - s);
            })(t, t.segments.length - 1 + i, n.numberOfDoubleDots);
          })(s, r, n),
          a = o.processChildren
            ? pu(o.segmentGroup, o.index, s.commands)
            : RA(o.segmentGroup, o.index, s.commands);
        return ty(r, o.segmentGroup, a, t, i);
      }
      function ff(n) {
        return (
          "object" == typeof n && null != n && !n.outlets && !n.segmentPath
        );
      }
      function fu(n) {
        return "object" == typeof n && null != n && n.outlets;
      }
      function ty(n, e, t, i, r) {
        let o,
          s = {};
        i &&
          Object.entries(i).forEach(([l, c]) => {
            s[l] = Array.isArray(c) ? c.map((u) => `${u}`) : `${c}`;
          }),
          (o = n === e ? t : AA(n, e, t));
        const a = CA(xA(o));
        return new ol(a, s, r);
      }
      function AA(n, e, t) {
        const i = {};
        return (
          Object.entries(n.children).forEach(([r, s]) => {
            i[r] = s === e ? t : AA(s, e, t);
          }),
          new Lt(n.segments, i)
        );
      }
      class IA {
        constructor(e, t, i) {
          if (
            ((this.isAbsolute = e),
            (this.numberOfDoubleDots = t),
            (this.commands = i),
            e && i.length > 0 && ff(i[0]))
          )
            throw new Y(4003, !1);
          const r = i.find(fu);
          if (r && r !== gA(i)) throw new Y(4004, !1);
        }
        toRoot() {
          return (
            this.isAbsolute &&
            1 === this.commands.length &&
            "/" == this.commands[0]
          );
        }
      }
      class pf {
        constructor(e, t, i) {
          (this.segmentGroup = e), (this.processChildren = t), (this.index = i);
        }
      }
      function RA(n, e, t) {
        if (
          (n || (n = new Lt([], {})),
          0 === n.segments.length && n.hasChildren())
        )
          return pu(n, e, t);
        const i = (function FW(n, e, t) {
            let i = 0,
              r = e;
            const s = { match: !1, pathIndex: 0, commandIndex: 0 };
            for (; r < n.segments.length; ) {
              if (i >= t.length) return s;
              const o = n.segments[r],
                a = t[i];
              if (fu(a)) break;
              const l = `${a}`,
                c = i < t.length - 1 ? t[i + 1] : null;
              if (r > 0 && void 0 === l) break;
              if (l && c && "object" == typeof c && void 0 === c.outlets) {
                if (!OA(l, c, o)) return s;
                i += 2;
              } else {
                if (!OA(l, {}, o)) return s;
                i++;
              }
              r++;
            }
            return { match: !0, pathIndex: r, commandIndex: i };
          })(n, e, t),
          r = t.slice(i.commandIndex);
        if (i.match && i.pathIndex < n.segments.length) {
          const s = new Lt(n.segments.slice(0, i.pathIndex), {});
          return (
            (s.children[nt] = new Lt(
              n.segments.slice(i.pathIndex),
              n.children,
            )),
            pu(s, 0, r)
          );
        }
        return i.match && 0 === r.length
          ? new Lt(n.segments, {})
          : i.match && !n.hasChildren()
          ? ny(n, e, t)
          : i.match
          ? pu(n, 0, r)
          : ny(n, e, t);
      }
      function pu(n, e, t) {
        if (0 === t.length) return new Lt(n.segments, {});
        {
          const i = (function LW(n) {
              return fu(n[0]) ? n[0].outlets : { [nt]: n };
            })(t),
            r = {};
          if (
            !i[nt] &&
            n.children[nt] &&
            1 === n.numberOfChildren &&
            0 === n.children[nt].segments.length
          ) {
            const s = pu(n.children[nt], e, t);
            return new Lt(n.segments, s.children);
          }
          return (
            Object.entries(i).forEach(([s, o]) => {
              "string" == typeof o && (o = [o]),
                null !== o && (r[s] = RA(n.children[s], e, o));
            }),
            Object.entries(n.children).forEach(([s, o]) => {
              void 0 === i[s] && (r[s] = o);
            }),
            new Lt(n.segments, r)
          );
        }
      }
      function ny(n, e, t) {
        const i = n.segments.slice(0, e);
        let r = 0;
        for (; r < t.length; ) {
          const s = t[r];
          if (fu(s)) {
            const l = kW(s.outlets);
            return new Lt(i, l);
          }
          if (0 === r && ff(t[0])) {
            i.push(new uu(n.segments[e].path, PA(t[0]))), r++;
            continue;
          }
          const o = fu(s) ? s.outlets[nt] : `${s}`,
            a = r < t.length - 1 ? t[r + 1] : null;
          o && a && ff(a)
            ? (i.push(new uu(o, PA(a))), (r += 2))
            : (i.push(new uu(o, {})), r++);
        }
        return new Lt(i, {});
      }
      function kW(n) {
        const e = {};
        return (
          Object.entries(n).forEach(([t, i]) => {
            "string" == typeof i && (i = [i]),
              null !== i && (e[t] = ny(new Lt([], {}), 0, i));
          }),
          e
        );
      }
      function PA(n) {
        const e = {};
        return Object.entries(n).forEach(([t, i]) => (e[t] = `${i}`)), e;
      }
      function OA(n, e, t) {
        return n == t.path && Pr(e, t.parameters);
      }
      const mu = "imperative";
      class Or {
        constructor(e, t) {
          (this.id = e), (this.url = t);
        }
      }
      class iy extends Or {
        constructor(e, t, i = "imperative", r = null) {
          super(e, t),
            (this.type = 0),
            (this.navigationTrigger = i),
            (this.restoredState = r);
        }
        toString() {
          return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
        }
      }
      class Ao extends Or {
        constructor(e, t, i) {
          super(e, t), (this.urlAfterRedirects = i), (this.type = 1);
        }
        toString() {
          return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
        }
      }
      class mf extends Or {
        constructor(e, t, i, r) {
          super(e, t), (this.reason = i), (this.code = r), (this.type = 2);
        }
        toString() {
          return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
        }
      }
      class gu extends Or {
        constructor(e, t, i, r) {
          super(e, t), (this.reason = i), (this.code = r), (this.type = 16);
        }
      }
      class ry extends Or {
        constructor(e, t, i, r) {
          super(e, t), (this.error = i), (this.target = r), (this.type = 3);
        }
        toString() {
          return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
        }
      }
      class UW extends Or {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 4);
        }
        toString() {
          return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class BW extends Or {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 7);
        }
        toString() {
          return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class VW extends Or {
        constructor(e, t, i, r, s) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.shouldActivate = s),
            (this.type = 8);
        }
        toString() {
          return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
        }
      }
      class HW extends Or {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 5);
        }
        toString() {
          return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class zW extends Or {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 6);
        }
        toString() {
          return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class GW {
        constructor(e) {
          (this.route = e), (this.type = 9);
        }
        toString() {
          return `RouteConfigLoadStart(path: ${this.route.path})`;
        }
      }
      class WW {
        constructor(e) {
          (this.route = e), (this.type = 10);
        }
        toString() {
          return `RouteConfigLoadEnd(path: ${this.route.path})`;
        }
      }
      class $W {
        constructor(e) {
          (this.snapshot = e), (this.type = 11);
        }
        toString() {
          return `ChildActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class jW {
        constructor(e) {
          (this.snapshot = e), (this.type = 12);
        }
        toString() {
          return `ChildActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class qW {
        constructor(e) {
          (this.snapshot = e), (this.type = 13);
        }
        toString() {
          return `ActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class XW {
        constructor(e) {
          (this.snapshot = e), (this.type = 14);
        }
        toString() {
          return `ActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class NA {
        constructor(e, t, i) {
          (this.routerEvent = e),
            (this.position = t),
            (this.anchor = i),
            (this.type = 15);
        }
        toString() {
          return `Scroll(anchor: '${this.anchor}', position: '${
            this.position ? `${this.position[0]}, ${this.position[1]}` : null
          }')`;
        }
      }
      class YW {
        constructor() {
          (this.outlet = null),
            (this.route = null),
            (this.injector = null),
            (this.children = new _u()),
            (this.attachRef = null);
        }
      }
      let _u = (() => {
        class n {
          constructor() {
            this.contexts = new Map();
          }
          onChildOutletCreated(t, i) {
            const r = this.getOrCreateContext(t);
            (r.outlet = i), this.contexts.set(t, r);
          }
          onChildOutletDestroyed(t) {
            const i = this.getContext(t);
            i && ((i.outlet = null), (i.attachRef = null));
          }
          onOutletDeactivated() {
            const t = this.contexts;
            return (this.contexts = new Map()), t;
          }
          onOutletReAttached(t) {
            this.contexts = t;
          }
          getOrCreateContext(t) {
            let i = this.getContext(t);
            return i || ((i = new YW()), this.contexts.set(t, i)), i;
          }
          getContext(t) {
            return this.contexts.get(t) || null;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      class LA {
        constructor(e) {
          this._root = e;
        }
        get root() {
          return this._root.value;
        }
        parent(e) {
          const t = this.pathFromRoot(e);
          return t.length > 1 ? t[t.length - 2] : null;
        }
        children(e) {
          const t = sy(e, this._root);
          return t ? t.children.map((i) => i.value) : [];
        }
        firstChild(e) {
          const t = sy(e, this._root);
          return t && t.children.length > 0 ? t.children[0].value : null;
        }
        siblings(e) {
          const t = oy(e, this._root);
          return t.length < 2
            ? []
            : t[t.length - 2].children
                .map((r) => r.value)
                .filter((r) => r !== e);
        }
        pathFromRoot(e) {
          return oy(e, this._root).map((t) => t.value);
        }
      }
      function sy(n, e) {
        if (n === e.value) return e;
        for (const t of e.children) {
          const i = sy(n, t);
          if (i) return i;
        }
        return null;
      }
      function oy(n, e) {
        if (n === e.value) return [e];
        for (const t of e.children) {
          const i = oy(n, t);
          if (i.length) return i.unshift(e), i;
        }
        return [];
      }
      class is {
        constructor(e, t) {
          (this.value = e), (this.children = t);
        }
        toString() {
          return `TreeNode(${this.value})`;
        }
      }
      function al(n) {
        const e = {};
        return n && n.children.forEach((t) => (e[t.value.outlet] = t)), e;
      }
      class FA extends LA {
        constructor(e, t) {
          super(e), (this.snapshot = t), ay(this, e);
        }
        toString() {
          return this.snapshot.toString();
        }
      }
      function kA(n, e) {
        const t = (function ZW(n, e) {
            const o = new gf([], {}, {}, "", {}, nt, e, null, {});
            return new BA("", new is(o, []));
          })(0, e),
          i = new Ui([new uu("", {})]),
          r = new Ui({}),
          s = new Ui({}),
          o = new Ui({}),
          a = new Ui(""),
          l = new ll(i, r, o, a, s, nt, e, t.root);
        return (l.snapshot = t.root), new FA(new is(l, []), t);
      }
      class ll {
        constructor(e, t, i, r, s, o, a, l) {
          (this.urlSubject = e),
            (this.paramsSubject = t),
            (this.queryParamsSubject = i),
            (this.fragmentSubject = r),
            (this.dataSubject = s),
            (this.outlet = o),
            (this.component = a),
            (this._futureSnapshot = l),
            (this.title =
              this.dataSubject?.pipe(Bt((c) => c[cu])) ?? We(void 0)),
            (this.url = e),
            (this.params = t),
            (this.queryParams = i),
            (this.fragment = r),
            (this.data = s);
        }
        get routeConfig() {
          return this._futureSnapshot.routeConfig;
        }
        get root() {
          return this._routerState.root;
        }
        get parent() {
          return this._routerState.parent(this);
        }
        get firstChild() {
          return this._routerState.firstChild(this);
        }
        get children() {
          return this._routerState.children(this);
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this);
        }
        get paramMap() {
          return (
            this._paramMap ||
              (this._paramMap = this.params.pipe(Bt((e) => sl(e)))),
            this._paramMap
          );
        }
        get queryParamMap() {
          return (
            this._queryParamMap ||
              (this._queryParamMap = this.queryParams.pipe(Bt((e) => sl(e)))),
            this._queryParamMap
          );
        }
        toString() {
          return this.snapshot
            ? this.snapshot.toString()
            : `Future(${this._futureSnapshot})`;
        }
      }
      function UA(n, e = "emptyOnly") {
        const t = n.pathFromRoot;
        let i = 0;
        if ("always" !== e)
          for (i = t.length - 1; i >= 1; ) {
            const r = t[i],
              s = t[i - 1];
            if (r.routeConfig && "" === r.routeConfig.path) i--;
            else {
              if (s.component) break;
              i--;
            }
          }
        return (function KW(n) {
          return n.reduce(
            (e, t) => ({
              params: { ...e.params, ...t.params },
              data: { ...e.data, ...t.data },
              resolve: {
                ...t.data,
                ...e.resolve,
                ...t.routeConfig?.data,
                ...t._resolvedData,
              },
            }),
            { params: {}, data: {}, resolve: {} },
          );
        })(t.slice(i));
      }
      class gf {
        get title() {
          return this.data?.[cu];
        }
        constructor(e, t, i, r, s, o, a, l, c) {
          (this.url = e),
            (this.params = t),
            (this.queryParams = i),
            (this.fragment = r),
            (this.data = s),
            (this.outlet = o),
            (this.component = a),
            (this.routeConfig = l),
            (this._resolve = c);
        }
        get root() {
          return this._routerState.root;
        }
        get parent() {
          return this._routerState.parent(this);
        }
        get firstChild() {
          return this._routerState.firstChild(this);
        }
        get children() {
          return this._routerState.children(this);
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this);
        }
        get paramMap() {
          return (
            this._paramMap || (this._paramMap = sl(this.params)), this._paramMap
          );
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = sl(this.queryParams)),
            this._queryParamMap
          );
        }
        toString() {
          return `Route(url:'${this.url
            .map((i) => i.toString())
            .join("/")}', path:'${
            this.routeConfig ? this.routeConfig.path : ""
          }')`;
        }
      }
      class BA extends LA {
        constructor(e, t) {
          super(t), (this.url = e), ay(this, t);
        }
        toString() {
          return VA(this._root);
        }
      }
      function ay(n, e) {
        (e.value._routerState = n), e.children.forEach((t) => ay(n, t));
      }
      function VA(n) {
        const e =
          n.children.length > 0 ? ` { ${n.children.map(VA).join(", ")} } ` : "";
        return `${n.value}${e}`;
      }
      function ly(n) {
        if (n.snapshot) {
          const e = n.snapshot,
            t = n._futureSnapshot;
          (n.snapshot = t),
            Pr(e.queryParams, t.queryParams) ||
              n.queryParamsSubject.next(t.queryParams),
            e.fragment !== t.fragment && n.fragmentSubject.next(t.fragment),
            Pr(e.params, t.params) || n.paramsSubject.next(t.params),
            (function hW(n, e) {
              if (n.length !== e.length) return !1;
              for (let t = 0; t < n.length; ++t) if (!Pr(n[t], e[t])) return !1;
              return !0;
            })(e.url, t.url) || n.urlSubject.next(t.url),
            Pr(e.data, t.data) || n.dataSubject.next(t.data);
        } else
          (n.snapshot = n._futureSnapshot),
            n.dataSubject.next(n._futureSnapshot.data);
      }
      function cy(n, e) {
        const t =
          Pr(n.params, e.params) &&
          (function gW(n, e) {
            return (
              To(n, e) && n.every((t, i) => Pr(t.parameters, e[i].parameters))
            );
          })(n.url, e.url);
        return (
          t &&
          !(!n.parent != !e.parent) &&
          (!n.parent || cy(n.parent, e.parent))
        );
      }
      let uy = (() => {
        class n {
          constructor() {
            (this.activated = null),
              (this._activatedRoute = null),
              (this.name = nt),
              (this.activateEvents = new Rt()),
              (this.deactivateEvents = new Rt()),
              (this.attachEvents = new Rt()),
              (this.detachEvents = new Rt()),
              (this.parentContexts = Te(_u)),
              (this.location = Te(ji)),
              (this.changeDetector = Te(tu)),
              (this.environmentInjector = Te(Xr)),
              (this.inputBinder = Te(_f, { optional: !0 })),
              (this.supportsBindingToComponentInputs = !0);
          }
          get activatedComponentRef() {
            return this.activated;
          }
          ngOnChanges(t) {
            if (t.name) {
              const { firstChange: i, previousValue: r } = t.name;
              if (i) return;
              this.isTrackedInParentContexts(r) &&
                (this.deactivate(),
                this.parentContexts.onChildOutletDestroyed(r)),
                this.initializeOutletWithName();
            }
          }
          ngOnDestroy() {
            this.isTrackedInParentContexts(this.name) &&
              this.parentContexts.onChildOutletDestroyed(this.name),
              this.inputBinder?.unsubscribeFromRouteData(this);
          }
          isTrackedInParentContexts(t) {
            return this.parentContexts.getContext(t)?.outlet === this;
          }
          ngOnInit() {
            this.initializeOutletWithName();
          }
          initializeOutletWithName() {
            if (
              (this.parentContexts.onChildOutletCreated(this.name, this),
              this.activated)
            )
              return;
            const t = this.parentContexts.getContext(this.name);
            t?.route &&
              (t.attachRef
                ? this.attach(t.attachRef, t.route)
                : this.activateWith(t.route, t.injector));
          }
          get isActivated() {
            return !!this.activated;
          }
          get component() {
            if (!this.activated) throw new Y(4012, !1);
            return this.activated.instance;
          }
          get activatedRoute() {
            if (!this.activated) throw new Y(4012, !1);
            return this._activatedRoute;
          }
          get activatedRouteData() {
            return this._activatedRoute
              ? this._activatedRoute.snapshot.data
              : {};
          }
          detach() {
            if (!this.activated) throw new Y(4012, !1);
            this.location.detach();
            const t = this.activated;
            return (
              (this.activated = null),
              (this._activatedRoute = null),
              this.detachEvents.emit(t.instance),
              t
            );
          }
          attach(t, i) {
            (this.activated = t),
              (this._activatedRoute = i),
              this.location.insert(t.hostView),
              this.inputBinder?.bindActivatedRouteToOutletComponent(this),
              this.attachEvents.emit(t.instance);
          }
          deactivate() {
            if (this.activated) {
              const t = this.component;
              this.activated.destroy(),
                (this.activated = null),
                (this._activatedRoute = null),
                this.deactivateEvents.emit(t);
            }
          }
          activateWith(t, i) {
            if (this.isActivated) throw new Y(4013, !1);
            this._activatedRoute = t;
            const r = this.location,
              o = t.snapshot.component,
              a = this.parentContexts.getOrCreateContext(this.name).children,
              l = new QW(t, a, r.injector);
            (this.activated = r.createComponent(o, {
              index: r.length,
              injector: l,
              environmentInjector: i ?? this.environmentInjector,
            })),
              this.changeDetector.markForCheck(),
              this.inputBinder?.bindActivatedRouteToOutletComponent(this),
              this.activateEvents.emit(this.activated.instance);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵdir = Ue({
            type: n,
            selectors: [["router-outlet"]],
            inputs: { name: "name" },
            outputs: {
              activateEvents: "activate",
              deactivateEvents: "deactivate",
              attachEvents: "attach",
              detachEvents: "detach",
            },
            exportAs: ["outlet"],
            standalone: !0,
            features: [zi],
          })),
          n
        );
      })();
      class QW {
        constructor(e, t, i) {
          (this.route = e), (this.childContexts = t), (this.parent = i);
        }
        get(e, t) {
          return e === ll
            ? this.route
            : e === _u
            ? this.childContexts
            : this.parent.get(e, t);
        }
      }
      const _f = new ve("");
      let HA = (() => {
        class n {
          constructor() {
            this.outletDataSubscriptions = new Map();
          }
          bindActivatedRouteToOutletComponent(t) {
            this.unsubscribeFromRouteData(t), this.subscribeToRouteData(t);
          }
          unsubscribeFromRouteData(t) {
            this.outletDataSubscriptions.get(t)?.unsubscribe(),
              this.outletDataSubscriptions.delete(t);
          }
          subscribeToRouteData(t) {
            const { activatedRoute: i } = t,
              r = qv([i.queryParams, i.params, i.data])
                .pipe(
                  nr(
                    ([s, o, a], l) => (
                      (a = { ...s, ...o, ...a }),
                      0 === l ? We(a) : Promise.resolve(a)
                    ),
                  ),
                )
                .subscribe((s) => {
                  if (
                    !t.isActivated ||
                    !t.activatedComponentRef ||
                    t.activatedRoute !== i ||
                    null === i.component
                  )
                    return void this.unsubscribeFromRouteData(t);
                  const o = (function SG(n) {
                    const e = Ct(n);
                    if (!e) return null;
                    const t = new Vc(e);
                    return {
                      get selector() {
                        return t.selector;
                      },
                      get type() {
                        return t.componentType;
                      },
                      get inputs() {
                        return t.inputs;
                      },
                      get outputs() {
                        return t.outputs;
                      },
                      get ngContentSelectors() {
                        return t.ngContentSelectors;
                      },
                      get isStandalone() {
                        return e.standalone;
                      },
                      get isSignal() {
                        return e.signals;
                      },
                    };
                  })(i.component);
                  if (o)
                    for (const { templateName: a } of o.inputs)
                      t.activatedComponentRef.setInput(a, s[a]);
                  else this.unsubscribeFromRouteData(t);
                });
            this.outletDataSubscriptions.set(t, r);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      function vu(n, e, t) {
        if (t && n.shouldReuseRoute(e.value, t.value.snapshot)) {
          const i = t.value;
          i._futureSnapshot = e.value;
          const r = (function e$(n, e, t) {
            return e.children.map((i) => {
              for (const r of t.children)
                if (n.shouldReuseRoute(i.value, r.value.snapshot))
                  return vu(n, i, r);
              return vu(n, i);
            });
          })(n, e, t);
          return new is(i, r);
        }
        {
          if (n.shouldAttach(e.value)) {
            const s = n.retrieve(e.value);
            if (null !== s) {
              const o = s.route;
              return (
                (o.value._futureSnapshot = e.value),
                (o.children = e.children.map((a) => vu(n, a))),
                o
              );
            }
          }
          const i = (function t$(n) {
              return new ll(
                new Ui(n.url),
                new Ui(n.params),
                new Ui(n.queryParams),
                new Ui(n.fragment),
                new Ui(n.data),
                n.outlet,
                n.component,
                n,
              );
            })(e.value),
            r = e.children.map((s) => vu(n, s));
          return new is(i, r);
        }
      }
      const dy = "ngNavigationCancelingError";
      function zA(n, e) {
        const { redirectTo: t, navigationBehaviorOptions: i } = Do(e)
            ? { redirectTo: e, navigationBehaviorOptions: void 0 }
            : e,
          r = GA(!1, 0, e);
        return (r.url = t), (r.navigationBehaviorOptions = i), r;
      }
      function GA(n, e, t) {
        const i = new Error("NavigationCancelingError: " + (n || ""));
        return (i[dy] = !0), (i.cancellationCode = e), t && (i.url = t), i;
      }
      function WA(n) {
        return $A(n) && Do(n.url);
      }
      function $A(n) {
        return n && n[dy];
      }
      let jA = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = Hi({
            type: n,
            selectors: [["ng-component"]],
            standalone: !0,
            features: [jx],
            decls: 1,
            vars: 0,
            template: function (t, i) {
              1 & t && xt(0, "router-outlet");
            },
            dependencies: [uy],
            encapsulation: 2,
          })),
          n
        );
      })();
      function hy(n) {
        const e = n.children && n.children.map(hy),
          t = e ? { ...n, children: e } : { ...n };
        return (
          !t.component &&
            !t.loadComponent &&
            (e || t.loadChildren) &&
            t.outlet &&
            t.outlet !== nt &&
            (t.component = jA),
          t
        );
      }
      function fr(n) {
        return n.outlet || nt;
      }
      function yu(n) {
        if (!n) return null;
        if (n.routeConfig?._injector) return n.routeConfig._injector;
        for (let e = n.parent; e; e = e.parent) {
          const t = e.routeConfig;
          if (t?._loadedInjector) return t._loadedInjector;
          if (t?._injector) return t._injector;
        }
        return null;
      }
      class l$ {
        constructor(e, t, i, r, s) {
          (this.routeReuseStrategy = e),
            (this.futureState = t),
            (this.currState = i),
            (this.forwardEvent = r),
            (this.inputBindingEnabled = s);
        }
        activate(e) {
          const t = this.futureState._root,
            i = this.currState ? this.currState._root : null;
          this.deactivateChildRoutes(t, i, e),
            ly(this.futureState.root),
            this.activateChildRoutes(t, i, e);
        }
        deactivateChildRoutes(e, t, i) {
          const r = al(t);
          e.children.forEach((s) => {
            const o = s.value.outlet;
            this.deactivateRoutes(s, r[o], i), delete r[o];
          }),
            Object.values(r).forEach((s) => {
              this.deactivateRouteAndItsChildren(s, i);
            });
        }
        deactivateRoutes(e, t, i) {
          const r = e.value,
            s = t ? t.value : null;
          if (r === s)
            if (r.component) {
              const o = i.getContext(r.outlet);
              o && this.deactivateChildRoutes(e, t, o.children);
            } else this.deactivateChildRoutes(e, t, i);
          else s && this.deactivateRouteAndItsChildren(t, i);
        }
        deactivateRouteAndItsChildren(e, t) {
          e.value.component &&
          this.routeReuseStrategy.shouldDetach(e.value.snapshot)
            ? this.detachAndStoreRouteSubtree(e, t)
            : this.deactivateRouteAndOutlet(e, t);
        }
        detachAndStoreRouteSubtree(e, t) {
          const i = t.getContext(e.value.outlet),
            r = i && e.value.component ? i.children : t,
            s = al(e);
          for (const o of Object.keys(s))
            this.deactivateRouteAndItsChildren(s[o], r);
          if (i && i.outlet) {
            const o = i.outlet.detach(),
              a = i.children.onOutletDeactivated();
            this.routeReuseStrategy.store(e.value.snapshot, {
              componentRef: o,
              route: e,
              contexts: a,
            });
          }
        }
        deactivateRouteAndOutlet(e, t) {
          const i = t.getContext(e.value.outlet),
            r = i && e.value.component ? i.children : t,
            s = al(e);
          for (const o of Object.keys(s))
            this.deactivateRouteAndItsChildren(s[o], r);
          i &&
            (i.outlet &&
              (i.outlet.deactivate(), i.children.onOutletDeactivated()),
            (i.attachRef = null),
            (i.route = null));
        }
        activateChildRoutes(e, t, i) {
          const r = al(t);
          e.children.forEach((s) => {
            this.activateRoutes(s, r[s.value.outlet], i),
              this.forwardEvent(new XW(s.value.snapshot));
          }),
            e.children.length && this.forwardEvent(new jW(e.value.snapshot));
        }
        activateRoutes(e, t, i) {
          const r = e.value,
            s = t ? t.value : null;
          if ((ly(r), r === s))
            if (r.component) {
              const o = i.getOrCreateContext(r.outlet);
              this.activateChildRoutes(e, t, o.children);
            } else this.activateChildRoutes(e, t, i);
          else if (r.component) {
            const o = i.getOrCreateContext(r.outlet);
            if (this.routeReuseStrategy.shouldAttach(r.snapshot)) {
              const a = this.routeReuseStrategy.retrieve(r.snapshot);
              this.routeReuseStrategy.store(r.snapshot, null),
                o.children.onOutletReAttached(a.contexts),
                (o.attachRef = a.componentRef),
                (o.route = a.route.value),
                o.outlet && o.outlet.attach(a.componentRef, a.route.value),
                ly(a.route.value),
                this.activateChildRoutes(e, null, o.children);
            } else {
              const a = yu(r.snapshot);
              (o.attachRef = null),
                (o.route = r),
                (o.injector = a),
                o.outlet && o.outlet.activateWith(r, o.injector),
                this.activateChildRoutes(e, null, o.children);
            }
          } else this.activateChildRoutes(e, null, i);
        }
      }
      class qA {
        constructor(e) {
          (this.path = e), (this.route = this.path[this.path.length - 1]);
        }
      }
      class vf {
        constructor(e, t) {
          (this.component = e), (this.route = t);
        }
      }
      function c$(n, e, t) {
        const i = n._root;
        return bu(i, e ? e._root : null, t, [i.value]);
      }
      function cl(n, e) {
        const t = Symbol(),
          i = e.get(n, t);
        return i === t
          ? "function" != typeof n ||
            (function rF(n) {
              return null !== bd(n);
            })(n)
            ? e.get(n)
            : n
          : i;
      }
      function bu(
        n,
        e,
        t,
        i,
        r = { canDeactivateChecks: [], canActivateChecks: [] },
      ) {
        const s = al(e);
        return (
          n.children.forEach((o) => {
            (function d$(
              n,
              e,
              t,
              i,
              r = { canDeactivateChecks: [], canActivateChecks: [] },
            ) {
              const s = n.value,
                o = e ? e.value : null,
                a = t ? t.getContext(n.value.outlet) : null;
              if (o && s.routeConfig === o.routeConfig) {
                const l = (function h$(n, e, t) {
                  if ("function" == typeof t) return t(n, e);
                  switch (t) {
                    case "pathParamsChange":
                      return !To(n.url, e.url);
                    case "pathParamsOrQueryParamsChange":
                      return (
                        !To(n.url, e.url) || !Pr(n.queryParams, e.queryParams)
                      );
                    case "always":
                      return !0;
                    case "paramsOrQueryParamsChange":
                      return !cy(n, e) || !Pr(n.queryParams, e.queryParams);
                    default:
                      return !cy(n, e);
                  }
                })(o, s, s.routeConfig.runGuardsAndResolvers);
                l
                  ? r.canActivateChecks.push(new qA(i))
                  : ((s.data = o.data), (s._resolvedData = o._resolvedData)),
                  bu(n, e, s.component ? (a ? a.children : null) : t, i, r),
                  l &&
                    a &&
                    a.outlet &&
                    a.outlet.isActivated &&
                    r.canDeactivateChecks.push(new vf(a.outlet.component, o));
              } else
                o && Mu(e, a, r),
                  r.canActivateChecks.push(new qA(i)),
                  bu(n, null, s.component ? (a ? a.children : null) : t, i, r);
            })(o, s[o.value.outlet], t, i.concat([o.value]), r),
              delete s[o.value.outlet];
          }),
          Object.entries(s).forEach(([o, a]) => Mu(a, t.getContext(o), r)),
          r
        );
      }
      function Mu(n, e, t) {
        const i = al(n),
          r = n.value;
        Object.entries(i).forEach(([s, o]) => {
          Mu(o, r.component ? (e ? e.children.getContext(s) : null) : e, t);
        }),
          t.canDeactivateChecks.push(
            new vf(
              r.component && e && e.outlet && e.outlet.isActivated
                ? e.outlet.component
                : null,
              r,
            ),
          );
      }
      function Su(n) {
        return "function" == typeof n;
      }
      function XA(n) {
        return n instanceof af || "EmptyError" === n?.name;
      }
      const yf = Symbol("INITIAL_VALUE");
      function ul() {
        return nr((n) =>
          qv(n.map((e) => e.pipe(xi(1), fA(yf)))).pipe(
            Bt((e) => {
              for (const t of e)
                if (!0 !== t) {
                  if (t === yf) return yf;
                  if (!1 === t || t instanceof ol) return t;
                }
              return !0;
            }),
            Yi((e) => e !== yf),
            xi(1),
          ),
        );
      }
      function YA(n) {
        return (function lL(...n) {
          return uM(n);
        })(
          Jn((e) => {
            if (Do(e)) throw zA(0, e);
          }),
          Bt((e) => !0 === e),
        );
      }
      class bf {
        constructor(e) {
          this.segmentGroup = e || null;
        }
      }
      class ZA {
        constructor(e) {
          this.urlTree = e;
        }
      }
      function dl(n) {
        return au(new bf(n));
      }
      function KA(n) {
        return au(new ZA(n));
      }
      class P$ {
        constructor(e, t) {
          (this.urlSerializer = e), (this.urlTree = t);
        }
        noMatchError(e) {
          return new Y(4002, !1);
        }
        lineralizeSegments(e, t) {
          let i = [],
            r = t.root;
          for (;;) {
            if (((i = i.concat(r.segments)), 0 === r.numberOfChildren))
              return We(i);
            if (r.numberOfChildren > 1 || !r.children[nt])
              return au(new Y(4e3, !1));
            r = r.children[nt];
          }
        }
        applyRedirectCommands(e, t, i) {
          return this.applyRedirectCreateUrlTree(
            t,
            this.urlSerializer.parse(t),
            e,
            i,
          );
        }
        applyRedirectCreateUrlTree(e, t, i, r) {
          const s = this.createSegmentGroup(e, t.root, i, r);
          return new ol(
            s,
            this.createQueryParams(t.queryParams, this.urlTree.queryParams),
            t.fragment,
          );
        }
        createQueryParams(e, t) {
          const i = {};
          return (
            Object.entries(e).forEach(([r, s]) => {
              if ("string" == typeof s && s.startsWith(":")) {
                const a = s.substring(1);
                i[r] = t[a];
              } else i[r] = s;
            }),
            i
          );
        }
        createSegmentGroup(e, t, i, r) {
          const s = this.createSegments(e, t.segments, i, r);
          let o = {};
          return (
            Object.entries(t.children).forEach(([a, l]) => {
              o[a] = this.createSegmentGroup(e, l, i, r);
            }),
            new Lt(s, o)
          );
        }
        createSegments(e, t, i, r) {
          return t.map((s) =>
            s.path.startsWith(":")
              ? this.findPosParam(e, s, r)
              : this.findOrReturn(s, i),
          );
        }
        findPosParam(e, t, i) {
          const r = i[t.path.substring(1)];
          if (!r) throw new Y(4001, !1);
          return r;
        }
        findOrReturn(e, t) {
          let i = 0;
          for (const r of t) {
            if (r.path === e.path) return t.splice(i), r;
            i++;
          }
          return e;
        }
      }
      const fy = {
        matched: !1,
        consumedSegments: [],
        remainingSegments: [],
        parameters: {},
        positionalParamSegments: {},
      };
      function O$(n, e, t, i, r) {
        const s = py(n, e, t);
        return s.matched
          ? ((i = (function n$(n, e) {
              return (
                n.providers &&
                  !n._injector &&
                  (n._injector = k_(n.providers, e, `Route: ${n.path}`)),
                n._injector ?? e
              );
            })(e, i)),
            (function A$(n, e, t, i) {
              const r = e.canMatch;
              return r && 0 !== r.length
                ? We(
                    r.map((o) => {
                      const a = cl(o, n);
                      return Ls(
                        (function v$(n) {
                          return n && Su(n.canMatch);
                        })(a)
                          ? a.canMatch(e, t)
                          : n.runInContext(() => a(e, t)),
                      );
                    }),
                  ).pipe(ul(), YA())
                : We(!0);
            })(i, e, t).pipe(Bt((o) => (!0 === o ? s : { ...fy }))))
          : We(s);
      }
      function py(n, e, t) {
        if ("" === e.path)
          return "full" === e.pathMatch && (n.hasChildren() || t.length > 0)
            ? { ...fy }
            : {
                matched: !0,
                consumedSegments: [],
                remainingSegments: t,
                parameters: {},
                positionalParamSegments: {},
              };
        const r = (e.matcher || dW)(t, n, e);
        if (!r) return { ...fy };
        const s = {};
        Object.entries(r.posParams ?? {}).forEach(([a, l]) => {
          s[a] = l.path;
        });
        const o =
          r.consumed.length > 0
            ? { ...s, ...r.consumed[r.consumed.length - 1].parameters }
            : s;
        return {
          matched: !0,
          consumedSegments: r.consumed,
          remainingSegments: t.slice(r.consumed.length),
          parameters: o,
          positionalParamSegments: r.posParams ?? {},
        };
      }
      function QA(n, e, t, i) {
        return t.length > 0 &&
          (function F$(n, e, t) {
            return t.some((i) => Mf(n, e, i) && fr(i) !== nt);
          })(n, t, i)
          ? {
              segmentGroup: new Lt(e, L$(i, new Lt(t, n.children))),
              slicedSegments: [],
            }
          : 0 === t.length &&
            (function k$(n, e, t) {
              return t.some((i) => Mf(n, e, i));
            })(n, t, i)
          ? {
              segmentGroup: new Lt(n.segments, N$(n, 0, t, i, n.children)),
              slicedSegments: t,
            }
          : { segmentGroup: new Lt(n.segments, n.children), slicedSegments: t };
      }
      function N$(n, e, t, i, r) {
        const s = {};
        for (const o of i)
          if (Mf(n, t, o) && !r[fr(o)]) {
            const a = new Lt([], {});
            s[fr(o)] = a;
          }
        return { ...r, ...s };
      }
      function L$(n, e) {
        const t = {};
        t[nt] = e;
        for (const i of n)
          if ("" === i.path && fr(i) !== nt) {
            const r = new Lt([], {});
            t[fr(i)] = r;
          }
        return t;
      }
      function Mf(n, e, t) {
        return (
          (!(n.hasChildren() || e.length > 0) || "full" !== t.pathMatch) &&
          "" === t.path
        );
      }
      class H$ {
        constructor(e, t, i, r, s, o, a) {
          (this.injector = e),
            (this.configLoader = t),
            (this.rootComponentType = i),
            (this.config = r),
            (this.urlTree = s),
            (this.paramsInheritanceStrategy = o),
            (this.urlSerializer = a),
            (this.allowRedirects = !0),
            (this.applyRedirects = new P$(this.urlSerializer, this.urlTree));
        }
        noMatchError(e) {
          return new Y(4002, !1);
        }
        recognize() {
          const e = QA(this.urlTree.root, [], [], this.config).segmentGroup;
          return this.processSegmentGroup(
            this.injector,
            this.config,
            e,
            nt,
          ).pipe(
            xo((t) => {
              if (t instanceof ZA)
                return (
                  (this.allowRedirects = !1),
                  (this.urlTree = t.urlTree),
                  this.match(t.urlTree)
                );
              throw t instanceof bf ? this.noMatchError(t) : t;
            }),
            Bt((t) => {
              const i = new gf(
                  [],
                  Object.freeze({}),
                  Object.freeze({ ...this.urlTree.queryParams }),
                  this.urlTree.fragment,
                  {},
                  nt,
                  this.rootComponentType,
                  null,
                  {},
                ),
                r = new is(i, t),
                s = new BA("", r),
                o = (function RW(n, e, t = null, i = null) {
                  return DA(TA(n), e, t, i);
                })(i, [], this.urlTree.queryParams, this.urlTree.fragment);
              return (
                (o.queryParams = this.urlTree.queryParams),
                (s.url = this.urlSerializer.serialize(o)),
                this.inheritParamsAndData(s._root),
                { state: s, tree: o }
              );
            }),
          );
        }
        match(e) {
          return this.processSegmentGroup(
            this.injector,
            this.config,
            e.root,
            nt,
          ).pipe(
            xo((i) => {
              throw i instanceof bf ? this.noMatchError(i) : i;
            }),
          );
        }
        inheritParamsAndData(e) {
          const t = e.value,
            i = UA(t, this.paramsInheritanceStrategy);
          (t.params = Object.freeze(i.params)),
            (t.data = Object.freeze(i.data)),
            e.children.forEach((r) => this.inheritParamsAndData(r));
        }
        processSegmentGroup(e, t, i, r) {
          return 0 === i.segments.length && i.hasChildren()
            ? this.processChildren(e, t, i)
            : this.processSegment(e, t, i, i.segments, r, !0);
        }
        processChildren(e, t, i) {
          const r = [];
          for (const s of Object.keys(i.children))
            "primary" === s ? r.unshift(s) : r.push(s);
          return Sn(r).pipe(
            lu((s) => {
              const o = i.children[s],
                a = (function o$(n, e) {
                  const t = n.filter((i) => fr(i) === e);
                  return t.push(...n.filter((i) => fr(i) !== e)), t;
                })(t, s);
              return this.processSegmentGroup(e, a, o, s);
            }),
            (function aW(n, e) {
              return fn(
                (function oW(n, e, t, i, r) {
                  return (s, o) => {
                    let a = t,
                      l = e,
                      c = 0;
                    s.subscribe(
                      tn(
                        o,
                        (u) => {
                          const d = c++;
                          (l = a ? n(l, u, d) : ((a = !0), u)), i && o.next(l);
                        },
                        r &&
                          (() => {
                            a && o.next(l), o.complete();
                          }),
                      ),
                    );
                  };
                })(n, e, arguments.length >= 2, !0),
              );
            })((s, o) => (s.push(...o), s)),
            lf(null),
            (function lW(n, e) {
              const t = arguments.length >= 2;
              return (i) =>
                i.pipe(
                  n ? Yi((r, s) => n(r, s, i)) : Ss,
                  Zv(1),
                  t ? lf(e) : pA(() => new af()),
                );
            })(),
            An((s) => {
              if (null === s) return dl(i);
              const o = JA(s);
              return (
                (function z$(n) {
                  n.sort((e, t) =>
                    e.value.outlet === nt
                      ? -1
                      : t.value.outlet === nt
                      ? 1
                      : e.value.outlet.localeCompare(t.value.outlet),
                  );
                })(o),
                We(o)
              );
            }),
          );
        }
        processSegment(e, t, i, r, s, o) {
          return Sn(t).pipe(
            lu((a) =>
              this.processSegmentAgainstRoute(
                a._injector ?? e,
                t,
                a,
                i,
                r,
                s,
                o,
              ).pipe(
                xo((l) => {
                  if (l instanceof bf) return We(null);
                  throw l;
                }),
              ),
            ),
            Co((a) => !!a),
            xo((a) => {
              if (XA(a))
                return (function B$(n, e, t) {
                  return 0 === e.length && !n.children[t];
                })(i, r, s)
                  ? We([])
                  : dl(i);
              throw a;
            }),
          );
        }
        processSegmentAgainstRoute(e, t, i, r, s, o, a) {
          return (function U$(n, e, t, i) {
            return (
              !!(fr(n) === i || (i !== nt && Mf(e, t, n))) &&
              ("**" === n.path || py(e, n, t).matched)
            );
          })(i, r, s, o)
            ? void 0 === i.redirectTo
              ? this.matchSegmentAgainstRoute(e, r, i, s, o, a)
              : a && this.allowRedirects
              ? this.expandSegmentAgainstRouteUsingRedirect(e, r, t, i, s, o)
              : dl(r)
            : dl(r);
        }
        expandSegmentAgainstRouteUsingRedirect(e, t, i, r, s, o) {
          return "**" === r.path
            ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(e, i, r, o)
            : this.expandRegularSegmentAgainstRouteUsingRedirect(
                e,
                t,
                i,
                r,
                s,
                o,
              );
        }
        expandWildCardWithParamsAgainstRouteUsingRedirect(e, t, i, r) {
          const s = this.applyRedirects.applyRedirectCommands(
            [],
            i.redirectTo,
            {},
          );
          return i.redirectTo.startsWith("/")
            ? KA(s)
            : this.applyRedirects.lineralizeSegments(i, s).pipe(
                An((o) => {
                  const a = new Lt(o, {});
                  return this.processSegment(e, t, a, o, r, !1);
                }),
              );
        }
        expandRegularSegmentAgainstRouteUsingRedirect(e, t, i, r, s, o) {
          const {
            matched: a,
            consumedSegments: l,
            remainingSegments: c,
            positionalParamSegments: u,
          } = py(t, r, s);
          if (!a) return dl(t);
          const d = this.applyRedirects.applyRedirectCommands(
            l,
            r.redirectTo,
            u,
          );
          return r.redirectTo.startsWith("/")
            ? KA(d)
            : this.applyRedirects
                .lineralizeSegments(r, d)
                .pipe(
                  An((h) => this.processSegment(e, i, t, h.concat(c), o, !1)),
                );
        }
        matchSegmentAgainstRoute(e, t, i, r, s, o) {
          let a;
          if ("**" === i.path) {
            const l = r.length > 0 ? gA(r).parameters : {};
            (a = We({
              snapshot: new gf(
                r,
                l,
                Object.freeze({ ...this.urlTree.queryParams }),
                this.urlTree.fragment,
                eI(i),
                fr(i),
                i.component ?? i._loadedComponent ?? null,
                i,
                tI(i),
              ),
              consumedSegments: [],
              remainingSegments: [],
            })),
              (t.children = {});
          } else
            a = O$(t, i, r, e).pipe(
              Bt(
                ({
                  matched: l,
                  consumedSegments: c,
                  remainingSegments: u,
                  parameters: d,
                }) =>
                  l
                    ? {
                        snapshot: new gf(
                          c,
                          d,
                          Object.freeze({ ...this.urlTree.queryParams }),
                          this.urlTree.fragment,
                          eI(i),
                          fr(i),
                          i.component ?? i._loadedComponent ?? null,
                          i,
                          tI(i),
                        ),
                        consumedSegments: c,
                        remainingSegments: u,
                      }
                    : null,
              ),
            );
          return a.pipe(
            nr((l) =>
              null === l
                ? dl(t)
                : this.getChildConfig((e = i._injector ?? e), i, r).pipe(
                    nr(({ routes: c }) => {
                      const u = i._loadedInjector ?? e,
                        {
                          snapshot: d,
                          consumedSegments: h,
                          remainingSegments: f,
                        } = l,
                        { segmentGroup: p, slicedSegments: _ } = QA(t, h, f, c);
                      if (0 === _.length && p.hasChildren())
                        return this.processChildren(u, c, p).pipe(
                          Bt((m) => (null === m ? null : [new is(d, m)])),
                        );
                      if (0 === c.length && 0 === _.length)
                        return We([new is(d, [])]);
                      const g = fr(i) === s;
                      return this.processSegment(
                        u,
                        c,
                        p,
                        _,
                        g ? nt : s,
                        !0,
                      ).pipe(Bt((m) => [new is(d, m)]));
                    }),
                  ),
            ),
          );
        }
        getChildConfig(e, t, i) {
          return t.children
            ? We({ routes: t.children, injector: e })
            : t.loadChildren
            ? void 0 !== t._loadedRoutes
              ? We({ routes: t._loadedRoutes, injector: t._loadedInjector })
              : (function D$(n, e, t, i) {
                  const r = e.canLoad;
                  return void 0 === r || 0 === r.length
                    ? We(!0)
                    : We(
                        r.map((o) => {
                          const a = cl(o, n);
                          return Ls(
                            (function p$(n) {
                              return n && Su(n.canLoad);
                            })(a)
                              ? a.canLoad(e, t)
                              : n.runInContext(() => a(e, t)),
                          );
                        }),
                      ).pipe(ul(), YA());
                })(e, t, i).pipe(
                  An((r) =>
                    r
                      ? this.configLoader.loadChildren(e, t).pipe(
                          Jn((s) => {
                            (t._loadedRoutes = s.routes),
                              (t._loadedInjector = s.injector);
                          }),
                        )
                      : (function R$(n) {
                          return au(GA(!1, 3));
                        })(),
                  ),
                )
            : We({ routes: [], injector: e });
        }
      }
      function G$(n) {
        const e = n.value.routeConfig;
        return e && "" === e.path;
      }
      function JA(n) {
        const e = [],
          t = new Set();
        for (const i of n) {
          if (!G$(i)) {
            e.push(i);
            continue;
          }
          const r = e.find((s) => i.value.routeConfig === s.value.routeConfig);
          void 0 !== r ? (r.children.push(...i.children), t.add(r)) : e.push(i);
        }
        for (const i of t) {
          const r = JA(i.children);
          e.push(new is(i.value, r));
        }
        return e.filter((i) => !t.has(i));
      }
      function eI(n) {
        return n.data || {};
      }
      function tI(n) {
        return n.resolve || {};
      }
      function nI(n) {
        return "string" == typeof n.title || null === n.title;
      }
      function my(n) {
        return nr((e) => {
          const t = n(e);
          return t ? Sn(t).pipe(Bt(() => e)) : We(e);
        });
      }
      const hl = new ve("ROUTES");
      let gy = (() => {
        class n {
          constructor() {
            (this.componentLoaders = new WeakMap()),
              (this.childrenLoaders = new WeakMap()),
              (this.compiler = Te(LT));
          }
          loadComponent(t) {
            if (this.componentLoaders.get(t))
              return this.componentLoaders.get(t);
            if (t._loadedComponent) return We(t._loadedComponent);
            this.onLoadStartListener && this.onLoadStartListener(t);
            const i = Ls(t.loadComponent()).pipe(
                Bt(iI),
                Jn((s) => {
                  this.onLoadEndListener && this.onLoadEndListener(t),
                    (t._loadedComponent = s);
                }),
                Kv(() => {
                  this.componentLoaders.delete(t);
                }),
              ),
              r = new hA(i, () => new en()).pipe(Yv());
            return this.componentLoaders.set(t, r), r;
          }
          loadChildren(t, i) {
            if (this.childrenLoaders.get(i)) return this.childrenLoaders.get(i);
            if (i._loadedRoutes)
              return We({
                routes: i._loadedRoutes,
                injector: i._loadedInjector,
              });
            this.onLoadStartListener && this.onLoadStartListener(i);
            const s = this.loadModuleFactoryOrRoutes(i.loadChildren).pipe(
                Bt((a) => {
                  this.onLoadEndListener && this.onLoadEndListener(i);
                  let l, c;
                  return (
                    Array.isArray(a)
                      ? (c = a)
                      : ((l = a.create(t).injector),
                        (c = l.get(hl, [], ct.Self | ct.Optional).flat())),
                    { routes: c.map(hy), injector: l }
                  );
                }),
                Kv(() => {
                  this.childrenLoaders.delete(i);
                }),
              ),
              o = new hA(s, () => new en()).pipe(Yv());
            return this.childrenLoaders.set(i, o), o;
          }
          loadModuleFactoryOrRoutes(t) {
            return Ls(t()).pipe(
              Bt(iI),
              An((i) =>
                i instanceof Wx || Array.isArray(i)
                  ? We(i)
                  : Sn(this.compiler.compileModuleAsync(i)),
              ),
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function iI(n) {
        return (function Z$(n) {
          return n && "object" == typeof n && "default" in n;
        })(n)
          ? n.default
          : n;
      }
      let Sf = (() => {
        class n {
          get hasRequestedNavigation() {
            return 0 !== this.navigationId;
          }
          constructor() {
            (this.currentNavigation = null),
              (this.lastSuccessfulNavigation = null),
              (this.events = new en()),
              (this.configLoader = Te(gy)),
              (this.environmentInjector = Te(Xr)),
              (this.urlSerializer = Te(du)),
              (this.rootContexts = Te(_u)),
              (this.inputBindingEnabled = null !== Te(_f, { optional: !0 })),
              (this.navigationId = 0),
              (this.afterPreactivation = () => We(void 0)),
              (this.rootComponentType = null),
              (this.configLoader.onLoadEndListener = (r) =>
                this.events.next(new WW(r))),
              (this.configLoader.onLoadStartListener = (r) =>
                this.events.next(new GW(r)));
          }
          complete() {
            this.transitions?.complete();
          }
          handleNavigationRequest(t) {
            const i = ++this.navigationId;
            this.transitions?.next({ ...this.transitions.value, ...t, id: i });
          }
          setupNavigations(t) {
            return (
              (this.transitions = new Ui({
                id: 0,
                currentUrlTree: t.currentUrlTree,
                currentRawUrl: t.currentUrlTree,
                extractedUrl: t.urlHandlingStrategy.extract(t.currentUrlTree),
                urlAfterRedirects: t.urlHandlingStrategy.extract(
                  t.currentUrlTree,
                ),
                rawUrl: t.currentUrlTree,
                extras: {},
                resolve: null,
                reject: null,
                promise: Promise.resolve(!0),
                source: mu,
                restoredState: null,
                currentSnapshot: t.routerState.snapshot,
                targetSnapshot: null,
                currentRouterState: t.routerState,
                targetRouterState: null,
                guards: { canActivateChecks: [], canDeactivateChecks: [] },
                guardsResult: null,
              })),
              this.transitions.pipe(
                Yi((i) => 0 !== i.id),
                Bt((i) => ({
                  ...i,
                  extractedUrl: t.urlHandlingStrategy.extract(i.rawUrl),
                })),
                nr((i) => {
                  let r = !1,
                    s = !1;
                  return We(i).pipe(
                    Jn((o) => {
                      this.currentNavigation = {
                        id: o.id,
                        initialUrl: o.rawUrl,
                        extractedUrl: o.extractedUrl,
                        trigger: o.source,
                        extras: o.extras,
                        previousNavigation: this.lastSuccessfulNavigation
                          ? {
                              ...this.lastSuccessfulNavigation,
                              previousNavigation: null,
                            }
                          : null,
                      };
                    }),
                    nr((o) => {
                      const a = t.browserUrlTree.toString(),
                        l =
                          !t.navigated ||
                          o.extractedUrl.toString() !== a ||
                          a !== t.currentUrlTree.toString();
                      if (
                        !l &&
                        "reload" !==
                          (o.extras.onSameUrlNavigation ??
                            t.onSameUrlNavigation)
                      ) {
                        const u = "";
                        return (
                          this.events.next(
                            new gu(o.id, t.serializeUrl(i.rawUrl), u, 0),
                          ),
                          (t.rawUrlTree = o.rawUrl),
                          o.resolve(null),
                          yr
                        );
                      }
                      if (t.urlHandlingStrategy.shouldProcessUrl(o.rawUrl))
                        return (
                          rI(o.source) && (t.browserUrlTree = o.extractedUrl),
                          We(o).pipe(
                            nr((u) => {
                              const d = this.transitions?.getValue();
                              return (
                                this.events.next(
                                  new iy(
                                    u.id,
                                    this.urlSerializer.serialize(
                                      u.extractedUrl,
                                    ),
                                    u.source,
                                    u.restoredState,
                                  ),
                                ),
                                d !== this.transitions?.getValue()
                                  ? yr
                                  : Promise.resolve(u)
                              );
                            }),
                            (function W$(n, e, t, i, r, s) {
                              return An((o) =>
                                (function V$(
                                  n,
                                  e,
                                  t,
                                  i,
                                  r,
                                  s,
                                  o = "emptyOnly",
                                ) {
                                  return new H$(
                                    n,
                                    e,
                                    t,
                                    i,
                                    r,
                                    o,
                                    s,
                                  ).recognize();
                                })(n, e, t, i, o.extractedUrl, r, s).pipe(
                                  Bt(({ state: a, tree: l }) => ({
                                    ...o,
                                    targetSnapshot: a,
                                    urlAfterRedirects: l,
                                  })),
                                ),
                              );
                            })(
                              this.environmentInjector,
                              this.configLoader,
                              this.rootComponentType,
                              t.config,
                              this.urlSerializer,
                              t.paramsInheritanceStrategy,
                            ),
                            Jn((u) => {
                              if (
                                ((i.targetSnapshot = u.targetSnapshot),
                                (i.urlAfterRedirects = u.urlAfterRedirects),
                                (this.currentNavigation = {
                                  ...this.currentNavigation,
                                  finalUrl: u.urlAfterRedirects,
                                }),
                                "eager" === t.urlUpdateStrategy)
                              ) {
                                if (!u.extras.skipLocationChange) {
                                  const h = t.urlHandlingStrategy.merge(
                                    u.urlAfterRedirects,
                                    u.rawUrl,
                                  );
                                  t.setBrowserUrl(h, u);
                                }
                                t.browserUrlTree = u.urlAfterRedirects;
                              }
                              const d = new UW(
                                u.id,
                                this.urlSerializer.serialize(u.extractedUrl),
                                this.urlSerializer.serialize(
                                  u.urlAfterRedirects,
                                ),
                                u.targetSnapshot,
                              );
                              this.events.next(d);
                            }),
                          )
                        );
                      if (
                        l &&
                        t.urlHandlingStrategy.shouldProcessUrl(t.rawUrlTree)
                      ) {
                        const {
                            id: u,
                            extractedUrl: d,
                            source: h,
                            restoredState: f,
                            extras: p,
                          } = o,
                          _ = new iy(u, this.urlSerializer.serialize(d), h, f);
                        this.events.next(_);
                        const g = kA(0, this.rootComponentType).snapshot;
                        return We(
                          (i = {
                            ...o,
                            targetSnapshot: g,
                            urlAfterRedirects: d,
                            extras: {
                              ...p,
                              skipLocationChange: !1,
                              replaceUrl: !1,
                            },
                          }),
                        );
                      }
                      {
                        const u = "";
                        return (
                          this.events.next(
                            new gu(o.id, t.serializeUrl(i.extractedUrl), u, 1),
                          ),
                          (t.rawUrlTree = o.rawUrl),
                          o.resolve(null),
                          yr
                        );
                      }
                    }),
                    Jn((o) => {
                      const a = new BW(
                        o.id,
                        this.urlSerializer.serialize(o.extractedUrl),
                        this.urlSerializer.serialize(o.urlAfterRedirects),
                        o.targetSnapshot,
                      );
                      this.events.next(a);
                    }),
                    Bt(
                      (o) =>
                        (i = {
                          ...o,
                          guards: c$(
                            o.targetSnapshot,
                            o.currentSnapshot,
                            this.rootContexts,
                          ),
                        }),
                    ),
                    (function b$(n, e) {
                      return An((t) => {
                        const {
                          targetSnapshot: i,
                          currentSnapshot: r,
                          guards: {
                            canActivateChecks: s,
                            canDeactivateChecks: o,
                          },
                        } = t;
                        return 0 === o.length && 0 === s.length
                          ? We({ ...t, guardsResult: !0 })
                          : (function M$(n, e, t, i) {
                              return Sn(n).pipe(
                                An((r) =>
                                  (function T$(n, e, t, i, r) {
                                    const s =
                                      e && e.routeConfig
                                        ? e.routeConfig.canDeactivate
                                        : null;
                                    return s && 0 !== s.length
                                      ? We(
                                          s.map((a) => {
                                            const l = yu(e) ?? r,
                                              c = cl(a, l);
                                            return Ls(
                                              (function _$(n) {
                                                return n && Su(n.canDeactivate);
                                              })(c)
                                                ? c.canDeactivate(n, e, t, i)
                                                : l.runInContext(() =>
                                                    c(n, e, t, i),
                                                  ),
                                            ).pipe(Co());
                                          }),
                                        ).pipe(ul())
                                      : We(!0);
                                  })(r.component, r.route, t, e, i),
                                ),
                                Co((r) => !0 !== r, !0),
                              );
                            })(o, i, r, n).pipe(
                              An((a) =>
                                a &&
                                (function f$(n) {
                                  return "boolean" == typeof n;
                                })(a)
                                  ? (function S$(n, e, t, i) {
                                      return Sn(e).pipe(
                                        lu((r) =>
                                          Xv(
                                            (function E$(n, e) {
                                              return (
                                                null !== n && e && e(new $W(n)),
                                                We(!0)
                                              );
                                            })(r.route.parent, i),
                                            (function w$(n, e) {
                                              return (
                                                null !== n && e && e(new qW(n)),
                                                We(!0)
                                              );
                                            })(r.route, i),
                                            (function x$(n, e, t) {
                                              const i = e[e.length - 1],
                                                s = e
                                                  .slice(0, e.length - 1)
                                                  .reverse()
                                                  .map((o) =>
                                                    (function u$(n) {
                                                      const e = n.routeConfig
                                                        ? n.routeConfig
                                                            .canActivateChild
                                                        : null;
                                                      return e && 0 !== e.length
                                                        ? { node: n, guards: e }
                                                        : null;
                                                    })(o),
                                                  )
                                                  .filter((o) => null !== o)
                                                  .map((o) =>
                                                    dA(() =>
                                                      We(
                                                        o.guards.map((l) => {
                                                          const c =
                                                              yu(o.node) ?? t,
                                                            u = cl(l, c);
                                                          return Ls(
                                                            (function g$(n) {
                                                              return (
                                                                n &&
                                                                Su(
                                                                  n.canActivateChild,
                                                                )
                                                              );
                                                            })(u)
                                                              ? u.canActivateChild(
                                                                  i,
                                                                  n,
                                                                )
                                                              : c.runInContext(
                                                                  () => u(i, n),
                                                                ),
                                                          ).pipe(Co());
                                                        }),
                                                      ).pipe(ul()),
                                                    ),
                                                  );
                                              return We(s).pipe(ul());
                                            })(n, r.path, t),
                                            (function C$(n, e, t) {
                                              const i = e.routeConfig
                                                ? e.routeConfig.canActivate
                                                : null;
                                              if (!i || 0 === i.length)
                                                return We(!0);
                                              const r = i.map((s) =>
                                                dA(() => {
                                                  const o = yu(e) ?? t,
                                                    a = cl(s, o);
                                                  return Ls(
                                                    (function m$(n) {
                                                      return (
                                                        n && Su(n.canActivate)
                                                      );
                                                    })(a)
                                                      ? a.canActivate(e, n)
                                                      : o.runInContext(() =>
                                                          a(e, n),
                                                        ),
                                                  ).pipe(Co());
                                                }),
                                              );
                                              return We(r).pipe(ul());
                                            })(n, r.route, t),
                                          ),
                                        ),
                                        Co((r) => !0 !== r, !0),
                                      );
                                    })(i, s, n, e)
                                  : We(a),
                              ),
                              Bt((a) => ({ ...t, guardsResult: a })),
                            );
                      });
                    })(this.environmentInjector, (o) => this.events.next(o)),
                    Jn((o) => {
                      if (
                        ((i.guardsResult = o.guardsResult), Do(o.guardsResult))
                      )
                        throw zA(0, o.guardsResult);
                      const a = new VW(
                        o.id,
                        this.urlSerializer.serialize(o.extractedUrl),
                        this.urlSerializer.serialize(o.urlAfterRedirects),
                        o.targetSnapshot,
                        !!o.guardsResult,
                      );
                      this.events.next(a);
                    }),
                    Yi(
                      (o) =>
                        !!o.guardsResult ||
                        (t.restoreHistory(o),
                        this.cancelNavigationTransition(o, "", 3),
                        !1),
                    ),
                    my((o) => {
                      if (o.guards.canActivateChecks.length)
                        return We(o).pipe(
                          Jn((a) => {
                            const l = new HW(
                              a.id,
                              this.urlSerializer.serialize(a.extractedUrl),
                              this.urlSerializer.serialize(a.urlAfterRedirects),
                              a.targetSnapshot,
                            );
                            this.events.next(l);
                          }),
                          nr((a) => {
                            let l = !1;
                            return We(a).pipe(
                              (function $$(n, e) {
                                return An((t) => {
                                  const {
                                    targetSnapshot: i,
                                    guards: { canActivateChecks: r },
                                  } = t;
                                  if (!r.length) return We(t);
                                  let s = 0;
                                  return Sn(r).pipe(
                                    lu((o) =>
                                      (function j$(n, e, t, i) {
                                        const r = n.routeConfig,
                                          s = n._resolve;
                                        return (
                                          void 0 !== r?.title &&
                                            !nI(r) &&
                                            (s[cu] = r.title),
                                          (function q$(n, e, t, i) {
                                            const r = (function X$(n) {
                                              return [
                                                ...Object.keys(n),
                                                ...Object.getOwnPropertySymbols(
                                                  n,
                                                ),
                                              ];
                                            })(n);
                                            if (0 === r.length) return We({});
                                            const s = {};
                                            return Sn(r).pipe(
                                              An((o) =>
                                                (function Y$(n, e, t, i) {
                                                  const r = yu(e) ?? i,
                                                    s = cl(n, r);
                                                  return Ls(
                                                    s.resolve
                                                      ? s.resolve(e, t)
                                                      : r.runInContext(() =>
                                                          s(e, t),
                                                        ),
                                                  );
                                                })(n[o], e, t, i).pipe(
                                                  Co(),
                                                  Jn((a) => {
                                                    s[o] = a;
                                                  }),
                                                ),
                                              ),
                                              Zv(1),
                                              (function cW(n) {
                                                return Bt(() => n);
                                              })(s),
                                              xo((o) => (XA(o) ? yr : au(o))),
                                            );
                                          })(s, n, e, i).pipe(
                                            Bt(
                                              (o) => (
                                                (n._resolvedData = o),
                                                (n.data = UA(n, t).resolve),
                                                r &&
                                                  nI(r) &&
                                                  (n.data[cu] = r.title),
                                                null
                                              ),
                                            ),
                                          )
                                        );
                                      })(o.route, i, n, e),
                                    ),
                                    Jn(() => s++),
                                    Zv(1),
                                    An((o) => (s === r.length ? We(t) : yr)),
                                  );
                                });
                              })(
                                t.paramsInheritanceStrategy,
                                this.environmentInjector,
                              ),
                              Jn({
                                next: () => (l = !0),
                                complete: () => {
                                  l ||
                                    (t.restoreHistory(a),
                                    this.cancelNavigationTransition(a, "", 2));
                                },
                              }),
                            );
                          }),
                          Jn((a) => {
                            const l = new zW(
                              a.id,
                              this.urlSerializer.serialize(a.extractedUrl),
                              this.urlSerializer.serialize(a.urlAfterRedirects),
                              a.targetSnapshot,
                            );
                            this.events.next(l);
                          }),
                        );
                    }),
                    my((o) => {
                      const a = (l) => {
                        const c = [];
                        l.routeConfig?.loadComponent &&
                          !l.routeConfig._loadedComponent &&
                          c.push(
                            this.configLoader.loadComponent(l.routeConfig).pipe(
                              Jn((u) => {
                                l.component = u;
                              }),
                              Bt(() => {}),
                            ),
                          );
                        for (const u of l.children) c.push(...a(u));
                        return c;
                      };
                      return qv(a(o.targetSnapshot.root)).pipe(lf(), xi(1));
                    }),
                    my(() => this.afterPreactivation()),
                    Bt((o) => {
                      const a = (function JW(n, e, t) {
                        const i = vu(n, e._root, t ? t._root : void 0);
                        return new FA(i, e);
                      })(
                        t.routeReuseStrategy,
                        o.targetSnapshot,
                        o.currentRouterState,
                      );
                      return (i = { ...o, targetRouterState: a });
                    }),
                    Jn((o) => {
                      (t.currentUrlTree = o.urlAfterRedirects),
                        (t.rawUrlTree = t.urlHandlingStrategy.merge(
                          o.urlAfterRedirects,
                          o.rawUrl,
                        )),
                        (t.routerState = o.targetRouterState),
                        "deferred" === t.urlUpdateStrategy &&
                          (o.extras.skipLocationChange ||
                            t.setBrowserUrl(t.rawUrlTree, o),
                          (t.browserUrlTree = o.urlAfterRedirects));
                    }),
                    ((n, e, t, i) =>
                      Bt(
                        (r) => (
                          new l$(
                            e,
                            r.targetRouterState,
                            r.currentRouterState,
                            t,
                            i,
                          ).activate(n),
                          r
                        ),
                      ))(
                      this.rootContexts,
                      t.routeReuseStrategy,
                      (o) => this.events.next(o),
                      this.inputBindingEnabled,
                    ),
                    xi(1),
                    Jn({
                      next: (o) => {
                        (r = !0),
                          (this.lastSuccessfulNavigation =
                            this.currentNavigation),
                          (t.navigated = !0),
                          this.events.next(
                            new Ao(
                              o.id,
                              this.urlSerializer.serialize(o.extractedUrl),
                              this.urlSerializer.serialize(t.currentUrlTree),
                            ),
                          ),
                          t.titleStrategy?.updateTitle(
                            o.targetRouterState.snapshot,
                          ),
                          o.resolve(!0);
                      },
                      complete: () => {
                        r = !0;
                      },
                    }),
                    Kv(() => {
                      r || s || this.cancelNavigationTransition(i, "", 1),
                        this.currentNavigation?.id === i.id &&
                          (this.currentNavigation = null);
                    }),
                    xo((o) => {
                      if (((s = !0), $A(o))) {
                        WA(o) || ((t.navigated = !0), t.restoreHistory(i, !0));
                        const a = new mf(
                          i.id,
                          this.urlSerializer.serialize(i.extractedUrl),
                          o.message,
                          o.cancellationCode,
                        );
                        if ((this.events.next(a), WA(o))) {
                          const l = t.urlHandlingStrategy.merge(
                              o.url,
                              t.rawUrlTree,
                            ),
                            c = {
                              skipLocationChange: i.extras.skipLocationChange,
                              replaceUrl:
                                "eager" === t.urlUpdateStrategy || rI(i.source),
                            };
                          t.scheduleNavigation(l, mu, null, c, {
                            resolve: i.resolve,
                            reject: i.reject,
                            promise: i.promise,
                          });
                        } else i.resolve(!1);
                      } else {
                        t.restoreHistory(i, !0);
                        const a = new ry(
                          i.id,
                          this.urlSerializer.serialize(i.extractedUrl),
                          o,
                          i.targetSnapshot ?? void 0,
                        );
                        this.events.next(a);
                        try {
                          i.resolve(t.errorHandler(o));
                        } catch (l) {
                          i.reject(l);
                        }
                      }
                      return yr;
                    }),
                  );
                }),
              )
            );
          }
          cancelNavigationTransition(t, i, r) {
            const s = new mf(
              t.id,
              this.urlSerializer.serialize(t.extractedUrl),
              i,
              r,
            );
            this.events.next(s), t.resolve(!1);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function rI(n) {
        return n !== mu;
      }
      let sI = (() => {
          class n {
            buildTitle(t) {
              let i,
                r = t.root;
              for (; void 0 !== r; )
                (i = this.getResolvedTitleForRoute(r) ?? i),
                  (r = r.children.find((s) => s.outlet === nt));
              return i;
            }
            getResolvedTitleForRoute(t) {
              return t.data[cu];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({
              token: n,
              factory: function () {
                return Te(K$);
              },
              providedIn: "root",
            })),
            n
          );
        })(),
        K$ = (() => {
          class n extends sI {
            constructor(t) {
              super(), (this.title = t);
            }
            updateTitle(t) {
              const i = this.buildTitle(t);
              void 0 !== i && this.title.setTitle(i);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(rA));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        Q$ = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({
              token: n,
              factory: function () {
                return Te(ej);
              },
              providedIn: "root",
            })),
            n
          );
        })();
      class J$ {
        shouldDetach(e) {
          return !1;
        }
        store(e, t) {}
        shouldAttach(e) {
          return !1;
        }
        retrieve(e) {
          return null;
        }
        shouldReuseRoute(e, t) {
          return e.routeConfig === t.routeConfig;
        }
      }
      let ej = (() => {
        class n extends J$ {}
        return (
          (n.ɵfac = (function () {
            let e;
            return function (i) {
              return (
                e ||
                (e = (function Ln(n) {
                  return zr(() => {
                    const e = n.prototype.constructor,
                      t = e[Gr] || cg(e),
                      i = Object.prototype;
                    let r = Object.getPrototypeOf(n.prototype).constructor;
                    for (; r && r !== i; ) {
                      const s = r[Gr] || cg(r);
                      if (s && s !== t) return s;
                      r = Object.getPrototypeOf(r);
                    }
                    return (s) => new s();
                  });
                })(n))
              )(i || n);
            };
          })()),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const wf = new ve("", { providedIn: "root", factory: () => ({}) });
      let tj = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({
              token: n,
              factory: function () {
                return Te(nj);
              },
              providedIn: "root",
            })),
            n
          );
        })(),
        nj = (() => {
          class n {
            shouldProcessUrl(t) {
              return !0;
            }
            extract(t) {
              return t;
            }
            merge(t, i) {
              return t;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      var wu = (function (n) {
        return (
          (n[(n.COMPLETE = 0)] = "COMPLETE"),
          (n[(n.FAILED = 1)] = "FAILED"),
          (n[(n.REDIRECTING = 2)] = "REDIRECTING"),
          n
        );
      })(wu || {});
      function oI(n, e) {
        n.events
          .pipe(
            Yi(
              (t) =>
                t instanceof Ao ||
                t instanceof mf ||
                t instanceof ry ||
                t instanceof gu,
            ),
            Bt((t) =>
              t instanceof Ao || t instanceof gu
                ? wu.COMPLETE
                : t instanceof mf && (0 === t.code || 1 === t.code)
                ? wu.REDIRECTING
                : wu.FAILED,
            ),
            Yi((t) => t !== wu.REDIRECTING),
            xi(1),
          )
          .subscribe(() => {
            e();
          });
      }
      function ij(n) {
        throw n;
      }
      function rj(n, e, t) {
        return e.parse("/");
      }
      const sj = {
          paths: "exact",
          fragment: "ignored",
          matrixParams: "ignored",
          queryParams: "exact",
        },
        oj = {
          paths: "subset",
          fragment: "ignored",
          matrixParams: "ignored",
          queryParams: "subset",
        };
      let Zi = (() => {
        class n {
          get navigationId() {
            return this.navigationTransitions.navigationId;
          }
          get browserPageId() {
            if ("computed" === this.canceledNavigationResolution)
              return this.location.getState()?.ɵrouterPageId;
          }
          get events() {
            return this.navigationTransitions.events;
          }
          constructor() {
            (this.disposed = !1),
              (this.currentPageId = 0),
              (this.console = Te(OT)),
              (this.isNgZoneEnabled = !1),
              (this.options = Te(wf, { optional: !0 }) || {}),
              (this.pendingTasks = Te(NT)),
              (this.errorHandler = this.options.errorHandler || ij),
              (this.malformedUriErrorHandler =
                this.options.malformedUriErrorHandler || rj),
              (this.navigated = !1),
              (this.lastSuccessfulId = -1),
              (this.urlHandlingStrategy = Te(tj)),
              (this.routeReuseStrategy = Te(Q$)),
              (this.titleStrategy = Te(sI)),
              (this.onSameUrlNavigation =
                this.options.onSameUrlNavigation || "ignore"),
              (this.paramsInheritanceStrategy =
                this.options.paramsInheritanceStrategy || "emptyOnly"),
              (this.urlUpdateStrategy =
                this.options.urlUpdateStrategy || "deferred"),
              (this.canceledNavigationResolution =
                this.options.canceledNavigationResolution || "replace"),
              (this.config = Te(hl, { optional: !0 })?.flat() ?? []),
              (this.navigationTransitions = Te(Sf)),
              (this.urlSerializer = Te(du)),
              (this.location = Te($h)),
              (this.componentInputBindingEnabled = !!Te(_f, { optional: !0 })),
              (this.isNgZoneEnabled =
                Te(yt) instanceof yt && yt.isInAngularZone()),
              this.resetConfig(this.config),
              (this.currentUrlTree = new ol()),
              (this.rawUrlTree = this.currentUrlTree),
              (this.browserUrlTree = this.currentUrlTree),
              (this.routerState = kA(0, null)),
              this.navigationTransitions.setupNavigations(this).subscribe(
                (t) => {
                  (this.lastSuccessfulId = t.id),
                    (this.currentPageId = this.browserPageId ?? 0);
                },
                (t) => {
                  this.console.warn(`Unhandled Navigation Error: ${t}`);
                },
              );
          }
          resetRootComponentType(t) {
            (this.routerState.root.component = t),
              (this.navigationTransitions.rootComponentType = t);
          }
          initialNavigation() {
            if (
              (this.setUpLocationChangeListener(),
              !this.navigationTransitions.hasRequestedNavigation)
            ) {
              const t = this.location.getState();
              this.navigateToSyncWithBrowser(this.location.path(!0), mu, t);
            }
          }
          setUpLocationChangeListener() {
            this.locationSubscription ||
              (this.locationSubscription = this.location.subscribe((t) => {
                const i = "popstate" === t.type ? "popstate" : "hashchange";
                "popstate" === i &&
                  setTimeout(() => {
                    this.navigateToSyncWithBrowser(t.url, i, t.state);
                  }, 0);
              }));
          }
          navigateToSyncWithBrowser(t, i, r) {
            const s = { replaceUrl: !0 },
              o = r?.navigationId ? r : null;
            if (r) {
              const l = { ...r };
              delete l.navigationId,
                delete l.ɵrouterPageId,
                0 !== Object.keys(l).length && (s.state = l);
            }
            const a = this.parseUrl(t);
            this.scheduleNavigation(a, i, o, s);
          }
          get url() {
            return this.serializeUrl(this.currentUrlTree);
          }
          getCurrentNavigation() {
            return this.navigationTransitions.currentNavigation;
          }
          get lastSuccessfulNavigation() {
            return this.navigationTransitions.lastSuccessfulNavigation;
          }
          resetConfig(t) {
            (this.config = t.map(hy)),
              (this.navigated = !1),
              (this.lastSuccessfulId = -1);
          }
          ngOnDestroy() {
            this.dispose();
          }
          dispose() {
            this.navigationTransitions.complete(),
              this.locationSubscription &&
                (this.locationSubscription.unsubscribe(),
                (this.locationSubscription = void 0)),
              (this.disposed = !0);
          }
          createUrlTree(t, i = {}) {
            const {
                relativeTo: r,
                queryParams: s,
                fragment: o,
                queryParamsHandling: a,
                preserveFragment: l,
              } = i,
              c = l ? this.currentUrlTree.fragment : o;
            let d,
              u = null;
            switch (a) {
              case "merge":
                u = { ...this.currentUrlTree.queryParams, ...s };
                break;
              case "preserve":
                u = this.currentUrlTree.queryParams;
                break;
              default:
                u = s || null;
            }
            null !== u && (u = this.removeEmptyProps(u));
            try {
              d = TA(r ? r.snapshot : this.routerState.snapshot.root);
            } catch {
              ("string" != typeof t[0] || !t[0].startsWith("/")) && (t = []),
                (d = this.currentUrlTree.root);
            }
            return DA(d, t, u, c ?? null);
          }
          navigateByUrl(t, i = { skipLocationChange: !1 }) {
            const r = Do(t) ? t : this.parseUrl(t),
              s = this.urlHandlingStrategy.merge(r, this.rawUrlTree);
            return this.scheduleNavigation(s, mu, null, i);
          }
          navigate(t, i = { skipLocationChange: !1 }) {
            return (
              (function aj(n) {
                for (let e = 0; e < n.length; e++)
                  if (null == n[e]) throw new Y(4008, !1);
              })(t),
              this.navigateByUrl(this.createUrlTree(t, i), i)
            );
          }
          serializeUrl(t) {
            return this.urlSerializer.serialize(t);
          }
          parseUrl(t) {
            let i;
            try {
              i = this.urlSerializer.parse(t);
            } catch (r) {
              i = this.malformedUriErrorHandler(r, this.urlSerializer, t);
            }
            return i;
          }
          isActive(t, i) {
            let r;
            if (((r = !0 === i ? { ...sj } : !1 === i ? { ...oj } : i), Do(t)))
              return vA(this.currentUrlTree, t, r);
            const s = this.parseUrl(t);
            return vA(this.currentUrlTree, s, r);
          }
          removeEmptyProps(t) {
            return Object.keys(t).reduce((i, r) => {
              const s = t[r];
              return null != s && (i[r] = s), i;
            }, {});
          }
          scheduleNavigation(t, i, r, s, o) {
            if (this.disposed) return Promise.resolve(!1);
            let a, l, c;
            o
              ? ((a = o.resolve), (l = o.reject), (c = o.promise))
              : (c = new Promise((d, h) => {
                  (a = d), (l = h);
                }));
            const u = this.pendingTasks.add();
            return (
              oI(this, () => {
                queueMicrotask(() => this.pendingTasks.remove(u));
              }),
              this.navigationTransitions.handleNavigationRequest({
                source: i,
                restoredState: r,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.currentUrlTree,
                rawUrl: t,
                extras: s,
                resolve: a,
                reject: l,
                promise: c,
                currentSnapshot: this.routerState.snapshot,
                currentRouterState: this.routerState,
              }),
              c.catch((d) => Promise.reject(d))
            );
          }
          setBrowserUrl(t, i) {
            const r = this.urlSerializer.serialize(t);
            if (this.location.isCurrentPathEqualTo(r) || i.extras.replaceUrl) {
              const o = {
                ...i.extras.state,
                ...this.generateNgRouterState(i.id, this.browserPageId),
              };
              this.location.replaceState(r, "", o);
            } else {
              const s = {
                ...i.extras.state,
                ...this.generateNgRouterState(
                  i.id,
                  (this.browserPageId ?? 0) + 1,
                ),
              };
              this.location.go(r, "", s);
            }
          }
          restoreHistory(t, i = !1) {
            if ("computed" === this.canceledNavigationResolution) {
              const s =
                this.currentPageId - (this.browserPageId ?? this.currentPageId);
              0 !== s
                ? this.location.historyGo(s)
                : this.currentUrlTree ===
                    this.getCurrentNavigation()?.finalUrl &&
                  0 === s &&
                  (this.resetState(t),
                  (this.browserUrlTree = t.currentUrlTree),
                  this.resetUrlToCurrentUrlTree());
            } else
              "replace" === this.canceledNavigationResolution &&
                (i && this.resetState(t), this.resetUrlToCurrentUrlTree());
          }
          resetState(t) {
            (this.routerState = t.currentRouterState),
              (this.currentUrlTree = t.currentUrlTree),
              (this.rawUrlTree = this.urlHandlingStrategy.merge(
                this.currentUrlTree,
                t.rawUrl,
              ));
          }
          resetUrlToCurrentUrlTree() {
            this.location.replaceState(
              this.urlSerializer.serialize(this.rawUrlTree),
              "",
              this.generateNgRouterState(
                this.lastSuccessfulId,
                this.currentPageId,
              ),
            );
          }
          generateNgRouterState(t, i) {
            return "computed" === this.canceledNavigationResolution
              ? { navigationId: t, ɵrouterPageId: i }
              : { navigationId: t };
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      class aI {}
      let uj = (() => {
        class n {
          constructor(t, i, r, s, o) {
            (this.router = t),
              (this.injector = r),
              (this.preloadingStrategy = s),
              (this.loader = o);
          }
          setUpPreloading() {
            this.subscription = this.router.events
              .pipe(
                Yi((t) => t instanceof Ao),
                lu(() => this.preload()),
              )
              .subscribe(() => {});
          }
          preload() {
            return this.processRoutes(this.injector, this.router.config);
          }
          ngOnDestroy() {
            this.subscription && this.subscription.unsubscribe();
          }
          processRoutes(t, i) {
            const r = [];
            for (const s of i) {
              s.providers &&
                !s._injector &&
                (s._injector = k_(s.providers, t, `Route: ${s.path}`));
              const o = s._injector ?? t,
                a = s._loadedInjector ?? o;
              ((s.loadChildren && !s._loadedRoutes && void 0 === s.canLoad) ||
                (s.loadComponent && !s._loadedComponent)) &&
                r.push(this.preloadConfig(o, s)),
                (s.children || s._loadedRoutes) &&
                  r.push(this.processRoutes(a, s.children ?? s._loadedRoutes));
            }
            return Sn(r).pipe(da());
          }
          preloadConfig(t, i) {
            return this.preloadingStrategy.preload(i, () => {
              let r;
              r =
                i.loadChildren && void 0 === i.canLoad
                  ? this.loader.loadChildren(t, i)
                  : We(null);
              const s = r.pipe(
                An((o) =>
                  null === o
                    ? We(void 0)
                    : ((i._loadedRoutes = o.routes),
                      (i._loadedInjector = o.injector),
                      this.processRoutes(o.injector ?? t, o.routes)),
                ),
              );
              return i.loadComponent && !i._loadedComponent
                ? Sn([s, this.loader.loadComponent(i)]).pipe(da())
                : s;
            });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se(Zi), se(LT), se(Xr), se(aI), se(gy));
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const vy = new ve("");
      let lI = (() => {
        class n {
          constructor(t, i, r, s, o = {}) {
            (this.urlSerializer = t),
              (this.transitions = i),
              (this.viewportScroller = r),
              (this.zone = s),
              (this.options = o),
              (this.lastId = 0),
              (this.lastSource = "imperative"),
              (this.restoredId = 0),
              (this.store = {}),
              (o.scrollPositionRestoration =
                o.scrollPositionRestoration || "disabled"),
              (o.anchorScrolling = o.anchorScrolling || "disabled");
          }
          init() {
            "disabled" !== this.options.scrollPositionRestoration &&
              this.viewportScroller.setHistoryScrollRestoration("manual"),
              (this.routerEventsSubscription = this.createScrollEvents()),
              (this.scrollEventsSubscription = this.consumeScrollEvents());
          }
          createScrollEvents() {
            return this.transitions.events.subscribe((t) => {
              t instanceof iy
                ? ((this.store[this.lastId] =
                    this.viewportScroller.getScrollPosition()),
                  (this.lastSource = t.navigationTrigger),
                  (this.restoredId = t.restoredState
                    ? t.restoredState.navigationId
                    : 0))
                : t instanceof Ao
                ? ((this.lastId = t.id),
                  this.scheduleScrollEvent(
                    t,
                    this.urlSerializer.parse(t.urlAfterRedirects).fragment,
                  ))
                : t instanceof gu &&
                  0 === t.code &&
                  ((this.lastSource = void 0),
                  (this.restoredId = 0),
                  this.scheduleScrollEvent(
                    t,
                    this.urlSerializer.parse(t.url).fragment,
                  ));
            });
          }
          consumeScrollEvents() {
            return this.transitions.events.subscribe((t) => {
              t instanceof NA &&
                (t.position
                  ? "top" === this.options.scrollPositionRestoration
                    ? this.viewportScroller.scrollToPosition([0, 0])
                    : "enabled" === this.options.scrollPositionRestoration &&
                      this.viewportScroller.scrollToPosition(t.position)
                  : t.anchor && "enabled" === this.options.anchorScrolling
                  ? this.viewportScroller.scrollToAnchor(t.anchor)
                  : "disabled" !== this.options.scrollPositionRestoration &&
                    this.viewportScroller.scrollToPosition([0, 0]));
            });
          }
          scheduleScrollEvent(t, i) {
            this.zone.runOutsideAngular(() => {
              setTimeout(() => {
                this.zone.run(() => {
                  this.transitions.events.next(
                    new NA(
                      t,
                      "popstate" === this.lastSource
                        ? this.store[this.restoredId]
                        : null,
                      i,
                    ),
                  );
                });
              }, 0);
            });
          }
          ngOnDestroy() {
            this.routerEventsSubscription?.unsubscribe(),
              this.scrollEventsSubscription?.unsubscribe();
          }
        }
        return (
          (n.ɵfac = function (t) {
            !(function RE() {
              throw new Error("invalid");
            })();
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      function rs(n, e) {
        return { ɵkind: n, ɵproviders: e };
      }
      function uI() {
        const n = Te(fi);
        return (e) => {
          const t = n.get(Ps);
          if (e !== t.components[0]) return;
          const i = n.get(Zi),
            r = n.get(dI);
          1 === n.get(yy) && i.initialNavigation(),
            n.get(hI, null, ct.Optional)?.setUpPreloading(),
            n.get(vy, null, ct.Optional)?.init(),
            i.resetRootComponentType(t.componentTypes[0]),
            r.closed || (r.next(), r.complete(), r.unsubscribe());
        };
      }
      const dI = new ve("", { factory: () => new en() }),
        yy = new ve("", { providedIn: "root", factory: () => 1 }),
        hI = new ve("");
      function pj(n) {
        return rs(0, [
          { provide: hI, useExisting: uj },
          { provide: aI, useExisting: n },
        ]);
      }
      const fI = new ve("ROUTER_FORROOT_GUARD"),
        gj = [
          $h,
          { provide: du, useClass: Qv },
          Zi,
          _u,
          {
            provide: ll,
            useFactory: function cI(n) {
              return n.routerState.root;
            },
            deps: [Zi],
          },
          gy,
          [],
        ];
      function _j() {
        return new jT("Router", Zi);
      }
      let pI = (() => {
        class n {
          constructor(t) {}
          static forRoot(t, i) {
            return {
              ngModule: n,
              providers: [
                gj,
                [],
                { provide: hl, multi: !0, useValue: t },
                {
                  provide: fI,
                  useFactory: Mj,
                  deps: [[Zi, new qd(), new Xd()]],
                },
                { provide: wf, useValue: i || {} },
                i?.useHash
                  ? { provide: Eo, useClass: TG }
                  : { provide: Eo, useClass: bD },
                {
                  provide: vy,
                  useFactory: () => {
                    const n = Te(X4),
                      e = Te(yt),
                      t = Te(wf),
                      i = Te(Sf),
                      r = Te(du);
                    return (
                      t.scrollOffset && n.setOffset(t.scrollOffset),
                      new lI(r, i, n, e, t)
                    );
                  },
                },
                i?.preloadingStrategy
                  ? pj(i.preloadingStrategy).ɵproviders
                  : [],
                { provide: jT, multi: !0, useFactory: _j },
                i?.initialNavigation ? Sj(i) : [],
                i?.bindToComponentInputs
                  ? rs(8, [HA, { provide: _f, useExisting: HA }]).ɵproviders
                  : [],
                [
                  { provide: mI, useFactory: uI },
                  { provide: cv, multi: !0, useExisting: mI },
                ],
              ],
            };
          }
          static forChild(t) {
            return {
              ngModule: n,
              providers: [{ provide: hl, multi: !0, useValue: t }],
            };
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se(fI, 8));
          }),
          (n.ɵmod = Et({ type: n })),
          (n.ɵinj = bt({})),
          n
        );
      })();
      function Mj(n) {
        return "guarded";
      }
      function Sj(n) {
        return [
          "disabled" === n.initialNavigation
            ? rs(3, [
                {
                  provide: tv,
                  multi: !0,
                  useFactory: () => {
                    const e = Te(Zi);
                    return () => {
                      e.setUpLocationChangeListener();
                    };
                  },
                },
                { provide: yy, useValue: 2 },
              ]).ɵproviders
            : [],
          "enabledBlocking" === n.initialNavigation
            ? rs(2, [
                { provide: yy, useValue: 0 },
                {
                  provide: tv,
                  multi: !0,
                  deps: [fi],
                  useFactory: (e) => {
                    const t = e.get(CG, Promise.resolve());
                    return () =>
                      t.then(
                        () =>
                          new Promise((i) => {
                            const r = e.get(Zi),
                              s = e.get(dI);
                            oI(r, () => {
                              i(!0);
                            }),
                              (e.get(Sf).afterPreactivation = () => (
                                i(!0), s.closed ? We(void 0) : s
                              )),
                              r.initialNavigation();
                          }),
                      );
                  },
                },
              ]).ɵproviders
            : [],
        ];
      }
      const mI = new ve("");
      let Ej = (() => {
        class n {
          constructor() {
            this.title = "web-ingegno";
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = Hi({
            type: n,
            selectors: [["app-root"]],
            decls: 1,
            vars: 0,
            template: function (t, i) {
              1 & t && xt(0, "router-outlet");
            },
            dependencies: [uy],
          })),
          n
        );
      })();
      function gI(n, e, t, i, r, s, o) {
        try {
          var a = n[s](o),
            l = a.value;
        } catch (c) {
          return void t(c);
        }
        a.done ? e(l) : Promise.resolve(l).then(i, r);
      }
      const vI = 1,
        Dj = 2,
        ss = 3,
        Ef = 0,
        Xj = 1,
        Yj = 2,
        Us = 0,
        Zj = 1,
        Kj = 2,
        Qj = 3,
        Jj = 4,
        e8 = 5,
        Bs = 301,
        Io = 302,
        Eu = 306,
        ei = 1001,
        mn = 1003,
        gn = 1006,
        Ro = 1008,
        Vs = 1009,
        Hs = 1014,
        as = 1015,
        Cu = 1016,
        Po = 1020,
        Ki = 1023,
        Oo = 1026,
        ml = 1027,
        No = 3001,
        rt = "srgb",
        Nr = "srgb-linear",
        rR = "display-p3",
        sR = "300 es",
        ls = 2e3;
      class vl {
        addEventListener(e, t) {
          void 0 === this._listeners && (this._listeners = {});
          const i = this._listeners;
          void 0 === i[e] && (i[e] = []),
            -1 === i[e].indexOf(t) && i[e].push(t);
        }
        hasEventListener(e, t) {
          if (void 0 === this._listeners) return !1;
          const i = this._listeners;
          return void 0 !== i[e] && -1 !== i[e].indexOf(t);
        }
        removeEventListener(e, t) {
          if (void 0 === this._listeners) return;
          const r = this._listeners[e];
          if (void 0 !== r) {
            const s = r.indexOf(t);
            -1 !== s && r.splice(s, 1);
          }
        }
        dispatchEvent(e) {
          if (void 0 === this._listeners) return;
          const i = this._listeners[e.type];
          if (void 0 !== i) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
            e.target = null;
          }
        }
      }
      const Wn = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ],
        ko = Math.PI / 180,
        yl = 180 / Math.PI;
      function Ti() {
        const n = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          t = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          Wn[255 & n] +
          Wn[(n >> 8) & 255] +
          Wn[(n >> 16) & 255] +
          Wn[(n >> 24) & 255] +
          "-" +
          Wn[255 & e] +
          Wn[(e >> 8) & 255] +
          "-" +
          Wn[((e >> 16) & 15) | 64] +
          Wn[(e >> 24) & 255] +
          "-" +
          Wn[(63 & t) | 128] +
          Wn[(t >> 8) & 255] +
          "-" +
          Wn[(t >> 16) & 255] +
          Wn[(t >> 24) & 255] +
          Wn[255 & i] +
          Wn[(i >> 8) & 255] +
          Wn[(i >> 16) & 255] +
          Wn[(i >> 24) & 255]
        ).toLowerCase();
      }
      function nn(n, e, t) {
        return Math.max(e, Math.min(t, n));
      }
      function xu(n, e, t) {
        return (1 - t) * n + t * e;
      }
      function Ly(n) {
        return 0 == (n & (n - 1)) && 0 !== n;
      }
      function Lf(n) {
        return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
      }
      function gi(n, e) {
        switch (e.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return n / 4294967295;
          case Uint16Array:
            return n / 65535;
          case Uint8Array:
            return n / 255;
          case Int32Array:
            return Math.max(n / 2147483647, -1);
          case Int16Array:
            return Math.max(n / 32767, -1);
          case Int8Array:
            return Math.max(n / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function st(n, e) {
        switch (e.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return Math.round(4294967295 * n);
          case Uint16Array:
            return Math.round(65535 * n);
          case Uint8Array:
            return Math.round(255 * n);
          case Int32Array:
            return Math.round(2147483647 * n);
          case Int16Array:
            return Math.round(32767 * n);
          case Int8Array:
            return Math.round(127 * n);
          default:
            throw new Error("Invalid component type.");
        }
      }
      class oe {
        constructor(e = 0, t = 0) {
          (oe.prototype.isVector2 = !0), (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            i = this.y,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * i + r[6]),
            (this.y = r[1] * t + r[4] * i + r[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(
            Math.max(e, Math.min(t, i)),
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(nn(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            i = this.y - e.y;
          return t * t + i * i;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, i) {
          return (
            (this.x = e.x + (t.x - e.x) * i),
            (this.y = e.y + (t.y - e.y) * i),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t) {
          return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
        }
        rotateAround(e, t) {
          const i = Math.cos(t),
            r = Math.sin(t),
            s = this.x - e.x,
            o = this.y - e.y;
          return (
            (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class ut {
        constructor(e, t, i, r, s, o, a, l, c) {
          (ut.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            void 0 !== e && this.set(e, t, i, r, s, o, a, l, c);
        }
        set(e, t, i, r, s, o, a, l, c) {
          const u = this.elements;
          return (
            (u[0] = e),
            (u[1] = r),
            (u[2] = a),
            (u[3] = t),
            (u[4] = s),
            (u[5] = l),
            (u[6] = i),
            (u[7] = o),
            (u[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            i = e.elements;
          return (
            (t[0] = i[0]),
            (t[1] = i[1]),
            (t[2] = i[2]),
            (t[3] = i[3]),
            (t[4] = i[4]),
            (t[5] = i[5]),
            (t[6] = i[6]),
            (t[7] = i[7]),
            (t[8] = i[8]),
            this
          );
        }
        extractBasis(e, t, i) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            i.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[3],
            l = i[6],
            c = i[1],
            u = i[4],
            d = i[7],
            h = i[2],
            f = i[5],
            p = i[8],
            _ = r[0],
            g = r[3],
            m = r[6],
            y = r[1],
            v = r[4],
            b = r[7],
            S = r[2],
            E = r[5],
            x = r[8];
          return (
            (s[0] = o * _ + a * y + l * S),
            (s[3] = o * g + a * v + l * E),
            (s[6] = o * m + a * b + l * x),
            (s[1] = c * _ + u * y + d * S),
            (s[4] = c * g + u * v + d * E),
            (s[7] = c * m + u * b + d * x),
            (s[2] = h * _ + f * y + p * S),
            (s[5] = h * g + f * v + p * E),
            (s[8] = h * m + f * b + p * x),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8];
          return (
            t * o * u -
            t * a * c -
            i * s * u +
            i * a * l +
            r * s * c -
            r * o * l
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            d = u * o - a * c,
            h = a * l - u * s,
            f = c * s - o * l,
            p = t * d + i * h + r * f;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const _ = 1 / p;
          return (
            (e[0] = d * _),
            (e[1] = (r * c - u * i) * _),
            (e[2] = (a * i - r * o) * _),
            (e[3] = h * _),
            (e[4] = (u * t - r * l) * _),
            (e[5] = (r * s - a * t) * _),
            (e[6] = f * _),
            (e[7] = (i * l - c * t) * _),
            (e[8] = (o * t - i * s) * _),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, i, r, s, o, a) {
          const l = Math.cos(s),
            c = Math.sin(s);
          return (
            this.set(
              i * l,
              i * c,
              -i * (l * o + c * a) + o + e,
              -r * c,
              r * l,
              -r * (-c * o + l * a) + a + t,
              0,
              0,
              1,
            ),
            this
          );
        }
        scale(e, t) {
          return this.premultiply(Fy.makeScale(e, t)), this;
        }
        rotate(e) {
          return this.premultiply(Fy.makeRotation(-e)), this;
        }
        translate(e, t) {
          return this.premultiply(Fy.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
          return (
            e.isVector2
              ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
              : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
            this
          );
        }
        makeRotation(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
          return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
          const t = this.elements,
            i = e.elements;
          for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return (
            (e[t] = i[0]),
            (e[t + 1] = i[1]),
            (e[t + 2] = i[2]),
            (e[t + 3] = i[3]),
            (e[t + 4] = i[4]),
            (e[t + 5] = i[5]),
            (e[t + 6] = i[6]),
            (e[t + 7] = i[7]),
            (e[t + 8] = i[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const Fy = new ut();
      function lR(n) {
        for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
        return !1;
      }
      function Tu(n) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", n);
      }
      Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
      const cR = {};
      function Du(n) {
        n in cR || ((cR[n] = !0), console.warn(n));
      }
      function Ml(n) {
        return n < 0.04045
          ? 0.0773993808 * n
          : Math.pow(0.9478672986 * n + 0.0521327014, 2.4);
      }
      function ky(n) {
        return n < 0.0031308 ? 12.92 * n : 1.055 * Math.pow(n, 0.41666) - 0.055;
      }
      const B8 = new ut().fromArray([
          0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974,
          -1e-7, 1e-7, 0.9105199,
        ]),
        V8 = new ut().fromArray([
          1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361,
          1e-7, 0, 1.0982735,
        ]),
        G8 = {
          [Nr]: (n) => n,
          [rt]: (n) => n.convertSRGBToLinear(),
          [rR]: function H8(n) {
            return n.convertSRGBToLinear().applyMatrix3(V8);
          },
        },
        W8 = {
          [Nr]: (n) => n,
          [rt]: (n) => n.convertLinearToSRGB(),
          [rR]: function z8(n) {
            return n.applyMatrix3(B8).convertLinearToSRGB();
          },
        },
        pr = {
          enabled: !0,
          get legacyMode() {
            return (
              console.warn(
                "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.",
              ),
              !this.enabled
            );
          },
          set legacyMode(n) {
            console.warn(
              "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.",
            ),
              (this.enabled = !n);
          },
          get workingColorSpace() {
            return Nr;
          },
          set workingColorSpace(n) {
            console.warn(
              "THREE.ColorManagement: .workingColorSpace is readonly.",
            );
          },
          convert: function (n, e, t) {
            if (!1 === this.enabled || e === t || !e || !t) return n;
            const i = G8[e],
              r = W8[t];
            if (void 0 === i || void 0 === r)
              throw new Error(
                `Unsupported color space conversion, "${e}" to "${t}".`,
              );
            return r(i(n));
          },
          fromWorkingColorSpace: function (n, e) {
            return this.convert(n, this.workingColorSpace, e);
          },
          toWorkingColorSpace: function (n, e) {
            return this.convert(n, e, this.workingColorSpace);
          },
        };
      let Sl;
      class uR {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            void 0 === Sl && (Sl = Tu("canvas")),
              (Sl.width = e.width),
              (Sl.height = e.height);
            const i = Sl.getContext("2d");
            e instanceof ImageData
              ? i.putImageData(e, 0, 0)
              : i.drawImage(e, 0, 0, e.width, e.height),
              (t = Sl);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e,
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (
            (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement < "u" &&
              e instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
          ) {
            const t = Tu("canvas");
            (t.width = e.width), (t.height = e.height);
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height),
              s = r.data;
            for (let o = 0; o < s.length; o++) s[o] = 255 * Ml(s[o] / 255);
            return i.putImageData(r, 0, 0), t;
          }
          if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
              t[i] =
                t instanceof Uint8Array || t instanceof Uint8ClampedArray
                  ? Math.floor(255 * Ml(t[i] / 255))
                  : Ml(t[i]);
            return { data: t, width: e.width, height: e.height };
          }
          return (
            console.warn(
              "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
            ),
            e
          );
        }
      }
      let $8 = 0;
      class wl {
        constructor(e = null) {
          (this.isSource = !0),
            Object.defineProperty(this, "id", { value: $8++ }),
            (this.uuid = Ti()),
            (this.data = e),
            (this.version = 0);
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
          const i = { uuid: this.uuid, url: "" },
            r = this.data;
          if (null !== r) {
            let s;
            if (Array.isArray(r)) {
              s = [];
              for (let o = 0, a = r.length; o < a; o++)
                s.push(Uy(r[o].isDataTexture ? r[o].image : r[o]));
            } else s = Uy(r);
            i.url = s;
          }
          return t || (e.images[this.uuid] = i), i;
        }
      }
      function Uy(n) {
        return (typeof HTMLImageElement < "u" &&
          n instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
          ? uR.getDataURL(n)
          : n.data
          ? {
              data: Array.from(n.data),
              width: n.width,
              height: n.height,
              type: n.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let j8 = 0,
        zs = (() => {
          class n extends vl {
            constructor(
              t = n.DEFAULT_IMAGE,
              i = n.DEFAULT_MAPPING,
              r = ei,
              s = ei,
              o = gn,
              a = Ro,
              l = Ki,
              c = Vs,
              u = n.DEFAULT_ANISOTROPY,
              d = "",
            ) {
              super(),
                (this.isTexture = !0),
                Object.defineProperty(this, "id", { value: j8++ }),
                (this.uuid = Ti()),
                (this.name = ""),
                (this.source = new wl(t)),
                (this.mipmaps = []),
                (this.mapping = i),
                (this.channel = 0),
                (this.wrapS = r),
                (this.wrapT = s),
                (this.magFilter = o),
                (this.minFilter = a),
                (this.anisotropy = u),
                (this.format = l),
                (this.internalFormat = null),
                (this.type = c),
                (this.offset = new oe(0, 0)),
                (this.repeat = new oe(1, 1)),
                (this.center = new oe(0, 0)),
                (this.rotation = 0),
                (this.matrixAutoUpdate = !0),
                (this.matrix = new ut()),
                (this.generateMipmaps = !0),
                (this.premultiplyAlpha = !1),
                (this.flipY = !0),
                (this.unpackAlignment = 4),
                "string" == typeof d
                  ? (this.colorSpace = d)
                  : (Du(
                      "THREE.Texture: Property .encoding has been replaced by .colorSpace.",
                    ),
                    (this.colorSpace = d === No ? rt : "")),
                (this.userData = {}),
                (this.version = 0),
                (this.onUpdate = null),
                (this.isRenderTargetTexture = !1),
                (this.needsPMREMUpdate = !1);
            }
            get image() {
              return this.source.data;
            }
            set image(t = null) {
              this.source.data = t;
            }
            updateMatrix() {
              this.matrix.setUvTransform(
                this.offset.x,
                this.offset.y,
                this.repeat.x,
                this.repeat.y,
                this.rotation,
                this.center.x,
                this.center.y,
              );
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(t) {
              return (
                (this.name = t.name),
                (this.source = t.source),
                (this.mipmaps = t.mipmaps.slice(0)),
                (this.mapping = t.mapping),
                (this.channel = t.channel),
                (this.wrapS = t.wrapS),
                (this.wrapT = t.wrapT),
                (this.magFilter = t.magFilter),
                (this.minFilter = t.minFilter),
                (this.anisotropy = t.anisotropy),
                (this.format = t.format),
                (this.internalFormat = t.internalFormat),
                (this.type = t.type),
                this.offset.copy(t.offset),
                this.repeat.copy(t.repeat),
                this.center.copy(t.center),
                (this.rotation = t.rotation),
                (this.matrixAutoUpdate = t.matrixAutoUpdate),
                this.matrix.copy(t.matrix),
                (this.generateMipmaps = t.generateMipmaps),
                (this.premultiplyAlpha = t.premultiplyAlpha),
                (this.flipY = t.flipY),
                (this.unpackAlignment = t.unpackAlignment),
                (this.colorSpace = t.colorSpace),
                (this.userData = JSON.parse(JSON.stringify(t.userData))),
                (this.needsUpdate = !0),
                this
              );
            }
            toJSON(t) {
              const i = void 0 === t || "string" == typeof t;
              if (!i && void 0 !== t.textures[this.uuid])
                return t.textures[this.uuid];
              const r = {
                metadata: {
                  version: 4.6,
                  type: "Texture",
                  generator: "Texture.toJSON",
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(t).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment,
              };
              return (
                Object.keys(this.userData).length > 0 &&
                  (r.userData = this.userData),
                i || (t.textures[this.uuid] = r),
                r
              );
            }
            dispose() {
              this.dispatchEvent({ type: "dispose" });
            }
            transformUv(t) {
              if (300 !== this.mapping) return t;
              if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
                switch (this.wrapS) {
                  case 1e3:
                    t.x = t.x - Math.floor(t.x);
                    break;
                  case ei:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                  case 1002:
                    t.x =
                      1 === Math.abs(Math.floor(t.x) % 2)
                        ? Math.ceil(t.x) - t.x
                        : t.x - Math.floor(t.x);
                }
              if (t.y < 0 || t.y > 1)
                switch (this.wrapT) {
                  case 1e3:
                    t.y = t.y - Math.floor(t.y);
                    break;
                  case ei:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                  case 1002:
                    t.y =
                      1 === Math.abs(Math.floor(t.y) % 2)
                        ? Math.ceil(t.y) - t.y
                        : t.y - Math.floor(t.y);
                }
              return this.flipY && (t.y = 1 - t.y), t;
            }
            set needsUpdate(t) {
              !0 === t && (this.version++, (this.source.needsUpdate = !0));
            }
            get encoding() {
              return (
                Du(
                  "THREE.Texture: Property .encoding has been replaced by .colorSpace.",
                ),
                this.colorSpace === rt ? No : 3e3
              );
            }
            set encoding(t) {
              Du(
                "THREE.Texture: Property .encoding has been replaced by .colorSpace.",
              ),
                (this.colorSpace = t === No ? rt : "");
            }
          }
          return (
            (n.DEFAULT_IMAGE = null),
            (n.DEFAULT_MAPPING = 300),
            (n.DEFAULT_ANISOTROPY = 1),
            n
          );
        })();
      class Ut {
        constructor(e = 0, t = 0, i = 0, r = 1) {
          (Ut.prototype.isVector4 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = i),
            (this.w = r);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, i, r) {
          return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = void 0 !== e.w ? e.w : 1),
            this
          );
        }
        add(e) {
          return (
            (this.x += e.x),
            (this.y += e.y),
            (this.z += e.z),
            (this.w += e.w),
            this
          );
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e) {
          return (
            (this.x -= e.x),
            (this.y -= e.y),
            (this.z -= e.z),
            (this.w -= e.w),
            this
          );
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = this.w,
            o = e.elements;
          return (
            (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
            (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
            (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
            (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, i, r, s;
          const l = e.elements,
            c = l[0],
            u = l[4],
            d = l[8],
            h = l[1],
            f = l[5],
            p = l[9],
            _ = l[2],
            g = l[6],
            m = l[10];
          if (
            Math.abs(u - h) < 0.01 &&
            Math.abs(d - _) < 0.01 &&
            Math.abs(p - g) < 0.01
          ) {
            if (
              Math.abs(u + h) < 0.1 &&
              Math.abs(d + _) < 0.1 &&
              Math.abs(p + g) < 0.1 &&
              Math.abs(c + f + m - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const v = (c + 1) / 2,
              b = (f + 1) / 2,
              S = (m + 1) / 2,
              E = (u + h) / 4,
              x = (d + _) / 4,
              P = (p + g) / 4;
            return (
              v > b && v > S
                ? v < 0.01
                  ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
                  : ((i = Math.sqrt(v)), (r = E / i), (s = x / i))
                : b > S
                ? b < 0.01
                  ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
                  : ((r = Math.sqrt(b)), (i = E / r), (s = P / r))
                : S < 0.01
                ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
                : ((s = Math.sqrt(S)), (i = x / s), (r = P / s)),
              this.set(i, r, s, t),
              this
            );
          }
          let y = Math.sqrt(
            (g - p) * (g - p) + (d - _) * (d - _) + (h - u) * (h - u),
          );
          return (
            Math.abs(y) < 0.001 && (y = 1),
            (this.x = (g - p) / y),
            (this.y = (d - _) / y),
            (this.z = (h - u) / y),
            (this.w = Math.acos((c + f + m - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(
            Math.max(e, Math.min(t, i)),
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w,
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, i) {
          return (
            (this.x = e.x + (t.x - e.x) * i),
            (this.y = e.y + (t.y - e.y) * i),
            (this.z = e.z + (t.z - e.z) * i),
            (this.w = e.w + (t.w - e.w) * i),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class q8 extends vl {
        constructor(e = 1, t = 1, i = {}) {
          super(),
            (this.isRenderTarget = !0),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new Ut(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new Ut(0, 0, e, t));
          const r = { width: e, height: t, depth: 1 };
          void 0 !== i.encoding &&
            (Du(
              "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.",
            ),
            (i.colorSpace = i.encoding === No ? rt : "")),
            (this.texture = new zs(
              r,
              i.mapping,
              i.wrapS,
              i.wrapT,
              i.magFilter,
              i.minFilter,
              i.format,
              i.type,
              i.anisotropy,
              i.colorSpace,
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.flipY = !1),
            (this.texture.generateMipmaps =
              void 0 !== i.generateMipmaps && i.generateMipmaps),
            (this.texture.internalFormat =
              void 0 !== i.internalFormat ? i.internalFormat : null),
            (this.texture.minFilter =
              void 0 !== i.minFilter ? i.minFilter : gn),
            (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
            (this.stencilBuffer =
              void 0 !== i.stencilBuffer && i.stencilBuffer),
            (this.depthTexture =
              void 0 !== i.depthTexture ? i.depthTexture : null),
            (this.samples = void 0 !== i.samples ? i.samples : 0);
        }
        setSize(e, t, i = 1) {
          (this.width !== e || this.height !== t || this.depth !== i) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = i),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = i),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.scissor.copy(e.scissor),
            (this.scissorTest = e.scissorTest),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.isRenderTargetTexture = !0);
          const t = Object.assign({}, e.texture.image);
          return (
            (this.texture.source = new wl(t)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            null !== e.depthTexture &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class Uo extends q8 {
        constructor(e = 1, t = 1, i = {}) {
          super(e, t, i), (this.isWebGLRenderTarget = !0);
        }
      }
      class By extends zs {
        constructor(e = null, t = 1, i = 1, r = 1) {
          super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: e, width: t, height: i, depth: r }),
            (this.magFilter = mn),
            (this.minFilter = mn),
            (this.wrapR = ei),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class dR extends zs {
        constructor(e = null, t = 1, i = 1, r = 1) {
          super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: e, width: t, height: i, depth: r }),
            (this.magFilter = mn),
            (this.minFilter = mn),
            (this.wrapR = ei),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class Di {
        constructor(e = 0, t = 0, i = 0, r = 1) {
          (this.isQuaternion = !0),
            (this._x = e),
            (this._y = t),
            (this._z = i),
            (this._w = r);
        }
        static slerpFlat(e, t, i, r, s, o, a) {
          let l = i[r + 0],
            c = i[r + 1],
            u = i[r + 2],
            d = i[r + 3];
          const h = s[o + 0],
            f = s[o + 1],
            p = s[o + 2],
            _ = s[o + 3];
          if (0 === a)
            return (
              (e[t + 0] = l),
              (e[t + 1] = c),
              (e[t + 2] = u),
              void (e[t + 3] = d)
            );
          if (1 === a)
            return (
              (e[t + 0] = h),
              (e[t + 1] = f),
              (e[t + 2] = p),
              void (e[t + 3] = _)
            );
          if (d !== _ || l !== h || c !== f || u !== p) {
            let g = 1 - a;
            const m = l * h + c * f + u * p + d * _,
              y = m >= 0 ? 1 : -1,
              v = 1 - m * m;
            if (v > Number.EPSILON) {
              const S = Math.sqrt(v),
                E = Math.atan2(S, m * y);
              (g = Math.sin(g * E) / S), (a = Math.sin(a * E) / S);
            }
            const b = a * y;
            if (
              ((l = l * g + h * b),
              (c = c * g + f * b),
              (u = u * g + p * b),
              (d = d * g + _ * b),
              g === 1 - a)
            ) {
              const S = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
              (l *= S), (c *= S), (u *= S), (d *= S);
            }
          }
          (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = d);
        }
        static multiplyQuaternionsFlat(e, t, i, r, s, o) {
          const a = i[r],
            l = i[r + 1],
            c = i[r + 2],
            u = i[r + 3],
            d = s[o],
            h = s[o + 1],
            f = s[o + 2],
            p = s[o + 3];
          return (
            (e[t] = a * p + u * d + l * f - c * h),
            (e[t + 1] = l * p + u * h + c * d - a * f),
            (e[t + 2] = c * p + u * f + a * h - l * d),
            (e[t + 3] = u * p - a * d - l * h - c * f),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, i, r) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = i),
            (this._w = r),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          const i = e._x,
            r = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(i / 2),
            u = a(r / 2),
            d = a(s / 2),
            h = l(i / 2),
            f = l(r / 2),
            p = l(s / 2);
          switch (o) {
            case "XYZ":
              (this._x = h * u * d + c * f * p),
                (this._y = c * f * d - h * u * p),
                (this._z = c * u * p + h * f * d),
                (this._w = c * u * d - h * f * p);
              break;
            case "YXZ":
              (this._x = h * u * d + c * f * p),
                (this._y = c * f * d - h * u * p),
                (this._z = c * u * p - h * f * d),
                (this._w = c * u * d + h * f * p);
              break;
            case "ZXY":
              (this._x = h * u * d - c * f * p),
                (this._y = c * f * d + h * u * p),
                (this._z = c * u * p + h * f * d),
                (this._w = c * u * d - h * f * p);
              break;
            case "ZYX":
              (this._x = h * u * d - c * f * p),
                (this._y = c * f * d + h * u * p),
                (this._z = c * u * p - h * f * d),
                (this._w = c * u * d + h * f * p);
              break;
            case "YZX":
              (this._x = h * u * d + c * f * p),
                (this._y = c * f * d + h * u * p),
                (this._z = c * u * p - h * f * d),
                (this._w = c * u * d - h * f * p);
              break;
            case "XZY":
              (this._x = h * u * d - c * f * p),
                (this._y = c * f * d - h * u * p),
                (this._z = c * u * p + h * f * d),
                (this._w = c * u * d + h * f * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  o,
              );
          }
          return !1 !== t && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const i = t / 2,
            r = Math.sin(i);
          return (
            (this._x = e.x * r),
            (this._y = e.y * r),
            (this._z = e.z * r),
            (this._w = Math.cos(i)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            i = t[0],
            r = t[4],
            s = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            u = t[6],
            d = t[10],
            h = i + a + d;
          if (h > 0) {
            const f = 0.5 / Math.sqrt(h + 1);
            (this._w = 0.25 / f),
              (this._x = (u - l) * f),
              (this._y = (s - c) * f),
              (this._z = (o - r) * f);
          } else if (i > a && i > d) {
            const f = 2 * Math.sqrt(1 + i - a - d);
            (this._w = (u - l) / f),
              (this._x = 0.25 * f),
              (this._y = (r + o) / f),
              (this._z = (s + c) / f);
          } else if (a > d) {
            const f = 2 * Math.sqrt(1 + a - i - d);
            (this._w = (s - c) / f),
              (this._x = (r + o) / f),
              (this._y = 0.25 * f),
              (this._z = (l + u) / f);
          } else {
            const f = 2 * Math.sqrt(1 + d - i - a);
            (this._w = (o - r) / f),
              (this._x = (s + c) / f),
              (this._y = (l + u) / f),
              (this._z = 0.25 * f);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let i = e.dot(t) + 1;
          return (
            i < Number.EPSILON
              ? ((i = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = i))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = i)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = i)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(nn(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const i = this.angleTo(e);
          if (0 === i) return this;
          const r = Math.min(1, t / i);
          return this.slerp(e, r), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w,
          );
        }
        normalize() {
          let e = this.length();
          return (
            0 === e
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const i = e._x,
            r = e._y,
            s = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            u = t._w;
          return (
            (this._x = i * u + o * a + r * c - s * l),
            (this._y = r * u + o * l + s * a - i * c),
            (this._z = s * u + o * c + i * l - r * a),
            (this._w = o * u - i * a - r * l - s * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (0 === t) return this;
          if (1 === t) return this.copy(e);
          const i = this._x,
            r = this._y,
            s = this._z,
            o = this._w;
          let a = o * e._w + i * e._x + r * e._y + s * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = o), (this._x = i), (this._y = r), (this._z = s), this
            );
          const l = 1 - a * a;
          if (l <= Number.EPSILON) {
            const f = 1 - t;
            return (
              (this._w = f * o + t * this._w),
              (this._x = f * i + t * this._x),
              (this._y = f * r + t * this._y),
              (this._z = f * s + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(l),
            u = Math.atan2(c, a),
            d = Math.sin((1 - t) * u) / c,
            h = Math.sin(t * u) / c;
          return (
            (this._w = o * d + this._w * h),
            (this._x = i * d + this._x * h),
            (this._y = r * d + this._y * h),
            (this._z = s * d + this._z * h),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, i) {
          return this.copy(e).slerp(t, i);
        }
        random() {
          const e = Math.random(),
            t = Math.sqrt(1 - e),
            i = Math.sqrt(e),
            r = 2 * Math.PI * Math.random(),
            s = 2 * Math.PI * Math.random();
          return this.set(
            t * Math.cos(r),
            i * Math.sin(s),
            i * Math.cos(s),
            t * Math.sin(r),
          );
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class D {
        constructor(e = 0, t = 0, i = 0) {
          (D.prototype.isVector3 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = i);
        }
        set(e, t, i) {
          return (
            void 0 === i && (i = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = i),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return this.applyQuaternion(hR.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(hR.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[3] * i + s[6] * r),
            (this.y = s[1] * t + s[4] * i + s[7] * r),
            (this.z = s[2] * t + s[5] * i + s[8] * r),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements,
            o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
          return (
            (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
            (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
            (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = l * t + o * r - a * i,
            u = l * i + a * t - s * r,
            d = l * r + s * i - o * t,
            h = -s * t - o * i - a * r;
          return (
            (this.x = c * l + h * -s + u * -a - d * -o),
            (this.y = u * l + h * -o + d * -s - c * -a),
            (this.z = d * l + h * -a + c * -o - u * -s),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix,
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld,
          );
        }
        transformDirection(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[4] * i + s[8] * r),
            (this.y = s[1] * t + s[5] * i + s[9] * r),
            (this.z = s[2] * t + s[6] * i + s[10] * r),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(
            Math.max(e, Math.min(t, i)),
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, i) {
          return (
            (this.x = e.x + (t.x - e.x) * i),
            (this.y = e.y + (t.y - e.y) * i),
            (this.z = e.z + (t.z - e.z) * i),
            this
          );
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const i = e.x,
            r = e.y,
            s = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
          return (
            (this.x = r * l - s * a),
            (this.y = s * o - i * l),
            (this.z = i * a - r * o),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (0 === t) return this.set(0, 0, 0);
          const i = e.dot(this) / t;
          return this.copy(e).multiplyScalar(i);
        }
        projectOnPlane(e) {
          return Vy.copy(this).projectOnVector(e), this.sub(Vy);
        }
        reflect(e) {
          return this.sub(Vy.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(nn(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            i = this.y - e.y,
            r = this.z - e.z;
          return t * t + i * i + r * r;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, i) {
          const r = Math.sin(t) * e;
          return (
            (this.x = r * Math.sin(i)),
            (this.y = Math.cos(t) * e),
            (this.z = r * Math.cos(i)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, i) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = i),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            i = this.setFromMatrixColumn(e, 1).length(),
            r = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = i), (this.z = r), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, 4 * t);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, 3 * t);
        }
        setFromEuler(e) {
          return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
        }
        setFromColor(e) {
          return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const e = 2 * (Math.random() - 0.5),
            t = Math.random() * Math.PI * 2,
            i = Math.sqrt(1 - e ** 2);
          return (
            (this.x = i * Math.cos(t)),
            (this.y = i * Math.sin(t)),
            (this.z = e),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const Vy = new D(),
        hR = new Di();
      class cs {
        constructor(
          e = new D(1 / 0, 1 / 0, 1 / 0),
          t = new D(-1 / 0, -1 / 0, -1 / 0),
        ) {
          (this.isBox3 = !0), (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(ds.fromArray(e, t));
          return this;
        }
        setFromBufferAttribute(e) {
          this.makeEmpty();
          for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(ds.fromBufferAttribute(e, t));
          return this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const i = ds.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          if ((e.updateWorldMatrix(!1, !1), void 0 !== e.boundingBox))
            null === e.boundingBox && e.computeBoundingBox(),
              El.copy(e.boundingBox),
              El.applyMatrix4(e.matrixWorld),
              this.union(El);
          else {
            const r = e.geometry;
            if (void 0 !== r)
              if (
                t &&
                void 0 !== r.attributes &&
                void 0 !== r.attributes.position
              ) {
                const s = r.attributes.position;
                for (let o = 0, a = s.count; o < a; o++)
                  ds.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(ds);
              } else
                null === r.boundingBox && r.computeBoundingBox(),
                  El.copy(r.boundingBox),
                  El.applyMatrix4(e.matrixWorld),
                  this.union(El);
          }
          const i = e.children;
          for (let r = 0, s = i.length; r < s; r++)
            this.expandByObject(i[r], t);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z),
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, ds),
            ds.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, i;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (i += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (i += e.normal.z * this.min.z)),
            t <= -e.constant && i >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(Au),
            Ff.subVectors(this.max, Au),
            Cl.subVectors(e.a, Au),
            xl.subVectors(e.b, Au),
            Tl.subVectors(e.c, Au),
            Gs.subVectors(xl, Cl),
            Ws.subVectors(Tl, xl),
            Bo.subVectors(Cl, Tl);
          let t = [
            0,
            -Gs.z,
            Gs.y,
            0,
            -Ws.z,
            Ws.y,
            0,
            -Bo.z,
            Bo.y,
            Gs.z,
            0,
            -Gs.x,
            Ws.z,
            0,
            -Ws.x,
            Bo.z,
            0,
            -Bo.x,
            -Gs.y,
            Gs.x,
            0,
            -Ws.y,
            Ws.x,
            0,
            -Bo.y,
            Bo.x,
            0,
          ];
          return (
            !(
              !Hy(t, Cl, xl, Tl, Ff) ||
              ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Hy(t, Cl, xl, Tl, Ff))
            ) &&
            (kf.crossVectors(Gs, Ws),
            (t = [kf.x, kf.y, kf.z]),
            Hy(t, Cl, xl, Tl, Ff))
          );
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return this.clampPoint(e, ds).distanceTo(e);
        }
        getBoundingSphere(e) {
          return (
            this.isEmpty()
              ? e.makeEmpty()
              : (this.getCenter(e.center),
                (e.radius = 0.5 * this.getSize(ds).length())),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return (
            this.isEmpty() ||
              (us[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              us[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              us[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              us[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              us[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              us[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              us[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              us[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(us)),
            this
          );
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const us = [
          new D(),
          new D(),
          new D(),
          new D(),
          new D(),
          new D(),
          new D(),
          new D(),
        ],
        ds = new D(),
        El = new cs(),
        Cl = new D(),
        xl = new D(),
        Tl = new D(),
        Gs = new D(),
        Ws = new D(),
        Bo = new D(),
        Au = new D(),
        Ff = new D(),
        kf = new D(),
        Vo = new D();
      function Hy(n, e, t, i, r) {
        for (let s = 0, o = n.length - 3; s <= o; s += 3) {
          Vo.fromArray(n, s);
          const a =
              r.x * Math.abs(Vo.x) +
              r.y * Math.abs(Vo.y) +
              r.z * Math.abs(Vo.z),
            l = e.dot(Vo),
            c = t.dot(Vo),
            u = i.dot(Vo);
          if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1;
        }
        return !0;
      }
      const X8 = new cs(),
        Iu = new D(),
        zy = new D();
      class Lr {
        constructor(e = new D(), t = -1) {
          (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const i = this.center;
          void 0 !== t ? i.copy(t) : X8.setFromPoints(e).getCenter(i);
          let r = 0;
          for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
          return (this.radius = Math.sqrt(r)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const i = this.center.distanceToSquared(e);
          return (
            t.copy(e),
            i > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e);
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          if (this.isEmpty())
            return this.center.copy(e), (this.radius = 0), this;
          Iu.subVectors(e, this.center);
          const t = Iu.lengthSq();
          if (t > this.radius * this.radius) {
            const i = Math.sqrt(t),
              r = 0.5 * (i - this.radius);
            this.center.addScaledVector(Iu, r / i), (this.radius += r);
          }
          return this;
        }
        union(e) {
          return e.isEmpty()
            ? this
            : this.isEmpty()
            ? (this.copy(e), this)
            : (!0 === this.center.equals(e.center)
                ? (this.radius = Math.max(this.radius, e.radius))
                : (zy.subVectors(e.center, this.center).setLength(e.radius),
                  this.expandByPoint(Iu.copy(e.center).add(zy)),
                  this.expandByPoint(Iu.copy(e.center).sub(zy))),
              this);
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const hs = new D(),
        Gy = new D(),
        Uf = new D(),
        $s = new D(),
        Wy = new D(),
        Bf = new D(),
        $y = new D();
      class Ru {
        constructor(e = new D(), t = new D(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, hs)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const i = t.dot(this.direction);
          return i < 0
            ? t.copy(this.origin)
            : t.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = hs.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (hs.copy(this.origin).addScaledVector(this.direction, t),
              hs.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, i, r) {
          Gy.copy(e).add(t).multiplyScalar(0.5),
            Uf.copy(t).sub(e).normalize(),
            $s.copy(this.origin).sub(Gy);
          const s = 0.5 * e.distanceTo(t),
            o = -this.direction.dot(Uf),
            a = $s.dot(this.direction),
            l = -$s.dot(Uf),
            c = $s.lengthSq(),
            u = Math.abs(1 - o * o);
          let d, h, f, p;
          if (u > 0)
            if (((d = o * l - a), (h = o * a - l), (p = s * u), d >= 0))
              if (h >= -p)
                if (h <= p) {
                  const _ = 1 / u;
                  (d *= _),
                    (h *= _),
                    (f = d * (d + o * h + 2 * a) + h * (o * d + h + 2 * l) + c);
                } else
                  (h = s),
                    (d = Math.max(0, -(o * h + a))),
                    (f = -d * d + h * (h + 2 * l) + c);
              else
                (h = -s),
                  (d = Math.max(0, -(o * h + a))),
                  (f = -d * d + h * (h + 2 * l) + c);
            else
              h <= -p
                ? ((d = Math.max(0, -(-o * s + a))),
                  (h = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
                  (f = -d * d + h * (h + 2 * l) + c))
                : h <= p
                ? ((d = 0),
                  (h = Math.min(Math.max(-s, -l), s)),
                  (f = h * (h + 2 * l) + c))
                : ((d = Math.max(0, -(o * s + a))),
                  (h = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
                  (f = -d * d + h * (h + 2 * l) + c));
          else
            (h = o > 0 ? -s : s),
              (d = Math.max(0, -(o * h + a))),
              (f = -d * d + h * (h + 2 * l) + c);
          return (
            i && i.copy(this.origin).addScaledVector(this.direction, d),
            r && r.copy(Gy).addScaledVector(Uf, h),
            f
          );
        }
        intersectSphere(e, t) {
          hs.subVectors(e.center, this.origin);
          const i = hs.dot(this.direction),
            r = hs.dot(hs) - i * i,
            s = e.radius * e.radius;
          if (r > s) return null;
          const o = Math.sqrt(s - r),
            a = i - o,
            l = i + o;
          return l < 0 ? null : this.at(a < 0 ? l : a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
          const i = -(this.origin.dot(e.normal) + e.constant) / t;
          return i >= 0 ? i : null;
        }
        intersectPlane(e, t) {
          const i = this.distanceToPlane(e);
          return null === i ? null : this.at(i, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return 0 === t || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let i, r, s, o, a, l;
          const c = 1 / this.direction.x,
            u = 1 / this.direction.y,
            d = 1 / this.direction.z,
            h = this.origin;
          return (
            c >= 0
              ? ((i = (e.min.x - h.x) * c), (r = (e.max.x - h.x) * c))
              : ((i = (e.max.x - h.x) * c), (r = (e.min.x - h.x) * c)),
            u >= 0
              ? ((s = (e.min.y - h.y) * u), (o = (e.max.y - h.y) * u))
              : ((s = (e.max.y - h.y) * u), (o = (e.min.y - h.y) * u)),
            i > o ||
            s > r ||
            ((s > i || isNaN(i)) && (i = s),
            (o < r || isNaN(r)) && (r = o),
            d >= 0
              ? ((a = (e.min.z - h.z) * d), (l = (e.max.z - h.z) * d))
              : ((a = (e.max.z - h.z) * d), (l = (e.min.z - h.z) * d)),
            i > l || a > r) ||
            ((a > i || i != i) && (i = a), (l < r || r != r) && (r = l), r < 0)
              ? null
              : this.at(i >= 0 ? i : r, t)
          );
        }
        intersectsBox(e) {
          return null !== this.intersectBox(e, hs);
        }
        intersectTriangle(e, t, i, r, s) {
          Wy.subVectors(t, e), Bf.subVectors(i, e), $y.crossVectors(Wy, Bf);
          let a,
            o = this.direction.dot($y);
          if (o > 0) {
            if (r) return null;
            a = 1;
          } else {
            if (!(o < 0)) return null;
            (a = -1), (o = -o);
          }
          $s.subVectors(this.origin, e);
          const l = a * this.direction.dot(Bf.crossVectors($s, Bf));
          if (l < 0) return null;
          const c = a * this.direction.dot(Wy.cross($s));
          if (c < 0 || l + c > o) return null;
          const u = -a * $s.dot($y);
          return u < 0 ? null : this.at(u / o, s);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class it {
        constructor(e, t, i, r, s, o, a, l, c, u, d, h, f, p, _, g) {
          (it.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            void 0 !== e &&
              this.set(e, t, i, r, s, o, a, l, c, u, d, h, f, p, _, g);
        }
        set(e, t, i, r, s, o, a, l, c, u, d, h, f, p, _, g) {
          const m = this.elements;
          return (
            (m[0] = e),
            (m[4] = t),
            (m[8] = i),
            (m[12] = r),
            (m[1] = s),
            (m[5] = o),
            (m[9] = a),
            (m[13] = l),
            (m[2] = c),
            (m[6] = u),
            (m[10] = d),
            (m[14] = h),
            (m[3] = f),
            (m[7] = p),
            (m[11] = _),
            (m[15] = g),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new it().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            i = e.elements;
          return (
            (t[0] = i[0]),
            (t[1] = i[1]),
            (t[2] = i[2]),
            (t[3] = i[3]),
            (t[4] = i[4]),
            (t[5] = i[5]),
            (t[6] = i[6]),
            (t[7] = i[7]),
            (t[8] = i[8]),
            (t[9] = i[9]),
            (t[10] = i[10]),
            (t[11] = i[11]),
            (t[12] = i[12]),
            (t[13] = i[13]),
            (t[14] = i[14]),
            (t[15] = i[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            i = e.elements;
          return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1,
            ),
            this
          );
        }
        extractBasis(e, t, i) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            i.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, i) {
          return (
            this.set(
              e.x,
              t.x,
              i.x,
              0,
              e.y,
              t.y,
              i.y,
              0,
              e.z,
              t.z,
              i.z,
              0,
              0,
              0,
              0,
              1,
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            i = e.elements,
            r = 1 / Dl.setFromMatrixColumn(e, 0).length(),
            s = 1 / Dl.setFromMatrixColumn(e, 1).length(),
            o = 1 / Dl.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = i[0] * r),
            (t[1] = i[1] * r),
            (t[2] = i[2] * r),
            (t[3] = 0),
            (t[4] = i[4] * s),
            (t[5] = i[5] * s),
            (t[6] = i[6] * s),
            (t[7] = 0),
            (t[8] = i[8] * o),
            (t[9] = i[9] * o),
            (t[10] = i[10] * o),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z,
            o = Math.cos(i),
            a = Math.sin(i),
            l = Math.cos(r),
            c = Math.sin(r),
            u = Math.cos(s),
            d = Math.sin(s);
          if ("XYZ" === e.order) {
            const h = o * u,
              f = o * d,
              p = a * u,
              _ = a * d;
            (t[0] = l * u),
              (t[4] = -l * d),
              (t[8] = c),
              (t[1] = f + p * c),
              (t[5] = h - _ * c),
              (t[9] = -a * l),
              (t[2] = _ - h * c),
              (t[6] = p + f * c),
              (t[10] = o * l);
          } else if ("YXZ" === e.order) {
            const h = l * u,
              f = l * d,
              p = c * u,
              _ = c * d;
            (t[0] = h + _ * a),
              (t[4] = p * a - f),
              (t[8] = o * c),
              (t[1] = o * d),
              (t[5] = o * u),
              (t[9] = -a),
              (t[2] = f * a - p),
              (t[6] = _ + h * a),
              (t[10] = o * l);
          } else if ("ZXY" === e.order) {
            const h = l * u,
              f = l * d,
              p = c * u,
              _ = c * d;
            (t[0] = h - _ * a),
              (t[4] = -o * d),
              (t[8] = p + f * a),
              (t[1] = f + p * a),
              (t[5] = o * u),
              (t[9] = _ - h * a),
              (t[2] = -o * c),
              (t[6] = a),
              (t[10] = o * l);
          } else if ("ZYX" === e.order) {
            const h = o * u,
              f = o * d,
              p = a * u,
              _ = a * d;
            (t[0] = l * u),
              (t[4] = p * c - f),
              (t[8] = h * c + _),
              (t[1] = l * d),
              (t[5] = _ * c + h),
              (t[9] = f * c - p),
              (t[2] = -c),
              (t[6] = a * l),
              (t[10] = o * l);
          } else if ("YZX" === e.order) {
            const h = o * l,
              f = o * c,
              p = a * l,
              _ = a * c;
            (t[0] = l * u),
              (t[4] = _ - h * d),
              (t[8] = p * d + f),
              (t[1] = d),
              (t[5] = o * u),
              (t[9] = -a * u),
              (t[2] = -c * u),
              (t[6] = f * d + p),
              (t[10] = h - _ * d);
          } else if ("XZY" === e.order) {
            const h = o * l,
              f = o * c,
              p = a * l,
              _ = a * c;
            (t[0] = l * u),
              (t[4] = -d),
              (t[8] = c * u),
              (t[1] = h * d + _),
              (t[5] = o * u),
              (t[9] = f * d - p),
              (t[2] = p * d - f),
              (t[6] = a * u),
              (t[10] = _ * d + h);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(Y8, e, Z8);
        }
        lookAt(e, t, i) {
          const r = this.elements;
          return (
            Ai.subVectors(e, t),
            0 === Ai.lengthSq() && (Ai.z = 1),
            Ai.normalize(),
            js.crossVectors(i, Ai),
            0 === js.lengthSq() &&
              (1 === Math.abs(i.z) ? (Ai.x += 1e-4) : (Ai.z += 1e-4),
              Ai.normalize(),
              js.crossVectors(i, Ai)),
            js.normalize(),
            Vf.crossVectors(Ai, js),
            (r[0] = js.x),
            (r[4] = Vf.x),
            (r[8] = Ai.x),
            (r[1] = js.y),
            (r[5] = Vf.y),
            (r[9] = Ai.y),
            (r[2] = js.z),
            (r[6] = Vf.z),
            (r[10] = Ai.z),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[4],
            l = i[8],
            c = i[12],
            u = i[1],
            d = i[5],
            h = i[9],
            f = i[13],
            p = i[2],
            _ = i[6],
            g = i[10],
            m = i[14],
            y = i[3],
            v = i[7],
            b = i[11],
            S = i[15],
            E = r[0],
            x = r[4],
            P = r[8],
            M = r[12],
            C = r[1],
            $ = r[5],
            ie = r[9],
            V = r[13],
            z = r[2],
            W = r[6],
            F = r[10],
            N = r[14],
            k = r[3],
            q = r[7],
            ee = r[11],
            U = r[15];
          return (
            (s[0] = o * E + a * C + l * z + c * k),
            (s[4] = o * x + a * $ + l * W + c * q),
            (s[8] = o * P + a * ie + l * F + c * ee),
            (s[12] = o * M + a * V + l * N + c * U),
            (s[1] = u * E + d * C + h * z + f * k),
            (s[5] = u * x + d * $ + h * W + f * q),
            (s[9] = u * P + d * ie + h * F + f * ee),
            (s[13] = u * M + d * V + h * N + f * U),
            (s[2] = p * E + _ * C + g * z + m * k),
            (s[6] = p * x + _ * $ + g * W + m * q),
            (s[10] = p * P + _ * ie + g * F + m * ee),
            (s[14] = p * M + _ * V + g * N + m * U),
            (s[3] = y * E + v * C + b * z + S * k),
            (s[7] = y * x + v * $ + b * W + S * q),
            (s[11] = y * P + v * ie + b * F + S * ee),
            (s[15] = y * M + v * V + b * N + S * U),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            i = e[4],
            r = e[8],
            s = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            u = e[2],
            d = e[6],
            h = e[10],
            f = e[14];
          return (
            e[3] *
              (+s * l * d -
                r * c * d -
                s * a * h +
                i * c * h +
                r * a * f -
                i * l * f) +
            e[7] *
              (+t * l * f -
                t * c * h +
                s * o * h -
                r * o * f +
                r * c * u -
                s * l * u) +
            e[11] *
              (+t * c * d -
                t * a * f -
                s * o * d +
                i * o * f +
                s * a * u -
                i * c * u) +
            e[15] *
              (-r * a * u -
                t * l * d +
                t * a * h +
                r * o * d -
                i * o * h +
                i * l * u)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, i) {
          const r = this.elements;
          return (
            e.isVector3
              ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
              : ((r[12] = e), (r[13] = t), (r[14] = i)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            d = e[9],
            h = e[10],
            f = e[11],
            p = e[12],
            _ = e[13],
            g = e[14],
            m = e[15],
            y =
              d * g * c -
              _ * h * c +
              _ * l * f -
              a * g * f -
              d * l * m +
              a * h * m,
            v =
              p * h * c -
              u * g * c -
              p * l * f +
              o * g * f +
              u * l * m -
              o * h * m,
            b =
              u * _ * c -
              p * d * c +
              p * a * f -
              o * _ * f -
              u * a * m +
              o * d * m,
            S =
              p * d * l -
              u * _ * l -
              p * a * h +
              o * _ * h +
              u * a * g -
              o * d * g,
            E = t * y + i * v + r * b + s * S;
          if (0 === E)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const x = 1 / E;
          return (
            (e[0] = y * x),
            (e[1] =
              (_ * h * s -
                d * g * s -
                _ * r * f +
                i * g * f +
                d * r * m -
                i * h * m) *
              x),
            (e[2] =
              (a * g * s -
                _ * l * s +
                _ * r * c -
                i * g * c -
                a * r * m +
                i * l * m) *
              x),
            (e[3] =
              (d * l * s -
                a * h * s -
                d * r * c +
                i * h * c +
                a * r * f -
                i * l * f) *
              x),
            (e[4] = v * x),
            (e[5] =
              (u * g * s -
                p * h * s +
                p * r * f -
                t * g * f -
                u * r * m +
                t * h * m) *
              x),
            (e[6] =
              (p * l * s -
                o * g * s -
                p * r * c +
                t * g * c +
                o * r * m -
                t * l * m) *
              x),
            (e[7] =
              (o * h * s -
                u * l * s +
                u * r * c -
                t * h * c -
                o * r * f +
                t * l * f) *
              x),
            (e[8] = b * x),
            (e[9] =
              (p * d * s -
                u * _ * s -
                p * i * f +
                t * _ * f +
                u * i * m -
                t * d * m) *
              x),
            (e[10] =
              (o * _ * s -
                p * a * s +
                p * i * c -
                t * _ * c -
                o * i * m +
                t * a * m) *
              x),
            (e[11] =
              (u * a * s -
                o * d * s -
                u * i * c +
                t * d * c +
                o * i * f -
                t * a * f) *
              x),
            (e[12] = S * x),
            (e[13] =
              (u * _ * r -
                p * d * r +
                p * i * h -
                t * _ * h -
                u * i * g +
                t * d * g) *
              x),
            (e[14] =
              (p * a * r -
                o * _ * r -
                p * i * l +
                t * _ * l +
                o * i * g -
                t * a * g) *
              x),
            (e[15] =
              (o * d * r -
                u * a * r +
                u * i * l -
                t * d * l -
                o * i * h +
                t * a * h) *
              x),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z;
          return (
            (t[0] *= i),
            (t[4] *= r),
            (t[8] *= s),
            (t[1] *= i),
            (t[5] *= r),
            (t[9] *= s),
            (t[2] *= i),
            (t[6] *= r),
            (t[10] *= s),
            (t[3] *= i),
            (t[7] *= r),
            (t[11] *= s),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements;
          return Math.sqrt(
            Math.max(
              e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
              e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
              e[8] * e[8] + e[9] * e[9] + e[10] * e[10],
            ),
          );
        }
        makeTranslation(e, t, i) {
          return (
            e.isVector3
              ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
              : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
            this
          );
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return (
            this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return (
            this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const i = Math.cos(t),
            r = Math.sin(t),
            s = 1 - i,
            o = e.x,
            a = e.y,
            l = e.z,
            c = s * o,
            u = s * a;
          return (
            this.set(
              c * o + i,
              c * a - r * l,
              c * l + r * a,
              0,
              c * a + r * l,
              u * a + i,
              u * l - r * o,
              0,
              c * l - r * a,
              u * l + r * o,
              s * l * l + i,
              0,
              0,
              0,
              0,
              1,
            ),
            this
          );
        }
        makeScale(e, t, i) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, i, r, s, o) {
          return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, i) {
          const r = this.elements,
            s = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = s + s,
            u = o + o,
            d = a + a,
            h = s * c,
            f = s * u,
            p = s * d,
            _ = o * u,
            g = o * d,
            m = a * d,
            y = l * c,
            v = l * u,
            b = l * d,
            S = i.x,
            E = i.y,
            x = i.z;
          return (
            (r[0] = (1 - (_ + m)) * S),
            (r[1] = (f + b) * S),
            (r[2] = (p - v) * S),
            (r[3] = 0),
            (r[4] = (f - b) * E),
            (r[5] = (1 - (h + m)) * E),
            (r[6] = (g + y) * E),
            (r[7] = 0),
            (r[8] = (p + v) * x),
            (r[9] = (g - y) * x),
            (r[10] = (1 - (h + _)) * x),
            (r[11] = 0),
            (r[12] = e.x),
            (r[13] = e.y),
            (r[14] = e.z),
            (r[15] = 1),
            this
          );
        }
        decompose(e, t, i) {
          const r = this.elements;
          let s = Dl.set(r[0], r[1], r[2]).length();
          const o = Dl.set(r[4], r[5], r[6]).length(),
            a = Dl.set(r[8], r[9], r[10]).length();
          this.determinant() < 0 && (s = -s),
            (e.x = r[12]),
            (e.y = r[13]),
            (e.z = r[14]),
            mr.copy(this);
          const c = 1 / s,
            u = 1 / o,
            d = 1 / a;
          return (
            (mr.elements[0] *= c),
            (mr.elements[1] *= c),
            (mr.elements[2] *= c),
            (mr.elements[4] *= u),
            (mr.elements[5] *= u),
            (mr.elements[6] *= u),
            (mr.elements[8] *= d),
            (mr.elements[9] *= d),
            (mr.elements[10] *= d),
            t.setFromRotationMatrix(mr),
            (i.x = s),
            (i.y = o),
            (i.z = a),
            this
          );
        }
        makePerspective(e, t, i, r, s, o, a = ls) {
          const l = this.elements,
            c = (2 * s) / (t - e),
            u = (2 * s) / (i - r),
            d = (t + e) / (t - e),
            h = (i + r) / (i - r);
          let f, p;
          if (a === ls) (f = -(o + s) / (o - s)), (p = (-2 * o * s) / (o - s));
          else {
            if (2001 !== a)
              throw new Error(
                "THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
                  a,
              );
            (f = -o / (o - s)), (p = (-o * s) / (o - s));
          }
          return (
            (l[0] = c),
            (l[4] = 0),
            (l[8] = d),
            (l[12] = 0),
            (l[1] = 0),
            (l[5] = u),
            (l[9] = h),
            (l[13] = 0),
            (l[2] = 0),
            (l[6] = 0),
            (l[10] = f),
            (l[14] = p),
            (l[3] = 0),
            (l[7] = 0),
            (l[11] = -1),
            (l[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, i, r, s, o, a = ls) {
          const l = this.elements,
            c = 1 / (t - e),
            u = 1 / (i - r),
            d = 1 / (o - s),
            h = (t + e) * c,
            f = (i + r) * u;
          let p, _;
          if (a === ls) (p = (o + s) * d), (_ = -2 * d);
          else {
            if (2001 !== a)
              throw new Error(
                "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
                  a,
              );
            (p = s * d), (_ = -1 * d);
          }
          return (
            (l[0] = 2 * c),
            (l[4] = 0),
            (l[8] = 0),
            (l[12] = -h),
            (l[1] = 0),
            (l[5] = 2 * u),
            (l[9] = 0),
            (l[13] = -f),
            (l[2] = 0),
            (l[6] = 0),
            (l[10] = _),
            (l[14] = -p),
            (l[3] = 0),
            (l[7] = 0),
            (l[11] = 0),
            (l[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            i = e.elements;
          for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return (
            (e[t] = i[0]),
            (e[t + 1] = i[1]),
            (e[t + 2] = i[2]),
            (e[t + 3] = i[3]),
            (e[t + 4] = i[4]),
            (e[t + 5] = i[5]),
            (e[t + 6] = i[6]),
            (e[t + 7] = i[7]),
            (e[t + 8] = i[8]),
            (e[t + 9] = i[9]),
            (e[t + 10] = i[10]),
            (e[t + 11] = i[11]),
            (e[t + 12] = i[12]),
            (e[t + 13] = i[13]),
            (e[t + 14] = i[14]),
            (e[t + 15] = i[15]),
            e
          );
        }
      }
      const Dl = new D(),
        mr = new it(),
        Y8 = new D(0, 0, 0),
        Z8 = new D(1, 1, 1),
        js = new D(),
        Vf = new D(),
        Ai = new D(),
        fR = new it(),
        pR = new Di();
      let K8 = (() => {
        class n {
          constructor(t = 0, i = 0, r = 0, s = n.DEFAULT_ORDER) {
            (this.isEuler = !0),
              (this._x = t),
              (this._y = i),
              (this._z = r),
              (this._order = s);
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(t) {
            (this._order = t), this._onChangeCallback();
          }
          set(t, i, r, s = this._order) {
            return (
              (this._x = t),
              (this._y = i),
              (this._z = r),
              (this._order = s),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t, i = this._order, r = !0) {
            const s = t.elements,
              o = s[0],
              a = s[4],
              l = s[8],
              c = s[1],
              u = s[5],
              d = s[9],
              h = s[2],
              f = s[6],
              p = s[10];
            switch (i) {
              case "XYZ":
                (this._y = Math.asin(nn(l, -1, 1))),
                  Math.abs(l) < 0.9999999
                    ? ((this._x = Math.atan2(-d, p)),
                      (this._z = Math.atan2(-a, o)))
                    : ((this._x = Math.atan2(f, u)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-nn(d, -1, 1))),
                  Math.abs(d) < 0.9999999
                    ? ((this._y = Math.atan2(l, p)),
                      (this._z = Math.atan2(c, u)))
                    : ((this._y = Math.atan2(-h, o)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(nn(f, -1, 1))),
                  Math.abs(f) < 0.9999999
                    ? ((this._y = Math.atan2(-h, p)),
                      (this._z = Math.atan2(-a, u)))
                    : ((this._y = 0), (this._z = Math.atan2(c, o)));
                break;
              case "ZYX":
                (this._y = Math.asin(-nn(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._x = Math.atan2(f, p)),
                      (this._z = Math.atan2(c, o)))
                    : ((this._x = 0), (this._z = Math.atan2(-a, u)));
                break;
              case "YZX":
                (this._z = Math.asin(nn(c, -1, 1))),
                  Math.abs(c) < 0.9999999
                    ? ((this._x = Math.atan2(-d, u)),
                      (this._y = Math.atan2(-h, o)))
                    : ((this._x = 0), (this._y = Math.atan2(l, p)));
                break;
              case "XZY":
                (this._z = Math.asin(-nn(a, -1, 1))),
                  Math.abs(a) < 0.9999999
                    ? ((this._x = Math.atan2(f, u)),
                      (this._y = Math.atan2(l, o)))
                    : ((this._x = Math.atan2(-d, p)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                    i,
                );
            }
            return (
              (this._order = i), !0 === r && this._onChangeCallback(), this
            );
          }
          setFromQuaternion(t, i, r) {
            return (
              fR.makeRotationFromQuaternion(t),
              this.setFromRotationMatrix(fR, i, r)
            );
          }
          setFromVector3(t, i = this._order) {
            return this.set(t.x, t.y, t.z, i);
          }
          reorder(t) {
            return pR.setFromEuler(this), this.setFromQuaternion(pR, t);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._order === this._order
            );
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], i = 0) {
            return (
              (t[i] = this._x),
              (t[i + 1] = this._y),
              (t[i + 2] = this._z),
              (t[i + 3] = this._order),
              t
            );
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
          }
        }
        return (n.DEFAULT_ORDER = "XYZ"), n;
      })();
      class jy {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = ((1 << e) | 0) >>> 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return 0 != (this.mask & e.mask);
        }
        isEnabled(e) {
          return 0 != (this.mask & ((1 << e) | 0));
        }
      }
      let Q8 = 0;
      const mR = new D(),
        Al = new Di(),
        fs = new it(),
        Hf = new D(),
        Pu = new D(),
        J8 = new D(),
        e6 = new Di(),
        gR = new D(1, 0, 0),
        _R = new D(0, 1, 0),
        vR = new D(0, 0, 1),
        t6 = { type: "added" },
        yR = { type: "removed" };
      let Ii = (() => {
        class n extends vl {
          constructor() {
            super(),
              (this.isObject3D = !0),
              Object.defineProperty(this, "id", { value: Q8++ }),
              (this.uuid = Ti()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = n.DEFAULT_UP.clone());
            const t = new D(),
              i = new K8(),
              r = new Di(),
              s = new D(1, 1, 1);
            i._onChange(function o() {
              r.setFromEuler(i, !1);
            }),
              r._onChange(function a() {
                i.setFromQuaternion(r, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: t },
                rotation: { configurable: !0, enumerable: !0, value: i },
                quaternion: { configurable: !0, enumerable: !0, value: r },
                scale: { configurable: !0, enumerable: !0, value: s },
                modelViewMatrix: { value: new it() },
                normalMatrix: { value: new ut() },
              }),
              (this.matrix = new it()),
              (this.matrixWorld = new it()),
              (this.matrixAutoUpdate = n.DEFAULT_MATRIX_AUTO_UPDATE),
              (this.matrixWorldNeedsUpdate = !1),
              (this.matrixWorldAutoUpdate = n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
              (this.layers = new jy()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(t),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(t) {
            return this.quaternion.premultiply(t), this;
          }
          setRotationFromAxisAngle(t, i) {
            this.quaternion.setFromAxisAngle(t, i);
          }
          setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0);
          }
          setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t);
          }
          setRotationFromQuaternion(t) {
            this.quaternion.copy(t);
          }
          rotateOnAxis(t, i) {
            return (
              Al.setFromAxisAngle(t, i), this.quaternion.multiply(Al), this
            );
          }
          rotateOnWorldAxis(t, i) {
            return (
              Al.setFromAxisAngle(t, i), this.quaternion.premultiply(Al), this
            );
          }
          rotateX(t) {
            return this.rotateOnAxis(gR, t);
          }
          rotateY(t) {
            return this.rotateOnAxis(_R, t);
          }
          rotateZ(t) {
            return this.rotateOnAxis(vR, t);
          }
          translateOnAxis(t, i) {
            return (
              mR.copy(t).applyQuaternion(this.quaternion),
              this.position.add(mR.multiplyScalar(i)),
              this
            );
          }
          translateX(t) {
            return this.translateOnAxis(gR, t);
          }
          translateY(t) {
            return this.translateOnAxis(_R, t);
          }
          translateZ(t) {
            return this.translateOnAxis(vR, t);
          }
          localToWorld(t) {
            return (
              this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
            );
          }
          worldToLocal(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              t.applyMatrix4(fs.copy(this.matrixWorld).invert())
            );
          }
          lookAt(t, i, r) {
            t.isVector3 ? Hf.copy(t) : Hf.set(t, i, r);
            const s = this.parent;
            this.updateWorldMatrix(!0, !1),
              Pu.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? fs.lookAt(Pu, Hf, this.up)
                : fs.lookAt(Hf, Pu, this.up),
              this.quaternion.setFromRotationMatrix(fs),
              s &&
                (fs.extractRotation(s.matrixWorld),
                Al.setFromRotationMatrix(fs),
                this.quaternion.premultiply(Al.invert()));
          }
          add(t) {
            if (arguments.length > 1) {
              for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
              return this;
            }
            return t === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  t,
                ),
                this)
              : (t && t.isObject3D
                  ? (null !== t.parent && t.parent.remove(t),
                    (t.parent = this),
                    this.children.push(t),
                    t.dispatchEvent(t6))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      t,
                    ),
                this);
          }
          remove(t) {
            if (arguments.length > 1) {
              for (let r = 0; r < arguments.length; r++)
                this.remove(arguments[r]);
              return this;
            }
            const i = this.children.indexOf(t);
            return (
              -1 !== i &&
                ((t.parent = null),
                this.children.splice(i, 1),
                t.dispatchEvent(yR)),
              this
            );
          }
          removeFromParent() {
            const t = this.parent;
            return null !== t && t.remove(this), this;
          }
          clear() {
            for (let t = 0; t < this.children.length; t++) {
              const i = this.children[t];
              (i.parent = null), i.dispatchEvent(yR);
            }
            return (this.children.length = 0), this;
          }
          attach(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              fs.copy(this.matrixWorld).invert(),
              null !== t.parent &&
                (t.parent.updateWorldMatrix(!0, !1),
                fs.multiply(t.parent.matrixWorld)),
              t.applyMatrix4(fs),
              this.add(t),
              t.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(t) {
            return this.getObjectByProperty("id", t);
          }
          getObjectByName(t) {
            return this.getObjectByProperty("name", t);
          }
          getObjectByProperty(t, i) {
            if (this[t] === i) return this;
            for (let r = 0, s = this.children.length; r < s; r++) {
              const a = this.children[r].getObjectByProperty(t, i);
              if (void 0 !== a) return a;
            }
          }
          getObjectsByProperty(t, i) {
            let r = [];
            this[t] === i && r.push(this);
            for (let s = 0, o = this.children.length; s < o; s++) {
              const a = this.children[s].getObjectsByProperty(t, i);
              a.length > 0 && (r = r.concat(a));
            }
            return r;
          }
          getWorldPosition(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              t.setFromMatrixPosition(this.matrixWorld)
            );
          }
          getWorldQuaternion(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Pu, t, J8),
              t
            );
          }
          getWorldScale(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Pu, e6, t),
              t
            );
          }
          getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const i = this.matrixWorld.elements;
            return t.set(i[8], i[9], i[10]).normalize();
          }
          raycast() {}
          traverse(t) {
            t(this);
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++) i[r].traverse(t);
          }
          traverseVisible(t) {
            if (!1 === this.visible) return;
            t(this);
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++) i[r].traverseVisible(t);
          }
          traverseAncestors(t) {
            const i = this.parent;
            null !== i && (t(i), i.traverseAncestors(t));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || t) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix,
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (t = !0));
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++) {
              const o = i[r];
              (!0 === o.matrixWorldAutoUpdate || !0 === t) &&
                o.updateMatrixWorld(t);
            }
          }
          updateWorldMatrix(t, i) {
            const r = this.parent;
            if (
              (!0 === t &&
                null !== r &&
                !0 === r.matrixWorldAutoUpdate &&
                r.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix,
                  ),
              !0 === i)
            ) {
              const s = this.children;
              for (let o = 0, a = s.length; o < a; o++) {
                const l = s[o];
                !0 === l.matrixWorldAutoUpdate && l.updateWorldMatrix(!1, !0);
              }
            }
          }
          toJSON(t) {
            const i = void 0 === t || "string" == typeof t,
              r = {};
            i &&
              ((t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {},
              }),
              (r.metadata = {
                version: 4.6,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            const s = {};
            function o(l, c) {
              return void 0 === l[c.uuid] && (l[c.uuid] = c.toJSON(t)), c.uuid;
            }
            if (
              ((s.uuid = this.uuid),
              (s.type = this.type),
              "" !== this.name && (s.name = this.name),
              !0 === this.castShadow && (s.castShadow = !0),
              !0 === this.receiveShadow && (s.receiveShadow = !0),
              !1 === this.visible && (s.visible = !1),
              !1 === this.frustumCulled && (s.frustumCulled = !1),
              0 !== this.renderOrder && (s.renderOrder = this.renderOrder),
              Object.keys(this.userData).length > 0 &&
                (s.userData = this.userData),
              (s.layers = this.layers.mask),
              (s.matrix = this.matrix.toArray()),
              (s.up = this.up.toArray()),
              !1 === this.matrixAutoUpdate && (s.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((s.type = "InstancedMesh"),
                (s.count = this.count),
                (s.instanceMatrix = this.instanceMatrix.toJSON()),
                null !== this.instanceColor &&
                  (s.instanceColor = this.instanceColor.toJSON())),
              this.isScene)
            )
              this.background &&
                (this.background.isColor
                  ? (s.background = this.background.toJSON())
                  : this.background.isTexture &&
                    (s.background = this.background.toJSON(t).uuid)),
                this.environment &&
                  this.environment.isTexture &&
                  !0 !== this.environment.isRenderTargetTexture &&
                  (s.environment = this.environment.toJSON(t).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
              s.geometry = o(t.geometries, this.geometry);
              const l = this.geometry.parameters;
              if (void 0 !== l && void 0 !== l.shapes) {
                const c = l.shapes;
                if (Array.isArray(c))
                  for (let u = 0, d = c.length; u < d; u++) o(t.shapes, c[u]);
                else o(t.shapes, c);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((s.bindMode = this.bindMode),
                (s.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (o(t.skeletons, this.skeleton),
                  (s.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            )
              if (Array.isArray(this.material)) {
                const l = [];
                for (let c = 0, u = this.material.length; c < u; c++)
                  l.push(o(t.materials, this.material[c]));
                s.material = l;
              } else s.material = o(t.materials, this.material);
            if (this.children.length > 0) {
              s.children = [];
              for (let l = 0; l < this.children.length; l++)
                s.children.push(this.children[l].toJSON(t).object);
            }
            if (this.animations.length > 0) {
              s.animations = [];
              for (let l = 0; l < this.animations.length; l++)
                s.animations.push(o(t.animations, this.animations[l]));
            }
            if (i) {
              const l = a(t.geometries),
                c = a(t.materials),
                u = a(t.textures),
                d = a(t.images),
                h = a(t.shapes),
                f = a(t.skeletons),
                p = a(t.animations),
                _ = a(t.nodes);
              l.length > 0 && (r.geometries = l),
                c.length > 0 && (r.materials = c),
                u.length > 0 && (r.textures = u),
                d.length > 0 && (r.images = d),
                h.length > 0 && (r.shapes = h),
                f.length > 0 && (r.skeletons = f),
                p.length > 0 && (r.animations = p),
                _.length > 0 && (r.nodes = _);
            }
            return (r.object = s), r;
            function a(l) {
              const c = [];
              for (const u in l) {
                const d = l[u];
                delete d.metadata, c.push(d);
              }
              return c;
            }
          }
          clone(t) {
            return new this.constructor().copy(this, t);
          }
          copy(t, i = !0) {
            if (
              ((this.name = t.name),
              this.up.copy(t.up),
              this.position.copy(t.position),
              (this.rotation.order = t.rotation.order),
              this.quaternion.copy(t.quaternion),
              this.scale.copy(t.scale),
              this.matrix.copy(t.matrix),
              this.matrixWorld.copy(t.matrixWorld),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
              (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
              (this.layers.mask = t.layers.mask),
              (this.visible = t.visible),
              (this.castShadow = t.castShadow),
              (this.receiveShadow = t.receiveShadow),
              (this.frustumCulled = t.frustumCulled),
              (this.renderOrder = t.renderOrder),
              (this.animations = t.animations.slice()),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              !0 === i)
            )
              for (let r = 0; r < t.children.length; r++)
                this.add(t.children[r].clone());
            return this;
          }
        }
        return (
          (n.DEFAULT_UP = new D(0, 1, 0)),
          (n.DEFAULT_MATRIX_AUTO_UPDATE = !0),
          (n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0),
          n
        );
      })();
      const gr = new D(),
        ps = new D(),
        qy = new D(),
        ms = new D(),
        Il = new D(),
        Rl = new D(),
        bR = new D(),
        Xy = new D(),
        Yy = new D(),
        Zy = new D();
      let zf = !1;
      class Ri {
        constructor(e = new D(), t = new D(), i = new D()) {
          (this.a = e), (this.b = t), (this.c = i);
        }
        static getNormal(e, t, i, r) {
          r.subVectors(i, t), gr.subVectors(e, t), r.cross(gr);
          const s = r.lengthSq();
          return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
        }
        static getBarycoord(e, t, i, r, s) {
          gr.subVectors(r, t), ps.subVectors(i, t), qy.subVectors(e, t);
          const o = gr.dot(gr),
            a = gr.dot(ps),
            l = gr.dot(qy),
            c = ps.dot(ps),
            u = ps.dot(qy),
            d = o * c - a * a;
          if (0 === d) return s.set(-2, -1, -1);
          const h = 1 / d,
            f = (c * l - a * u) * h,
            p = (o * u - a * l) * h;
          return s.set(1 - f - p, p, f);
        }
        static containsPoint(e, t, i, r) {
          return (
            this.getBarycoord(e, t, i, r, ms),
            ms.x >= 0 && ms.y >= 0 && ms.x + ms.y <= 1
          );
        }
        static getUV(e, t, i, r, s, o, a, l) {
          return (
            !1 === zf &&
              (console.warn(
                "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().",
              ),
              (zf = !0)),
            this.getInterpolation(e, t, i, r, s, o, a, l)
          );
        }
        static getInterpolation(e, t, i, r, s, o, a, l) {
          return (
            this.getBarycoord(e, t, i, r, ms),
            l.setScalar(0),
            l.addScaledVector(s, ms.x),
            l.addScaledVector(o, ms.y),
            l.addScaledVector(a, ms.z),
            l
          );
        }
        static isFrontFacing(e, t, i, r) {
          return (
            gr.subVectors(i, t), ps.subVectors(e, t), gr.cross(ps).dot(r) < 0
          );
        }
        set(e, t, i) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
        }
        setFromPointsAndIndices(e, t, i, r) {
          return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
        }
        setFromAttributeAndIndices(e, t, i, r) {
          return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, i),
            this.c.fromBufferAttribute(e, r),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            gr.subVectors(this.c, this.b),
            ps.subVectors(this.a, this.b),
            0.5 * gr.cross(ps).length()
          );
        }
        getMidpoint(e) {
          return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return Ri.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return Ri.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, i, r, s) {
          return (
            !1 === zf &&
              (console.warn(
                "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().",
              ),
              (zf = !0)),
            Ri.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
          );
        }
        getInterpolation(e, t, i, r, s) {
          return Ri.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
        }
        containsPoint(e) {
          return Ri.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return Ri.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const i = this.a,
            r = this.b,
            s = this.c;
          let o, a;
          Il.subVectors(r, i), Rl.subVectors(s, i), Xy.subVectors(e, i);
          const l = Il.dot(Xy),
            c = Rl.dot(Xy);
          if (l <= 0 && c <= 0) return t.copy(i);
          Yy.subVectors(e, r);
          const u = Il.dot(Yy),
            d = Rl.dot(Yy);
          if (u >= 0 && d <= u) return t.copy(r);
          const h = l * d - u * c;
          if (h <= 0 && l >= 0 && u <= 0)
            return (o = l / (l - u)), t.copy(i).addScaledVector(Il, o);
          Zy.subVectors(e, s);
          const f = Il.dot(Zy),
            p = Rl.dot(Zy);
          if (p >= 0 && f <= p) return t.copy(s);
          const _ = f * c - l * p;
          if (_ <= 0 && c >= 0 && p <= 0)
            return (a = c / (c - p)), t.copy(i).addScaledVector(Rl, a);
          const g = u * p - f * d;
          if (g <= 0 && d - u >= 0 && f - p >= 0)
            return (
              bR.subVectors(s, r),
              (a = (d - u) / (d - u + (f - p))),
              t.copy(r).addScaledVector(bR, a)
            );
          const m = 1 / (g + _ + h);
          return (
            (o = _ * m),
            (a = h * m),
            t.copy(i).addScaledVector(Il, o).addScaledVector(Rl, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let n6 = 0;
      class Ou extends vl {
        constructor() {
          super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, "id", { value: n6++ }),
            (this.uuid = Ti()),
            (this.name = ""),
            (this.type = "Material"),
            (this.blending = 1),
            (this.side = 0),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = 204),
            (this.blendDst = 205),
            (this.blendEquation = 100),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = 3),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = 7680),
            (this.stencilZFail = 7680),
            (this.stencilZPass = 7680),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (void 0 !== e)
            for (const t in e) {
              const i = e[t];
              if (void 0 === i) {
                console.warn(
                  `THREE.Material: parameter '${t}' has value of undefined.`,
                );
                continue;
              }
              const r = this[t];
              void 0 !== r
                ? r && r.isColor
                  ? r.set(i)
                  : r && r.isVector3 && i && i.isVector3
                  ? r.copy(i)
                  : (this[t] = i)
                : console.warn(
                    `THREE.Material: '${t}' is not a property of THREE.${this.type}.`,
                  );
            }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          t && (e = { textures: {}, images: {} });
          const i = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function r(s) {
            const o = [];
            for (const a in s) {
              const l = s[a];
              delete l.metadata, o.push(l);
            }
            return o;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            void 0 !== this.roughness && (i.roughness = this.roughness),
            void 0 !== this.metalness && (i.metalness = this.metalness),
            void 0 !== this.sheen && (i.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (i.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness &&
              (i.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (i.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (i.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (i.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (i.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (i.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (i.shininess = this.shininess),
            void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (i.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (i.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            void 0 !== this.iridescence && (i.iridescence = this.iridescence),
            void 0 !== this.iridescenceIOR &&
              (i.iridescenceIOR = this.iridescenceIOR),
            void 0 !== this.iridescenceThicknessRange &&
              (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
              this.iridescenceMap.isTexture &&
              (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap &&
              this.iridescenceThicknessMap.isTexture &&
              (i.iridescenceThicknessMap =
                this.iridescenceThicknessMap.toJSON(e).uuid),
            void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy),
            void 0 !== this.anisotropyRotation &&
              (i.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap &&
              this.anisotropyMap.isTexture &&
              (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (i.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (i.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((i.lightMap = this.lightMap.toJSON(e).uuid),
              (i.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((i.aoMap = this.aoMap.toJSON(e).uuid),
              (i.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
              (i.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((i.normalMap = this.normalMap.toJSON(e).uuid),
              (i.normalMapType = this.normalMapType),
              (i.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
              (i.displacementScale = this.displacementScale),
              (i.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (i.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (i.specularIntensityMap =
                this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((i.envMap = this.envMap.toJSON(e).uuid),
              void 0 !== this.combine && (i.combine = this.combine)),
            void 0 !== this.envMapIntensity &&
              (i.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (i.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (i.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (i.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.transmission &&
              (i.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            void 0 !== this.thickness && (i.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            void 0 !== this.attenuationDistance &&
              this.attenuationDistance !== 1 / 0 &&
              (i.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor &&
              (i.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (i.size = this.size),
            null !== this.shadowSide && (i.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (i.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (i.blending = this.blending),
            0 !== this.side && (i.side = this.side),
            this.vertexColors && (i.vertexColors = !0),
            this.opacity < 1 && (i.opacity = this.opacity),
            !0 === this.transparent && (i.transparent = this.transparent),
            (i.depthFunc = this.depthFunc),
            (i.depthTest = this.depthTest),
            (i.depthWrite = this.depthWrite),
            (i.colorWrite = this.colorWrite),
            (i.stencilWrite = this.stencilWrite),
            (i.stencilWriteMask = this.stencilWriteMask),
            (i.stencilFunc = this.stencilFunc),
            (i.stencilRef = this.stencilRef),
            (i.stencilFuncMask = this.stencilFuncMask),
            (i.stencilFail = this.stencilFail),
            (i.stencilZFail = this.stencilZFail),
            (i.stencilZPass = this.stencilZPass),
            void 0 !== this.rotation &&
              0 !== this.rotation &&
              (i.rotation = this.rotation),
            !0 === this.polygonOffset && (i.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (i.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (i.polygonOffsetUnits = this.polygonOffsetUnits),
            void 0 !== this.linewidth &&
              1 !== this.linewidth &&
              (i.linewidth = this.linewidth),
            void 0 !== this.dashSize && (i.dashSize = this.dashSize),
            void 0 !== this.gapSize && (i.gapSize = this.gapSize),
            void 0 !== this.scale && (i.scale = this.scale),
            !0 === this.dithering && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            !0 === this.alphaHash && (i.alphaHash = this.alphaHash),
            !0 === this.alphaToCoverage &&
              (i.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha &&
              (i.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.forceSinglePass &&
              (i.forceSinglePass = this.forceSinglePass),
            !0 === this.wireframe && (i.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (i.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (i.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (i.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (i.flatShading = this.flatShading),
            !1 === this.visible && (i.visible = !1),
            !1 === this.toneMapped && (i.toneMapped = !1),
            !1 === this.fog && (i.fog = !1),
            Object.keys(this.userData).length > 0 &&
              (i.userData = this.userData),
            t)
          ) {
            const s = r(e.textures),
              o = r(e.images);
            s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let i = null;
          if (null !== t) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
          }
          return (
            (this.clippingPlanes = i),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaHash = e.alphaHash),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.forceSinglePass = e.forceSinglePass),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
      }
      const MR = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        _r = { h: 0, s: 0, l: 0 },
        Gf = { h: 0, s: 0, l: 0 };
      function Ky(n, e, t) {
        return (
          t < 0 && (t += 1),
          t > 1 && (t -= 1),
          t < 1 / 6
            ? n + 6 * (e - n) * t
            : t < 0.5
            ? e
            : t < 2 / 3
            ? n + 6 * (e - n) * (2 / 3 - t)
            : n
        );
      }
      class Ce {
        constructor(e, t, i) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            this.set(e, t, i)
          );
        }
        set(e, t, i) {
          if (void 0 === t && void 0 === i) {
            const r = e;
            r && r.isColor
              ? this.copy(r)
              : "number" == typeof r
              ? this.setHex(r)
              : "string" == typeof r && this.setStyle(r);
          } else this.setRGB(e, t, i);
          return this;
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e, t = rt) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (255 & e) / 255),
            pr.toWorkingColorSpace(this, t),
            this
          );
        }
        setRGB(e, t, i, r = pr.workingColorSpace) {
          return (
            (this.r = e),
            (this.g = t),
            (this.b = i),
            pr.toWorkingColorSpace(this, r),
            this
          );
        }
        setHSL(e, t, i, r = pr.workingColorSpace) {
          if (
            ((e = (function Ny(n, e) {
              return ((n % e) + e) % e;
            })(e, 1)),
            (t = nn(t, 0, 1)),
            (i = nn(i, 0, 1)),
            0 === t)
          )
            this.r = this.g = this.b = i;
          else {
            const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
              o = 2 * i - s;
            (this.r = Ky(o, s, e + 1 / 3)),
              (this.g = Ky(o, s, e)),
              (this.b = Ky(o, s, e - 1 / 3));
          }
          return pr.toWorkingColorSpace(this, r), this;
        }
        setStyle(e, t = rt) {
          function i(s) {
            void 0 !== s &&
              parseFloat(s) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored.",
              );
          }
          let r;
          if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
            let s;
            const a = r[2];
            switch (r[1]) {
              case "rgb":
              case "rgba":
                if (
                  (s =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a,
                    ))
                )
                  return (
                    i(s[4]),
                    this.setRGB(
                      Math.min(255, parseInt(s[1], 10)) / 255,
                      Math.min(255, parseInt(s[2], 10)) / 255,
                      Math.min(255, parseInt(s[3], 10)) / 255,
                      t,
                    )
                  );
                if (
                  (s =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a,
                    ))
                )
                  return (
                    i(s[4]),
                    this.setRGB(
                      Math.min(100, parseInt(s[1], 10)) / 100,
                      Math.min(100, parseInt(s[2], 10)) / 100,
                      Math.min(100, parseInt(s[3], 10)) / 100,
                      t,
                    )
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (s =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a,
                    ))
                )
                  return (
                    i(s[4]),
                    this.setHSL(
                      parseFloat(s[1]) / 360,
                      parseFloat(s[2]) / 100,
                      parseFloat(s[3]) / 100,
                      t,
                    )
                  );
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + e);
            }
          } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const s = r[1],
              o = s.length;
            if (3 === o)
              return this.setRGB(
                parseInt(s.charAt(0), 16) / 15,
                parseInt(s.charAt(1), 16) / 15,
                parseInt(s.charAt(2), 16) / 15,
                t,
              );
            if (6 === o) return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e);
          } else if (e && e.length > 0) return this.setColorName(e, t);
          return this;
        }
        setColorName(e, t = rt) {
          const i = MR[e.toLowerCase()];
          return (
            void 0 !== i
              ? this.setHex(i, t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = Ml(e.r)), (this.g = Ml(e.g)), (this.b = Ml(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = ky(e.r)), (this.g = ky(e.g)), (this.b = ky(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = rt) {
          return (
            pr.fromWorkingColorSpace($n.copy(this), e),
            65536 * Math.round(nn(255 * $n.r, 0, 255)) +
              256 * Math.round(nn(255 * $n.g, 0, 255)) +
              Math.round(nn(255 * $n.b, 0, 255))
          );
        }
        getHexString(e = rt) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = pr.workingColorSpace) {
          pr.fromWorkingColorSpace($n.copy(this), t);
          const i = $n.r,
            r = $n.g,
            s = $n.b,
            o = Math.max(i, r, s),
            a = Math.min(i, r, s);
          let l, c;
          const u = (a + o) / 2;
          if (a === o) (l = 0), (c = 0);
          else {
            const d = o - a;
            switch (((c = u <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
              case i:
                l = (r - s) / d + (r < s ? 6 : 0);
                break;
              case r:
                l = (s - i) / d + 2;
                break;
              case s:
                l = (i - r) / d + 4;
            }
            l /= 6;
          }
          return (e.h = l), (e.s = c), (e.l = u), e;
        }
        getRGB(e, t = pr.workingColorSpace) {
          return (
            pr.fromWorkingColorSpace($n.copy(this), t),
            (e.r = $n.r),
            (e.g = $n.g),
            (e.b = $n.b),
            e
          );
        }
        getStyle(e = rt) {
          pr.fromWorkingColorSpace($n.copy(this), e);
          const t = $n.r,
            i = $n.g,
            r = $n.b;
          return e !== rt
            ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
            : `rgb(${Math.round(255 * t)},${Math.round(255 * i)},${Math.round(
                255 * r,
              )})`;
        }
        offsetHSL(e, t, i) {
          return (
            this.getHSL(_r),
            (_r.h += e),
            (_r.s += t),
            (_r.l += i),
            this.setHSL(_r.h, _r.s, _r.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, i) {
          return (
            (this.r = e.r + (t.r - e.r) * i),
            (this.g = e.g + (t.g - e.g) * i),
            (this.b = e.b + (t.b - e.b) * i),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(_r), e.getHSL(Gf);
          const i = xu(_r.h, Gf.h, t),
            r = xu(_r.s, Gf.s, t),
            s = xu(_r.l, Gf.l, t);
          return this.setHSL(i, r, s), this;
        }
        setFromVector3(e) {
          return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
        }
        applyMatrix3(e) {
          const t = this.r,
            i = this.g,
            r = this.b,
            s = e.elements;
          return (
            (this.r = s[0] * t + s[3] * i + s[6] * r),
            (this.g = s[1] * t + s[4] * i + s[7] * r),
            (this.b = s[2] * t + s[5] * i + s[8] * r),
            this
          );
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const $n = new Ce();
      Ce.NAMES = MR;
      class qs extends Ou {
        constructor(e) {
          super(),
            (this.isMeshBasicMaterial = !0),
            (this.type = "MeshBasicMaterial"),
            (this.color = new Ce(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Ef),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const _n = new D(),
        Wf = new oe();
      class Pn {
        constructor(e, t, i = !1) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array.",
            );
          (this.isBufferAttribute = !0),
            (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = void 0 !== e ? e.length / t : 0),
            (this.normalized = i),
            (this.usage = 35044),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.gpuType = as),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            (this.gpuType = e.gpuType),
            this
          );
        }
        copyAt(e, t, i) {
          (e *= this.itemSize), (i *= t.itemSize);
          for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        applyMatrix3(e) {
          if (2 === this.itemSize)
            for (let t = 0, i = this.count; t < i; t++)
              Wf.fromBufferAttribute(this, t),
                Wf.applyMatrix3(e),
                this.setXY(t, Wf.x, Wf.y);
          else if (3 === this.itemSize)
            for (let t = 0, i = this.count; t < i; t++)
              _n.fromBufferAttribute(this, t),
                _n.applyMatrix3(e),
                this.setXYZ(t, _n.x, _n.y, _n.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.count; t < i; t++)
            _n.fromBufferAttribute(this, t),
              _n.applyMatrix4(e),
              this.setXYZ(t, _n.x, _n.y, _n.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++)
            _n.fromBufferAttribute(this, t),
              _n.applyNormalMatrix(e),
              this.setXYZ(t, _n.x, _n.y, _n.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++)
            _n.fromBufferAttribute(this, t),
              _n.transformDirection(e),
              this.setXYZ(t, _n.x, _n.y, _n.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getComponent(e, t) {
          let i = this.array[e * this.itemSize + t];
          return this.normalized && (i = gi(i, this.array)), i;
        }
        setComponent(e, t, i) {
          return (
            this.normalized && (i = st(i, this.array)),
            (this.array[e * this.itemSize + t] = i),
            this
          );
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = gi(t, this.array)), t;
        }
        setX(e, t) {
          return (
            this.normalized && (t = st(t, this.array)),
            (this.array[e * this.itemSize] = t),
            this
          );
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = gi(t, this.array)), t;
        }
        setY(e, t) {
          return (
            this.normalized && (t = st(t, this.array)),
            (this.array[e * this.itemSize + 1] = t),
            this
          );
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = gi(t, this.array)), t;
        }
        setZ(e, t) {
          return (
            this.normalized && (t = st(t, this.array)),
            (this.array[e * this.itemSize + 2] = t),
            this
          );
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = gi(t, this.array)), t;
        }
        setW(e, t) {
          return (
            this.normalized && (t = st(t, this.array)),
            (this.array[e * this.itemSize + 3] = t),
            this
          );
        }
        setXY(e, t, i) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = st(t, this.array)), (i = st(i, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            this
          );
        }
        setXYZ(e, t, i, r) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = st(t, this.array)),
              (i = st(i, this.array)),
              (r = st(r, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            (this.array[e + 2] = r),
            this
          );
        }
        setXYZW(e, t, i, r, s) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = st(t, this.array)),
              (i = st(i, this.array)),
              (r = st(r, this.array)),
              (s = st(s, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            (this.array[e + 2] = r),
            (this.array[e + 3] = s),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (e.name = this.name),
            35044 !== this.usage && (e.usage = this.usage),
            (0 !== this.updateRange.offset || -1 !== this.updateRange.count) &&
              (e.updateRange = this.updateRange),
            e
          );
        }
      }
      class SR extends Pn {
        constructor(e, t, i) {
          super(new Uint16Array(e), t, i);
        }
      }
      class wR extends Pn {
        constructor(e, t, i) {
          super(new Uint32Array(e), t, i);
        }
      }
      class Ie extends Pn {
        constructor(e, t, i) {
          super(new Float32Array(e), t, i);
        }
      }
      let r6 = 0;
      const Qi = new it(),
        Qy = new Ii(),
        Pl = new D(),
        Pi = new cs(),
        Lu = new cs(),
        On = new D();
      class ht extends vl {
        constructor() {
          super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, "id", { value: r6++ }),
            (this.uuid = Ti()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            (this.index = Array.isArray(e) ? new (lR(e) ? wR : SR)(e, 1) : e),
            this
          );
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return void 0 !== this.attributes[e];
        }
        addGroup(e, t, i = 0) {
          this.groups.push({ start: e, count: t, materialIndex: i });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const i = this.attributes.normal;
          if (void 0 !== i) {
            const s = new ut().getNormalMatrix(e);
            i.applyNormalMatrix(s), (i.needsUpdate = !0);
          }
          const r = this.attributes.tangent;
          return (
            void 0 !== r && (r.transformDirection(e), (r.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return Qi.makeRotationFromQuaternion(e), this.applyMatrix4(Qi), this;
        }
        rotateX(e) {
          return Qi.makeRotationX(e), this.applyMatrix4(Qi), this;
        }
        rotateY(e) {
          return Qi.makeRotationY(e), this.applyMatrix4(Qi), this;
        }
        rotateZ(e) {
          return Qi.makeRotationZ(e), this.applyMatrix4(Qi), this;
        }
        translate(e, t, i) {
          return Qi.makeTranslation(e, t, i), this.applyMatrix4(Qi), this;
        }
        scale(e, t, i) {
          return Qi.makeScale(e, t, i), this.applyMatrix4(Qi), this;
        }
        lookAt(e) {
          return (
            Qy.lookAt(e), Qy.updateMatrix(), this.applyMatrix4(Qy.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Pl).negate(),
            this.translate(Pl.x, Pl.y, Pl.z),
            this
          );
        }
        setFromPoints(e) {
          const t = [];
          for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0);
          }
          return this.setAttribute("position", new Ie(t, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new cs());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this,
              ),
              void this.boundingBox.set(
                new D(-1 / 0, -1 / 0, -1 / 0),
                new D(1 / 0, 1 / 0, 1 / 0),
              )
            );
          if (void 0 !== e) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let i = 0, r = t.length; i < r; i++)
                Pi.setFromBufferAttribute(t[i]),
                  this.morphTargetsRelative
                    ? (On.addVectors(this.boundingBox.min, Pi.min),
                      this.boundingBox.expandByPoint(On),
                      On.addVectors(this.boundingBox.max, Pi.max),
                      this.boundingBox.expandByPoint(On))
                    : (this.boundingBox.expandByPoint(Pi.min),
                      this.boundingBox.expandByPoint(Pi.max));
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this,
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Lr());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this,
              ),
              void this.boundingSphere.set(new D(), 1 / 0)
            );
          if (e) {
            const i = this.boundingSphere.center;
            if ((Pi.setFromBufferAttribute(e), t))
              for (let s = 0, o = t.length; s < o; s++)
                Lu.setFromBufferAttribute(t[s]),
                  this.morphTargetsRelative
                    ? (On.addVectors(Pi.min, Lu.min),
                      Pi.expandByPoint(On),
                      On.addVectors(Pi.max, Lu.max),
                      Pi.expandByPoint(On))
                    : (Pi.expandByPoint(Lu.min), Pi.expandByPoint(Lu.max));
            Pi.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
              On.fromBufferAttribute(e, s),
                (r = Math.max(r, i.distanceToSquared(On)));
            if (t)
              for (let s = 0, o = t.length; s < o; s++) {
                const a = t[s],
                  l = this.morphTargetsRelative;
                for (let c = 0, u = a.count; c < u; c++)
                  On.fromBufferAttribute(a, c),
                    l && (Pl.fromBufferAttribute(e, c), On.add(Pl)),
                    (r = Math.max(r, i.distanceToSquared(On)));
              }
            (this.boundingSphere.radius = Math.sqrt(r)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this,
                );
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            null === e ||
            void 0 === t.position ||
            void 0 === t.normal ||
            void 0 === t.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
            );
          const i = e.array,
            r = t.position.array,
            s = t.normal.array,
            o = t.uv.array,
            a = r.length / 3;
          !1 === this.hasAttribute("tangent") &&
            this.setAttribute("tangent", new Pn(new Float32Array(4 * a), 4));
          const l = this.getAttribute("tangent").array,
            c = [],
            u = [];
          for (let C = 0; C < a; C++) (c[C] = new D()), (u[C] = new D());
          const d = new D(),
            h = new D(),
            f = new D(),
            p = new oe(),
            _ = new oe(),
            g = new oe(),
            m = new D(),
            y = new D();
          function v(C, $, ie) {
            d.fromArray(r, 3 * C),
              h.fromArray(r, 3 * $),
              f.fromArray(r, 3 * ie),
              p.fromArray(o, 2 * C),
              _.fromArray(o, 2 * $),
              g.fromArray(o, 2 * ie),
              h.sub(d),
              f.sub(d),
              _.sub(p),
              g.sub(p);
            const V = 1 / (_.x * g.y - g.x * _.y);
            isFinite(V) &&
              (m
                .copy(h)
                .multiplyScalar(g.y)
                .addScaledVector(f, -_.y)
                .multiplyScalar(V),
              y
                .copy(f)
                .multiplyScalar(_.x)
                .addScaledVector(h, -g.x)
                .multiplyScalar(V),
              c[C].add(m),
              c[$].add(m),
              c[ie].add(m),
              u[C].add(y),
              u[$].add(y),
              u[ie].add(y));
          }
          let b = this.groups;
          0 === b.length && (b = [{ start: 0, count: i.length }]);
          for (let C = 0, $ = b.length; C < $; ++C) {
            const ie = b[C],
              V = ie.start;
            for (let W = V, F = V + ie.count; W < F; W += 3)
              v(i[W + 0], i[W + 1], i[W + 2]);
          }
          const S = new D(),
            E = new D(),
            x = new D(),
            P = new D();
          function M(C) {
            x.fromArray(s, 3 * C), P.copy(x);
            const $ = c[C];
            S.copy($),
              S.sub(x.multiplyScalar(x.dot($))).normalize(),
              E.crossVectors(P, $);
            const V = E.dot(u[C]) < 0 ? -1 : 1;
            (l[4 * C] = S.x),
              (l[4 * C + 1] = S.y),
              (l[4 * C + 2] = S.z),
              (l[4 * C + 3] = V);
          }
          for (let C = 0, $ = b.length; C < $; ++C) {
            const ie = b[C],
              V = ie.start;
            for (let W = V, F = V + ie.count; W < F; W += 3)
              M(i[W + 0]), M(i[W + 1]), M(i[W + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (void 0 !== t) {
            let i = this.getAttribute("normal");
            if (void 0 === i)
              (i = new Pn(new Float32Array(3 * t.count), 3)),
                this.setAttribute("normal", i);
            else for (let h = 0, f = i.count; h < f; h++) i.setXYZ(h, 0, 0, 0);
            const r = new D(),
              s = new D(),
              o = new D(),
              a = new D(),
              l = new D(),
              c = new D(),
              u = new D(),
              d = new D();
            if (e)
              for (let h = 0, f = e.count; h < f; h += 3) {
                const p = e.getX(h + 0),
                  _ = e.getX(h + 1),
                  g = e.getX(h + 2);
                r.fromBufferAttribute(t, p),
                  s.fromBufferAttribute(t, _),
                  o.fromBufferAttribute(t, g),
                  u.subVectors(o, s),
                  d.subVectors(r, s),
                  u.cross(d),
                  a.fromBufferAttribute(i, p),
                  l.fromBufferAttribute(i, _),
                  c.fromBufferAttribute(i, g),
                  a.add(u),
                  l.add(u),
                  c.add(u),
                  i.setXYZ(p, a.x, a.y, a.z),
                  i.setXYZ(_, l.x, l.y, l.z),
                  i.setXYZ(g, c.x, c.y, c.z);
              }
            else
              for (let h = 0, f = t.count; h < f; h += 3)
                r.fromBufferAttribute(t, h + 0),
                  s.fromBufferAttribute(t, h + 1),
                  o.fromBufferAttribute(t, h + 2),
                  u.subVectors(o, s),
                  d.subVectors(r, s),
                  u.cross(d),
                  i.setXYZ(h + 0, u.x, u.y, u.z),
                  i.setXYZ(h + 1, u.x, u.y, u.z),
                  i.setXYZ(h + 2, u.x, u.y, u.z);
            this.normalizeNormals(), (i.needsUpdate = !0);
          }
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, i = e.count; t < i; t++)
            On.fromBufferAttribute(e, t),
              On.normalize(),
              e.setXYZ(t, On.x, On.y, On.z);
        }
        toNonIndexed() {
          function e(a, l) {
            const c = a.array,
              u = a.itemSize,
              d = a.normalized,
              h = new c.constructor(l.length * u);
            let f = 0,
              p = 0;
            for (let _ = 0, g = l.length; _ < g; _++) {
              f = a.isInterleavedBufferAttribute
                ? l[_] * a.data.stride + a.offset
                : l[_] * u;
              for (let m = 0; m < u; m++) h[p++] = c[f++];
            }
            return new Pn(h, u, d);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
              ),
              this
            );
          const t = new ht(),
            i = this.index.array,
            r = this.attributes;
          for (const a in r) {
            const c = e(r[a], i);
            t.setAttribute(a, c);
          }
          const s = this.morphAttributes;
          for (const a in s) {
            const l = [],
              c = s[a];
            for (let u = 0, d = c.length; u < d; u++) {
              const f = e(c[u], i);
              l.push(f);
            }
            t.morphAttributes[a] = l;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const o = this.groups;
          for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const l = this.parameters;
            for (const c in l) void 0 !== l[c] && (e[c] = l[c]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          null !== t &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const i = this.attributes;
          for (const l in i) e.data.attributes[l] = i[l].toJSON(e.data);
          const r = {};
          let s = !1;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
              u = [];
            for (let d = 0, h = c.length; d < h; d++)
              u.push(c[d].toJSON(e.data));
            u.length > 0 && ((r[l] = u), (s = !0));
          }
          s &&
            ((e.data.morphAttributes = r),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const o = this.groups;
          o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
          const a = this.boundingSphere;
          return (
            null !== a &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const i = e.index;
          null !== i && this.setIndex(i.clone(t));
          const r = e.attributes;
          for (const c in r) this.setAttribute(c, r[c].clone(t));
          const s = e.morphAttributes;
          for (const c in s) {
            const u = [],
              d = s[c];
            for (let h = 0, f = d.length; h < f; h++) u.push(d[h].clone(t));
            this.morphAttributes[c] = u;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const o = e.groups;
          for (let c = 0, u = o.length; c < u; c++) {
            const d = o[c];
            this.addGroup(d.start, d.count, d.materialIndex);
          }
          const a = e.boundingBox;
          null !== a && (this.boundingBox = a.clone());
          const l = e.boundingSphere;
          return (
            null !== l && (this.boundingSphere = l.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      const ER = new it(),
        Ho = new Ru(),
        $f = new Lr(),
        CR = new D(),
        Ol = new D(),
        Nl = new D(),
        Ll = new D(),
        Jy = new D(),
        jf = new D(),
        qf = new oe(),
        Xf = new oe(),
        Yf = new oe(),
        xR = new D(),
        TR = new D(),
        DR = new D(),
        Zf = new D(),
        Kf = new D();
      class ti extends Ii {
        constructor(e = new ht(), t = new qs()) {
          super(),
            (this.isMesh = !0),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            void 0 !== e.morphTargetInfluences &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary,
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes,
            i = Object.keys(t);
          if (i.length > 0) {
            const r = t[i[0]];
            if (void 0 !== r) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s].name || String(s);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[a] = s);
              }
            }
          }
        }
        getVertexPosition(e, t) {
          const i = this.geometry,
            s = i.morphAttributes.position,
            o = i.morphTargetsRelative;
          t.fromBufferAttribute(i.attributes.position, e);
          const a = this.morphTargetInfluences;
          if (s && a) {
            jf.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
              const u = a[l];
              0 !== u &&
                (Jy.fromBufferAttribute(s[l], e),
                jf.addScaledVector(o ? Jy : Jy.sub(t), u));
            }
            t.add(jf);
          }
          return t;
        }
        raycast(e, t) {
          const i = this.geometry,
            s = this.matrixWorld;
          void 0 !== this.material &&
            (null === i.boundingSphere && i.computeBoundingSphere(),
            $f.copy(i.boundingSphere),
            $f.applyMatrix4(s),
            Ho.copy(e.ray).recast(e.near),
            (!1 !== $f.containsPoint(Ho.origin) ||
              !(
                null === Ho.intersectSphere($f, CR) ||
                Ho.origin.distanceToSquared(CR) > (e.far - e.near) ** 2
              )) &&
              (ER.copy(s).invert(),
              Ho.copy(e.ray).applyMatrix4(ER),
              (null === i.boundingBox ||
                !1 !== Ho.intersectsBox(i.boundingBox)) &&
                this._computeIntersections(e, t, Ho)));
        }
        _computeIntersections(e, t, i) {
          let r;
          const s = this.geometry,
            o = this.material,
            a = s.index,
            l = s.attributes.position,
            c = s.attributes.uv,
            u = s.attributes.uv1,
            d = s.attributes.normal,
            h = s.groups,
            f = s.drawRange;
          if (null !== a)
            if (Array.isArray(o))
              for (let p = 0, _ = h.length; p < _; p++) {
                const g = h[p],
                  m = o[g.materialIndex];
                for (
                  let b = Math.max(g.start, f.start),
                    S = Math.min(
                      a.count,
                      Math.min(g.start + g.count, f.start + f.count),
                    );
                  b < S;
                  b += 3
                )
                  (r = Qf(
                    this,
                    m,
                    e,
                    i,
                    c,
                    u,
                    d,
                    a.getX(b),
                    a.getX(b + 1),
                    a.getX(b + 2),
                  )),
                    r &&
                      ((r.faceIndex = Math.floor(b / 3)),
                      (r.face.materialIndex = g.materialIndex),
                      t.push(r));
              }
            else
              for (
                let g = Math.max(0, f.start),
                  m = Math.min(a.count, f.start + f.count);
                g < m;
                g += 3
              )
                (r = Qf(
                  this,
                  o,
                  e,
                  i,
                  c,
                  u,
                  d,
                  a.getX(g),
                  a.getX(g + 1),
                  a.getX(g + 2),
                )),
                  r && ((r.faceIndex = Math.floor(g / 3)), t.push(r));
          else if (void 0 !== l)
            if (Array.isArray(o))
              for (let p = 0, _ = h.length; p < _; p++) {
                const g = h[p],
                  m = o[g.materialIndex];
                for (
                  let b = Math.max(g.start, f.start),
                    S = Math.min(
                      l.count,
                      Math.min(g.start + g.count, f.start + f.count),
                    );
                  b < S;
                  b += 3
                )
                  (r = Qf(this, m, e, i, c, u, d, b, b + 1, b + 2)),
                    r &&
                      ((r.faceIndex = Math.floor(b / 3)),
                      (r.face.materialIndex = g.materialIndex),
                      t.push(r));
              }
            else
              for (
                let g = Math.max(0, f.start),
                  m = Math.min(l.count, f.start + f.count);
                g < m;
                g += 3
              )
                (r = Qf(this, o, e, i, c, u, d, g, g + 1, g + 2)),
                  r && ((r.faceIndex = Math.floor(g / 3)), t.push(r));
        }
      }
      function Qf(n, e, t, i, r, s, o, a, l, c) {
        n.getVertexPosition(a, Ol),
          n.getVertexPosition(l, Nl),
          n.getVertexPosition(c, Ll);
        const u = (function s6(n, e, t, i, r, s, o, a) {
          let l;
          if (
            ((l =
              1 === e.side
                ? i.intersectTriangle(o, s, r, !0, a)
                : i.intersectTriangle(r, s, o, 0 === e.side, a)),
            null === l)
          )
            return null;
          Kf.copy(a), Kf.applyMatrix4(n.matrixWorld);
          const c = t.ray.origin.distanceTo(Kf);
          return c < t.near || c > t.far
            ? null
            : { distance: c, point: Kf.clone(), object: n };
        })(n, e, t, i, Ol, Nl, Ll, Zf);
        if (u) {
          r &&
            (qf.fromBufferAttribute(r, a),
            Xf.fromBufferAttribute(r, l),
            Yf.fromBufferAttribute(r, c),
            (u.uv = Ri.getInterpolation(Zf, Ol, Nl, Ll, qf, Xf, Yf, new oe()))),
            s &&
              (qf.fromBufferAttribute(s, a),
              Xf.fromBufferAttribute(s, l),
              Yf.fromBufferAttribute(s, c),
              (u.uv1 = Ri.getInterpolation(
                Zf,
                Ol,
                Nl,
                Ll,
                qf,
                Xf,
                Yf,
                new oe(),
              )),
              (u.uv2 = u.uv1)),
            o &&
              (xR.fromBufferAttribute(o, a),
              TR.fromBufferAttribute(o, l),
              DR.fromBufferAttribute(o, c),
              (u.normal = Ri.getInterpolation(
                Zf,
                Ol,
                Nl,
                Ll,
                xR,
                TR,
                DR,
                new D(),
              )),
              u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
          const d = { a, b: l, c, normal: new D(), materialIndex: 0 };
          Ri.getNormal(Ol, Nl, Ll, d.normal), (u.face = d);
        }
        return u;
      }
      class zo extends ht {
        constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: i,
              widthSegments: r,
              heightSegments: s,
              depthSegments: o,
            });
          const a = this;
          (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
          const l = [],
            c = [],
            u = [],
            d = [];
          let h = 0,
            f = 0;
          function p(_, g, m, y, v, b, S, E, x, P, M) {
            const C = b / x,
              $ = S / P,
              ie = b / 2,
              V = S / 2,
              z = E / 2,
              W = x + 1,
              F = P + 1;
            let N = 0,
              k = 0;
            const q = new D();
            for (let ee = 0; ee < F; ee++) {
              const U = ee * $ - V;
              for (let K = 0; K < W; K++)
                (q[_] = (K * C - ie) * y),
                  (q[g] = U * v),
                  (q[m] = z),
                  c.push(q.x, q.y, q.z),
                  (q[_] = 0),
                  (q[g] = 0),
                  (q[m] = E > 0 ? 1 : -1),
                  u.push(q.x, q.y, q.z),
                  d.push(K / x),
                  d.push(1 - ee / P),
                  (N += 1);
            }
            for (let ee = 0; ee < P; ee++)
              for (let U = 0; U < x; U++) {
                const fe = h + U + W * (ee + 1),
                  le = h + (U + 1) + W * (ee + 1),
                  be = h + (U + 1) + W * ee;
                l.push(h + U + W * ee, fe, be), l.push(fe, le, be), (k += 6);
              }
            a.addGroup(f, k, M), (f += k), (h += N);
          }
          p("z", "y", "x", -1, -1, i, t, e, o, s, 0),
            p("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
            p("x", "z", "y", 1, 1, e, i, t, r, o, 2),
            p("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
            p("x", "y", "z", 1, -1, e, t, i, r, s, 4),
            p("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
            this.setIndex(l),
            this.setAttribute("position", new Ie(c, 3)),
            this.setAttribute("normal", new Ie(u, 3)),
            this.setAttribute("uv", new Ie(d, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new zo(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments,
          );
        }
      }
      function Fl(n) {
        const e = {};
        for (const t in n) {
          e[t] = {};
          for (const i in n[t]) {
            const r = n[t][i];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? r.isRenderTargetTexture
                ? (console.warn(
                    "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().",
                  ),
                  (e[t][i] = null))
                : (e[t][i] = r.clone())
              : (e[t][i] = Array.isArray(r) ? r.slice() : r);
          }
        }
        return e;
      }
      function ni(n) {
        const e = {};
        for (let t = 0; t < n.length; t++) {
          const i = Fl(n[t]);
          for (const r in i) e[r] = i[r];
        }
        return e;
      }
      function AR(n) {
        return null === n.getRenderTarget() ? n.outputColorSpace : Nr;
      }
      const a6 = { clone: Fl, merge: ni };
      class Xs extends Ou {
        constructor(e) {
          super(),
            (this.isShaderMaterial = !0),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader =
              "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
            (this.fragmentShader =
              "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv1: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== e && this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = Fl(e.uniforms)),
            (this.uniformsGroups = (function o6(n) {
              const e = [];
              for (let t = 0; t < n.length; t++) e.push(n[t].clone());
              return e;
            })(e.uniformsGroups)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            t.uniforms[r] =
              o && o.isTexture
                ? { type: "t", value: o.toJSON(e).uuid }
                : o && o.isColor
                ? { type: "c", value: o.getHex() }
                : o && o.isVector2
                ? { type: "v2", value: o.toArray() }
                : o && o.isVector3
                ? { type: "v3", value: o.toArray() }
                : o && o.isVector4
                ? { type: "v4", value: o.toArray() }
                : o && o.isMatrix3
                ? { type: "m3", value: o.toArray() }
                : o && o.isMatrix4
                ? { type: "m4", value: o.toArray() }
                : { value: o };
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader),
            (t.lights = this.lights),
            (t.clipping = this.clipping);
          const i = {};
          for (const r in this.extensions)
            !0 === this.extensions[r] && (i[r] = !0);
          return Object.keys(i).length > 0 && (t.extensions = i), t;
        }
      }
      class e0 extends Ii {
        constructor() {
          super(),
            (this.isCamera = !0),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new it()),
            (this.projectionMatrix = new it()),
            (this.projectionMatrixInverse = new it()),
            (this.coordinateSystem = ls);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            (this.coordinateSystem = e.coordinateSystem),
            this
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class kn extends e0 {
        constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
          super(),
            (this.isPerspectiveCamera = !0),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = i),
            (this.far = r),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = 2 * yl * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(0.5 * ko * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return 2 * yl * Math.atan(Math.tan(0.5 * ko * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, i, r, s, o) {
          (this.aspect = e / t),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = i),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(0.5 * ko * this.fov)) / this.zoom,
            i = 2 * t,
            r = this.aspect * i,
            s = -0.5 * r;
          const o = this.view;
          if (null !== this.view && this.view.enabled) {
            const l = o.fullWidth,
              c = o.fullHeight;
            (s += (o.offsetX * r) / l),
              (t -= (o.offsetY * i) / c),
              (r *= o.width / l),
              (i *= o.height / c);
          }
          const a = this.filmOffset;
          0 !== a && (s += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              s,
              s + r,
              t,
              t - i,
              e,
              this.far,
              this.coordinateSystem,
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      class u6 extends Ii {
        constructor(e, t, i) {
          super(),
            (this.type = "CubeCamera"),
            (this.renderTarget = i),
            (this.coordinateSystem = null);
          const r = new kn(-90, 1, e, t);
          (r.layers = this.layers), this.add(r);
          const s = new kn(-90, 1, e, t);
          (s.layers = this.layers), this.add(s);
          const o = new kn(-90, 1, e, t);
          (o.layers = this.layers), this.add(o);
          const a = new kn(-90, 1, e, t);
          (a.layers = this.layers), this.add(a);
          const l = new kn(-90, 1, e, t);
          (l.layers = this.layers), this.add(l);
          const c = new kn(-90, 1, e, t);
          (c.layers = this.layers), this.add(c);
        }
        updateCoordinateSystem() {
          const e = this.coordinateSystem,
            t = this.children.concat(),
            [i, r, s, o, a, l] = t;
          for (const c of t) this.remove(c);
          if (e === ls)
            i.up.set(0, 1, 0),
              i.lookAt(1, 0, 0),
              r.up.set(0, 1, 0),
              r.lookAt(-1, 0, 0),
              s.up.set(0, 0, -1),
              s.lookAt(0, 1, 0),
              o.up.set(0, 0, 1),
              o.lookAt(0, -1, 0),
              a.up.set(0, 1, 0),
              a.lookAt(0, 0, 1),
              l.up.set(0, 1, 0),
              l.lookAt(0, 0, -1);
          else {
            if (2001 !== e)
              throw new Error(
                "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
                  e,
              );
            i.up.set(0, -1, 0),
              i.lookAt(-1, 0, 0),
              r.up.set(0, -1, 0),
              r.lookAt(1, 0, 0),
              s.up.set(0, 0, 1),
              s.lookAt(0, 1, 0),
              o.up.set(0, 0, -1),
              o.lookAt(0, -1, 0),
              a.up.set(0, -1, 0),
              a.lookAt(0, 0, 1),
              l.up.set(0, -1, 0),
              l.lookAt(0, 0, -1);
          }
          for (const c of t) this.add(c), c.updateMatrixWorld();
        }
        update(e, t) {
          null === this.parent && this.updateMatrixWorld();
          const i = this.renderTarget;
          this.coordinateSystem !== e.coordinateSystem &&
            ((this.coordinateSystem = e.coordinateSystem),
            this.updateCoordinateSystem());
          const [r, s, o, a, l, c] = this.children,
            u = e.getRenderTarget(),
            d = e.xr.enabled;
          e.xr.enabled = !1;
          const h = i.texture.generateMipmaps;
          (i.texture.generateMipmaps = !1),
            e.setRenderTarget(i, 0),
            e.render(t, r),
            e.setRenderTarget(i, 1),
            e.render(t, s),
            e.setRenderTarget(i, 2),
            e.render(t, o),
            e.setRenderTarget(i, 3),
            e.render(t, a),
            e.setRenderTarget(i, 4),
            e.render(t, l),
            (i.texture.generateMipmaps = h),
            e.setRenderTarget(i, 5),
            e.render(t, c),
            e.setRenderTarget(u),
            (e.xr.enabled = d),
            (i.texture.needsPMREMUpdate = !0);
        }
      }
      class Jf extends zs {
        constructor(e, t, i, r, s, o, a, l, c, u) {
          super(
            (e = void 0 !== e ? e : []),
            (t = void 0 !== t ? t : Bs),
            i,
            r,
            s,
            o,
            a,
            l,
            c,
            u,
          ),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class d6 extends Uo {
        constructor(e = 1, t = {}) {
          super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
          const i = { width: e, height: e, depth: 1 },
            r = [i, i, i, i, i, i];
          void 0 !== t.encoding &&
            (Du(
              "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.",
            ),
            (t.colorSpace = t.encoding === No ? rt : "")),
            (this.texture = new Jf(
              r,
              t.mapping,
              t.wrapS,
              t.wrapT,
              t.magFilter,
              t.minFilter,
              t.format,
              t.type,
              t.anisotropy,
              t.colorSpace,
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== t.generateMipmaps && t.generateMipmaps),
            (this.texture.minFilter =
              void 0 !== t.minFilter ? t.minFilter : gn);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.colorSpace = t.colorSpace),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const i_uniforms = { tEquirect: { value: null } },
            i_vertexShader =
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            i_fragmentShader =
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            r = new zo(5, 5, 5),
            s = new Xs({
              name: "CubemapFromEquirect",
              uniforms: Fl(i_uniforms),
              vertexShader: i_vertexShader,
              fragmentShader: i_fragmentShader,
              side: 1,
              blending: 0,
            });
          s.uniforms.tEquirect.value = t;
          const o = new ti(r, s),
            a = t.minFilter;
          return (
            t.minFilter === Ro && (t.minFilter = gn),
            new u6(1, 10, this).update(e, o),
            (t.minFilter = a),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
        clear(e, t, i, r) {
          const s = e.getRenderTarget();
          for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o), e.clear(t, i, r);
          e.setRenderTarget(s);
        }
      }
      const t0 = new D(),
        h6 = new D(),
        f6 = new ut();
      class Go {
        constructor(e = new D(1, 0, 0), t = 0) {
          (this.isPlane = !0), (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, i, r) {
          return this.normal.set(e, t, i), (this.constant = r), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, i) {
          const r = t0.subVectors(i, t).cross(h6.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(r, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t
            .copy(e)
            .addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
          const i = e.delta(t0),
            r = this.normal.dot(i);
          if (0 === r)
            return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
          const s = -(e.start.dot(this.normal) + this.constant) / r;
          return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            i = this.distanceToPoint(e.end);
          return (t < 0 && i > 0) || (i < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const i = t || f6.getNormalMatrix(e),
            r = this.coplanarPoint(t0).applyMatrix4(e),
            s = this.normal.applyMatrix3(i).normalize();
          return (this.constant = -r.dot(s)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Wo = new Lr(),
        ep = new D();
      class n0 {
        constructor(
          e = new Go(),
          t = new Go(),
          i = new Go(),
          r = new Go(),
          s = new Go(),
          o = new Go(),
        ) {
          this.planes = [e, t, i, r, s, o];
        }
        set(e, t, i, r, s, o) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(i),
            a[3].copy(r),
            a[4].copy(s),
            a[5].copy(o),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
          return this;
        }
        setFromProjectionMatrix(e, t = ls) {
          const i = this.planes,
            r = e.elements,
            s = r[0],
            o = r[1],
            a = r[2],
            l = r[3],
            c = r[4],
            u = r[5],
            d = r[6],
            h = r[7],
            f = r[8],
            p = r[9],
            _ = r[10],
            g = r[11],
            m = r[12],
            y = r[13],
            v = r[14],
            b = r[15];
          if (
            (i[0].setComponents(l - s, h - c, g - f, b - m).normalize(),
            i[1].setComponents(l + s, h + c, g + f, b + m).normalize(),
            i[2].setComponents(l + o, h + u, g + p, b + y).normalize(),
            i[3].setComponents(l - o, h - u, g - p, b - y).normalize(),
            i[4].setComponents(l - a, h - d, g - _, b - v).normalize(),
            t === ls)
          )
            i[5].setComponents(l + a, h + d, g + _, b + v).normalize();
          else {
            if (2001 !== t)
              throw new Error(
                "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
                  t,
              );
            i[5].setComponents(a, d, _, v).normalize();
          }
          return this;
        }
        intersectsObject(e) {
          if (void 0 !== e.boundingSphere)
            null === e.boundingSphere && e.computeBoundingSphere(),
              Wo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
          else {
            const t = e.geometry;
            null === t.boundingSphere && t.computeBoundingSphere(),
              Wo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
          }
          return this.intersectsSphere(Wo);
        }
        intersectsSprite(e) {
          return (
            Wo.center.set(0, 0, 0),
            (Wo.radius = 0.7071067811865476),
            Wo.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Wo)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            i = e.center,
            r = -e.radius;
          for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (
              ((ep.x = r.normal.x > 0 ? e.max.x : e.min.x),
              (ep.y = r.normal.y > 0 ? e.max.y : e.min.y),
              (ep.z = r.normal.z > 0 ? e.max.z : e.min.z),
              r.distanceToPoint(ep) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function IR() {
        let n = null,
          e = !1,
          t = null,
          i = null;
        function r(s, o) {
          t(s, o), (i = n.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== e &&
              null !== t &&
              ((i = n.requestAnimationFrame(r)), (e = !0));
          },
          stop: function () {
            n.cancelAnimationFrame(i), (e = !1);
          },
          setAnimationLoop: function (s) {
            t = s;
          },
          setContext: function (s) {
            n = s;
          },
        };
      }
      function p6(n, e) {
        const t = e.isWebGL2,
          i = new WeakMap();
        return {
          get: function o(c) {
            return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
          },
          remove: function a(c) {
            c.isInterleavedBufferAttribute && (c = c.data);
            const u = i.get(c);
            u && (n.deleteBuffer(u.buffer), i.delete(c));
          },
          update: function l(c, u) {
            if (c.isGLBufferAttribute) {
              const h = i.get(c);
              return void (
                (!h || h.version < c.version) &&
                i.set(c, {
                  buffer: c.buffer,
                  type: c.type,
                  bytesPerElement: c.elementSize,
                  version: c.version,
                })
              );
            }
            c.isInterleavedBufferAttribute && (c = c.data);
            const d = i.get(c);
            void 0 === d
              ? i.set(
                  c,
                  (function r(c, u) {
                    const d = c.array,
                      h = c.usage,
                      f = n.createBuffer();
                    let p;
                    if (
                      (n.bindBuffer(u, f),
                      n.bufferData(u, d, h),
                      c.onUploadCallback(),
                      d instanceof Float32Array)
                    )
                      p = n.FLOAT;
                    else if (d instanceof Uint16Array)
                      if (c.isFloat16BufferAttribute) {
                        if (!t)
                          throw new Error(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.",
                          );
                        p = n.HALF_FLOAT;
                      } else p = n.UNSIGNED_SHORT;
                    else if (d instanceof Int16Array) p = n.SHORT;
                    else if (d instanceof Uint32Array) p = n.UNSIGNED_INT;
                    else if (d instanceof Int32Array) p = n.INT;
                    else if (d instanceof Int8Array) p = n.BYTE;
                    else if (d instanceof Uint8Array) p = n.UNSIGNED_BYTE;
                    else {
                      if (!(d instanceof Uint8ClampedArray))
                        throw new Error(
                          "THREE.WebGLAttributes: Unsupported buffer data format: " +
                            d,
                        );
                      p = n.UNSIGNED_BYTE;
                    }
                    return {
                      buffer: f,
                      type: p,
                      bytesPerElement: d.BYTES_PER_ELEMENT,
                      version: c.version,
                    };
                  })(c, u),
                )
              : d.version < c.version &&
                ((function s(c, u, d) {
                  const h = u.array,
                    f = u.updateRange;
                  n.bindBuffer(d, c),
                    -1 === f.count
                      ? n.bufferSubData(d, 0, h)
                      : (t
                          ? n.bufferSubData(
                              d,
                              f.offset * h.BYTES_PER_ELEMENT,
                              h,
                              f.offset,
                              f.count,
                            )
                          : n.bufferSubData(
                              d,
                              f.offset * h.BYTES_PER_ELEMENT,
                              h.subarray(f.offset, f.offset + f.count),
                            ),
                        (f.count = -1)),
                    u.onUploadCallback();
                })(d.buffer, c, u),
                (d.version = c.version));
          },
        };
      }
      class tp extends ht {
        constructor(e = 1, t = 1, i = 1, r = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: i,
              heightSegments: r,
            });
          const s = e / 2,
            o = t / 2,
            a = Math.floor(i),
            l = Math.floor(r),
            c = a + 1,
            u = l + 1,
            d = e / a,
            h = t / l,
            f = [],
            p = [],
            _ = [],
            g = [];
          for (let m = 0; m < u; m++) {
            const y = m * h - o;
            for (let v = 0; v < c; v++)
              p.push(v * d - s, -y, 0),
                _.push(0, 0, 1),
                g.push(v / a),
                g.push(1 - m / l);
          }
          for (let m = 0; m < l; m++)
            for (let y = 0; y < a; y++) {
              const b = y + c * (m + 1),
                S = y + 1 + c * (m + 1),
                E = y + 1 + c * m;
              f.push(y + c * m, b, E), f.push(b, S, E);
            }
          this.setIndex(f),
            this.setAttribute("position", new Ie(p, 3)),
            this.setAttribute("normal", new Ie(_, 3)),
            this.setAttribute("uv", new Ie(g, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new tp(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      const at = {
          alphahash_fragment:
            "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
          alphahash_pars_fragment:
            "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
          alphatest_pars_fragment:
            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex:
            "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
          iridescence_fragment:
            "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          colorspace_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          colorspace_pars_fragment:
            "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
          lightmap_fragment:
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_fragment:
            "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
          lights_lambert_pars_fragment:
            "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphcolor_vertex:
            "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
          normal_fragment_begin:
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps:
            "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex:
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
          iridescence_pars_fragment:
            "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
          opaque_fragment:
            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment:
            "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
          transmission_pars_fragment:
            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
          uv_pars_fragment:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_pars_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag:
            "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          backgroundCube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          backgroundCube_frag:
            "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag:
            "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          depth_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
        },
        _e = {
          common: {
            diffuse: { value: new Ce(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            mapTransform: { value: new ut() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new ut() },
            alphaTest: { value: 0 },
          },
          specularmap: {
            specularMap: { value: null },
            specularMapTransform: { value: new ut() },
          },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: {
            aoMap: { value: null },
            aoMapIntensity: { value: 1 },
            aoMapTransform: { value: new ut() },
          },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
            lightMapTransform: { value: new ut() },
          },
          bumpmap: {
            bumpMap: { value: null },
            bumpMapTransform: { value: new ut() },
            bumpScale: { value: 1 },
          },
          normalmap: {
            normalMap: { value: null },
            normalMapTransform: { value: new ut() },
            normalScale: { value: new oe(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementMapTransform: { value: new ut() },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          emissivemap: {
            emissiveMap: { value: null },
            emissiveMapTransform: { value: new ut() },
          },
          metalnessmap: {
            metalnessMap: { value: null },
            metalnessMapTransform: { value: new ut() },
          },
          roughnessmap: {
            roughnessMap: { value: null },
            roughnessMapTransform: { value: new ut() },
          },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Ce(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Ce(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaMapTransform: { value: new ut() },
            alphaTest: { value: 0 },
            uvTransform: { value: new ut() },
          },
          sprite: {
            diffuse: { value: new Ce(16777215) },
            opacity: { value: 1 },
            center: { value: new oe(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            mapTransform: { value: new ut() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new ut() },
            alphaTest: { value: 0 },
          },
        },
        Fr = {
          basic: {
            uniforms: ni([
              _e.common,
              _e.specularmap,
              _e.envmap,
              _e.aomap,
              _e.lightmap,
              _e.fog,
            ]),
            vertexShader: at.meshbasic_vert,
            fragmentShader: at.meshbasic_frag,
          },
          lambert: {
            uniforms: ni([
              _e.common,
              _e.specularmap,
              _e.envmap,
              _e.aomap,
              _e.lightmap,
              _e.emissivemap,
              _e.bumpmap,
              _e.normalmap,
              _e.displacementmap,
              _e.fog,
              _e.lights,
              { emissive: { value: new Ce(0) } },
            ]),
            vertexShader: at.meshlambert_vert,
            fragmentShader: at.meshlambert_frag,
          },
          phong: {
            uniforms: ni([
              _e.common,
              _e.specularmap,
              _e.envmap,
              _e.aomap,
              _e.lightmap,
              _e.emissivemap,
              _e.bumpmap,
              _e.normalmap,
              _e.displacementmap,
              _e.fog,
              _e.lights,
              {
                emissive: { value: new Ce(0) },
                specular: { value: new Ce(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: at.meshphong_vert,
            fragmentShader: at.meshphong_frag,
          },
          standard: {
            uniforms: ni([
              _e.common,
              _e.envmap,
              _e.aomap,
              _e.lightmap,
              _e.emissivemap,
              _e.bumpmap,
              _e.normalmap,
              _e.displacementmap,
              _e.roughnessmap,
              _e.metalnessmap,
              _e.fog,
              _e.lights,
              {
                emissive: { value: new Ce(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: at.meshphysical_vert,
            fragmentShader: at.meshphysical_frag,
          },
          toon: {
            uniforms: ni([
              _e.common,
              _e.aomap,
              _e.lightmap,
              _e.emissivemap,
              _e.bumpmap,
              _e.normalmap,
              _e.displacementmap,
              _e.gradientmap,
              _e.fog,
              _e.lights,
              { emissive: { value: new Ce(0) } },
            ]),
            vertexShader: at.meshtoon_vert,
            fragmentShader: at.meshtoon_frag,
          },
          matcap: {
            uniforms: ni([
              _e.common,
              _e.bumpmap,
              _e.normalmap,
              _e.displacementmap,
              _e.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: at.meshmatcap_vert,
            fragmentShader: at.meshmatcap_frag,
          },
          points: {
            uniforms: ni([_e.points, _e.fog]),
            vertexShader: at.points_vert,
            fragmentShader: at.points_frag,
          },
          dashed: {
            uniforms: ni([
              _e.common,
              _e.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: at.linedashed_vert,
            fragmentShader: at.linedashed_frag,
          },
          depth: {
            uniforms: ni([_e.common, _e.displacementmap]),
            vertexShader: at.depth_vert,
            fragmentShader: at.depth_frag,
          },
          normal: {
            uniforms: ni([
              _e.common,
              _e.bumpmap,
              _e.normalmap,
              _e.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: at.meshnormal_vert,
            fragmentShader: at.meshnormal_frag,
          },
          sprite: {
            uniforms: ni([_e.sprite, _e.fog]),
            vertexShader: at.sprite_vert,
            fragmentShader: at.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new ut() },
              t2D: { value: null },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: at.background_vert,
            fragmentShader: at.background_frag,
          },
          backgroundCube: {
            uniforms: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              backgroundBlurriness: { value: 0 },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: at.backgroundCube_vert,
            fragmentShader: at.backgroundCube_frag,
          },
          cube: {
            uniforms: {
              tCube: { value: null },
              tFlip: { value: -1 },
              opacity: { value: 1 },
            },
            vertexShader: at.cube_vert,
            fragmentShader: at.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: at.equirect_vert,
            fragmentShader: at.equirect_frag,
          },
          distanceRGBA: {
            uniforms: ni([
              _e.common,
              _e.displacementmap,
              {
                referencePosition: { value: new D() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: at.distanceRGBA_vert,
            fragmentShader: at.distanceRGBA_frag,
          },
          shadow: {
            uniforms: ni([
              _e.lights,
              _e.fog,
              { color: { value: new Ce(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: at.shadow_vert,
            fragmentShader: at.shadow_frag,
          },
        };
      Fr.physical = {
        uniforms: ni([
          Fr.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatMapTransform: { value: new ut() },
            clearcoatNormalMap: { value: null },
            clearcoatNormalMapTransform: { value: new ut() },
            clearcoatNormalScale: { value: new oe(1, 1) },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatRoughnessMapTransform: { value: new ut() },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceMapTransform: { value: new ut() },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            iridescenceThicknessMapTransform: { value: new ut() },
            sheen: { value: 0 },
            sheenColor: { value: new Ce(0) },
            sheenColorMap: { value: null },
            sheenColorMapTransform: { value: new ut() },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            sheenRoughnessMapTransform: { value: new ut() },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionMapTransform: { value: new ut() },
            transmissionSamplerSize: { value: new oe() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            thicknessMapTransform: { value: new ut() },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new Ce(0) },
            specularColor: { value: new Ce(1, 1, 1) },
            specularColorMap: { value: null },
            specularColorMapTransform: { value: new ut() },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularIntensityMapTransform: { value: new ut() },
            anisotropyVector: { value: new oe() },
            anisotropyMap: { value: null },
            anisotropyMapTransform: { value: new ut() },
          },
        ]),
        vertexShader: at.meshphysical_vert,
        fragmentShader: at.meshphysical_frag,
      };
      const np = { r: 0, b: 0, g: 0 };
      function h7(n, e, t, i, r, s, o) {
        const a = new Ce(0);
        let c,
          u,
          l = !0 === s ? 0 : 1,
          d = null,
          h = 0,
          f = null;
        function _(g, m) {
          g.getRGB(np, AR(n)), i.buffers.color.setClear(np.r, np.g, np.b, m, o);
        }
        return {
          getClearColor: function () {
            return a;
          },
          setClearColor: function (g, m = 1) {
            a.set(g), (l = m), _(a, l);
          },
          getClearAlpha: function () {
            return l;
          },
          setClearAlpha: function (g) {
            (l = g), _(a, l);
          },
          render: function p(g, m) {
            let y = !1,
              v = !0 === m.isScene ? m.background : null;
            switch (
              (v &&
                v.isTexture &&
                (v = (m.backgroundBlurriness > 0 ? t : e).get(v)),
              null === v ? _(a, l) : v && v.isColor && (_(v, 1), (y = !0)),
              n.xr.getEnvironmentBlendMode())
            ) {
              case "opaque":
                y = !0;
                break;
              case "additive":
                i.buffers.color.setClear(0, 0, 0, 1, o), (y = !0);
                break;
              case "alpha-blend":
                i.buffers.color.setClear(0, 0, 0, 0, o), (y = !0);
            }
            (n.autoClear || y) &&
              n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
              v && (v.isCubeTexture || v.mapping === Eu)
                ? (void 0 === u &&
                    ((u = new ti(
                      new zo(1, 1, 1),
                      new Xs({
                        name: "BackgroundCubeMaterial",
                        uniforms: Fl(Fr.backgroundCube.uniforms),
                        vertexShader: Fr.backgroundCube.vertexShader,
                        fragmentShader: Fr.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      }),
                    )),
                    u.geometry.deleteAttribute("normal"),
                    u.geometry.deleteAttribute("uv"),
                    (u.onBeforeRender = function (E, x, P) {
                      this.matrixWorld.copyPosition(P.matrixWorld);
                    }),
                    Object.defineProperty(u.material, "envMap", {
                      get: function () {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    r.update(u)),
                  (u.material.uniforms.envMap.value = v),
                  (u.material.uniforms.flipEnvMap.value =
                    v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1),
                  (u.material.uniforms.backgroundBlurriness.value =
                    m.backgroundBlurriness),
                  (u.material.uniforms.backgroundIntensity.value =
                    m.backgroundIntensity),
                  (u.material.toneMapped = v.colorSpace !== rt),
                  (d !== v || h !== v.version || f !== n.toneMapping) &&
                    ((u.material.needsUpdate = !0),
                    (d = v),
                    (h = v.version),
                    (f = n.toneMapping)),
                  u.layers.enableAll(),
                  g.unshift(u, u.geometry, u.material, 0, 0, null))
                : v &&
                  v.isTexture &&
                  (void 0 === c &&
                    ((c = new ti(
                      new tp(2, 2),
                      new Xs({
                        name: "BackgroundMaterial",
                        uniforms: Fl(Fr.background.uniforms),
                        vertexShader: Fr.background.vertexShader,
                        fragmentShader: Fr.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      }),
                    )),
                    c.geometry.deleteAttribute("normal"),
                    Object.defineProperty(c.material, "map", {
                      get: function () {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    r.update(c)),
                  (c.material.uniforms.t2D.value = v),
                  (c.material.uniforms.backgroundIntensity.value =
                    m.backgroundIntensity),
                  (c.material.toneMapped = v.colorSpace !== rt),
                  !0 === v.matrixAutoUpdate && v.updateMatrix(),
                  c.material.uniforms.uvTransform.value.copy(v.matrix),
                  (d !== v || h !== v.version || f !== n.toneMapping) &&
                    ((c.material.needsUpdate = !0),
                    (d = v),
                    (h = v.version),
                    (f = n.toneMapping)),
                  c.layers.enableAll(),
                  g.unshift(c, c.geometry, c.material, 0, 0, null));
          },
        };
      }
      function f7(n, e, t, i) {
        const r = n.getParameter(n.MAX_VERTEX_ATTRIBS),
          s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          o = i.isWebGL2 || null !== s,
          a = {},
          l = g(null);
        let c = l,
          u = !1;
        function f(z) {
          return i.isWebGL2 ? n.bindVertexArray(z) : s.bindVertexArrayOES(z);
        }
        function p(z) {
          return i.isWebGL2
            ? n.deleteVertexArray(z)
            : s.deleteVertexArrayOES(z);
        }
        function g(z) {
          const W = [],
            F = [],
            N = [];
          for (let k = 0; k < r; k++) (W[k] = 0), (F[k] = 0), (N[k] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: W,
            enabledAttributes: F,
            attributeDivisors: N,
            object: z,
            attributes: {},
            index: null,
          };
        }
        function v() {
          const z = c.newAttributes;
          for (let W = 0, F = z.length; W < F; W++) z[W] = 0;
        }
        function b(z) {
          S(z, 0);
        }
        function S(z, W) {
          const N = c.enabledAttributes,
            k = c.attributeDivisors;
          (c.newAttributes[z] = 1),
            0 === N[z] && (n.enableVertexAttribArray(z), (N[z] = 1)),
            k[z] !== W &&
              ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
                i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](z, W),
              (k[z] = W));
        }
        function E() {
          const z = c.newAttributes,
            W = c.enabledAttributes;
          for (let F = 0, N = W.length; F < N; F++)
            W[F] !== z[F] && (n.disableVertexAttribArray(F), (W[F] = 0));
        }
        function x(z, W, F, N, k, q, ee) {
          !0 === ee
            ? n.vertexAttribIPointer(z, W, F, k, q)
            : n.vertexAttribPointer(z, W, F, N, k, q);
        }
        function ie() {
          V(), (u = !0), c !== l && ((c = l), f(c.object));
        }
        function V() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: function d(z, W, F, N, k) {
            let q = !1;
            if (o) {
              const ee = (function _(z, W, F) {
                const N = !0 === F.wireframe;
                let k = a[z.id];
                void 0 === k && ((k = {}), (a[z.id] = k));
                let q = k[W.id];
                void 0 === q && ((q = {}), (k[W.id] = q));
                let ee = q[N];
                return (
                  void 0 === ee &&
                    ((ee = g(
                      (function h() {
                        return i.isWebGL2
                          ? n.createVertexArray()
                          : s.createVertexArrayOES();
                      })(),
                    )),
                    (q[N] = ee)),
                  ee
                );
              })(N, F, W);
              c !== ee && ((c = ee), f(c.object)),
                (q = (function m(z, W, F, N) {
                  const k = c.attributes,
                    q = W.attributes;
                  let ee = 0;
                  const U = F.getAttributes();
                  for (const K in U)
                    if (U[K].location >= 0) {
                      const le = k[K];
                      let be = q[K];
                      if (
                        (void 0 === be &&
                          ("instanceMatrix" === K &&
                            z.instanceMatrix &&
                            (be = z.instanceMatrix),
                          "instanceColor" === K &&
                            z.instanceColor &&
                            (be = z.instanceColor)),
                        void 0 === le ||
                          le.attribute !== be ||
                          (be && le.data !== be.data))
                      )
                        return !0;
                      ee++;
                    }
                  return c.attributesNum !== ee || c.index !== N;
                })(z, N, F, k)),
                q &&
                  (function y(z, W, F, N) {
                    const k = {},
                      q = W.attributes;
                    let ee = 0;
                    const U = F.getAttributes();
                    for (const K in U)
                      if (U[K].location >= 0) {
                        let le = q[K];
                        void 0 === le &&
                          ("instanceMatrix" === K &&
                            z.instanceMatrix &&
                            (le = z.instanceMatrix),
                          "instanceColor" === K &&
                            z.instanceColor &&
                            (le = z.instanceColor));
                        const be = {};
                        (be.attribute = le),
                          le && le.data && (be.data = le.data),
                          (k[K] = be),
                          ee++;
                      }
                    (c.attributes = k), (c.attributesNum = ee), (c.index = N);
                  })(z, N, F, k);
            } else {
              const ee = !0 === W.wireframe;
              (c.geometry !== N.id ||
                c.program !== F.id ||
                c.wireframe !== ee) &&
                ((c.geometry = N.id),
                (c.program = F.id),
                (c.wireframe = ee),
                (q = !0));
            }
            null !== k && t.update(k, n.ELEMENT_ARRAY_BUFFER),
              (q || u) &&
                ((u = !1),
                (function P(z, W, F, N) {
                  if (
                    !1 === i.isWebGL2 &&
                    (z.isInstancedMesh || N.isInstancedBufferGeometry) &&
                    null === e.get("ANGLE_instanced_arrays")
                  )
                    return;
                  v();
                  const k = N.attributes,
                    q = F.getAttributes(),
                    ee = W.defaultAttributeValues;
                  for (const U in q) {
                    const K = q[U];
                    if (K.location >= 0) {
                      let fe = k[U];
                      if (
                        (void 0 === fe &&
                          ("instanceMatrix" === U &&
                            z.instanceMatrix &&
                            (fe = z.instanceMatrix),
                          "instanceColor" === U &&
                            z.instanceColor &&
                            (fe = z.instanceColor)),
                        void 0 !== fe)
                      ) {
                        const le = fe.normalized,
                          be = fe.itemSize,
                          Le = t.get(fe);
                        if (void 0 === Le) continue;
                        const Me = Le.buffer,
                          Re = Le.type,
                          Je = Le.bytesPerElement,
                          Ft =
                            !0 === i.isWebGL2 &&
                            (Re === n.INT ||
                              Re === n.UNSIGNED_INT ||
                              1013 === fe.gpuType);
                        if (fe.isInterleavedBufferAttribute) {
                          const Be = fe.data,
                            R = Be.stride,
                            me = fe.offset;
                          if (Be.isInstancedInterleavedBuffer) {
                            for (let te = 0; te < K.locationSize; te++)
                              S(K.location + te, Be.meshPerAttribute);
                            !0 !== z.isInstancedMesh &&
                              void 0 === N._maxInstanceCount &&
                              (N._maxInstanceCount =
                                Be.meshPerAttribute * Be.count);
                          } else
                            for (let te = 0; te < K.locationSize; te++)
                              b(K.location + te);
                          n.bindBuffer(n.ARRAY_BUFFER, Me);
                          for (let te = 0; te < K.locationSize; te++)
                            x(
                              K.location + te,
                              be / K.locationSize,
                              Re,
                              le,
                              R * Je,
                              (me + (be / K.locationSize) * te) * Je,
                              Ft,
                            );
                        } else {
                          if (fe.isInstancedBufferAttribute) {
                            for (let Be = 0; Be < K.locationSize; Be++)
                              S(K.location + Be, fe.meshPerAttribute);
                            !0 !== z.isInstancedMesh &&
                              void 0 === N._maxInstanceCount &&
                              (N._maxInstanceCount =
                                fe.meshPerAttribute * fe.count);
                          } else
                            for (let Be = 0; Be < K.locationSize; Be++)
                              b(K.location + Be);
                          n.bindBuffer(n.ARRAY_BUFFER, Me);
                          for (let Be = 0; Be < K.locationSize; Be++)
                            x(
                              K.location + Be,
                              be / K.locationSize,
                              Re,
                              le,
                              be * Je,
                              (be / K.locationSize) * Be * Je,
                              Ft,
                            );
                        }
                      } else if (void 0 !== ee) {
                        const le = ee[U];
                        if (void 0 !== le)
                          switch (le.length) {
                            case 2:
                              n.vertexAttrib2fv(K.location, le);
                              break;
                            case 3:
                              n.vertexAttrib3fv(K.location, le);
                              break;
                            case 4:
                              n.vertexAttrib4fv(K.location, le);
                              break;
                            default:
                              n.vertexAttrib1fv(K.location, le);
                          }
                      }
                    }
                  }
                  E();
                })(z, W, F, N),
                null !== k &&
                  n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(k).buffer));
          },
          reset: ie,
          resetDefaultState: V,
          dispose: function M() {
            ie();
            for (const z in a) {
              const W = a[z];
              for (const F in W) {
                const N = W[F];
                for (const k in N) p(N[k].object), delete N[k];
                delete W[F];
              }
              delete a[z];
            }
          },
          releaseStatesOfGeometry: function C(z) {
            if (void 0 === a[z.id]) return;
            const W = a[z.id];
            for (const F in W) {
              const N = W[F];
              for (const k in N) p(N[k].object), delete N[k];
              delete W[F];
            }
            delete a[z.id];
          },
          releaseStatesOfProgram: function $(z) {
            for (const W in a) {
              const F = a[W];
              if (void 0 === F[z.id]) continue;
              const N = F[z.id];
              for (const k in N) p(N[k].object), delete N[k];
              delete F[z.id];
            }
          },
          initAttributes: v,
          enableAttribute: b,
          disableUnusedAttributes: E,
        };
      }
      function p7(n, e, t, i) {
        const r = i.isWebGL2;
        let s;
        (this.setMode = function o(c) {
          s = c;
        }),
          (this.render = function a(c, u) {
            n.drawArrays(s, c, u), t.update(u, s, 1);
          }),
          (this.renderInstances = function l(c, u, d) {
            if (0 === d) return;
            let h, f;
            if (r) (h = n), (f = "drawArraysInstanced");
            else if (
              ((h = e.get("ANGLE_instanced_arrays")),
              (f = "drawArraysInstancedANGLE"),
              null === h)
            )
              return void console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
              );
            h[f](s, c, u, d), t.update(u, s, d);
          });
      }
      function m7(n, e, t) {
        let i;
        function s(x) {
          if ("highp" === x) {
            if (
              n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT)
                .precision > 0 &&
              n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT)
                .precision > 0
            )
              return "highp";
            x = "mediump";
          }
          return "mediump" === x &&
            n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT)
              .precision > 0 &&
            n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT)
              .precision > 0
            ? "mediump"
            : "lowp";
        }
        const o =
          typeof WebGL2RenderingContext < "u" &&
          "WebGL2RenderingContext" === n.constructor.name;
        let a = void 0 !== t.precision ? t.precision : "highp";
        const l = s(a);
        l !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            l,
            "instead.",
          ),
          (a = l));
        const c = o || e.has("WEBGL_draw_buffers"),
          u = !0 === t.logarithmicDepthBuffer,
          d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
          h = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          f = n.getParameter(n.MAX_TEXTURE_SIZE),
          p = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
          _ = n.getParameter(n.MAX_VERTEX_ATTRIBS),
          g = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
          m = n.getParameter(n.MAX_VARYING_VECTORS),
          y = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
          v = h > 0,
          b = o || e.has("OES_texture_float");
        return {
          isWebGL2: o,
          drawBuffers: c,
          getMaxAnisotropy: function r() {
            if (void 0 !== i) return i;
            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
              const x = e.get("EXT_texture_filter_anisotropic");
              i = n.getParameter(x.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else i = 0;
            return i;
          },
          getMaxPrecision: s,
          precision: a,
          logarithmicDepthBuffer: u,
          maxTextures: d,
          maxVertexTextures: h,
          maxTextureSize: f,
          maxCubemapSize: p,
          maxAttributes: _,
          maxVertexUniforms: g,
          maxVaryings: m,
          maxFragmentUniforms: y,
          vertexTextures: v,
          floatFragmentTextures: b,
          floatVertexTextures: v && b,
          maxSamples: o ? n.getParameter(n.MAX_SAMPLES) : 0,
        };
      }
      function g7(n) {
        const e = this;
        let t = null,
          i = 0,
          r = !1,
          s = !1;
        const o = new Go(),
          a = new ut(),
          l = { value: null, needsUpdate: !1 };
        function u(d, h, f, p) {
          const _ = null !== d ? d.length : 0;
          let g = null;
          if (0 !== _) {
            if (((g = l.value), !0 !== p || null === g)) {
              const m = f + 4 * _,
                y = h.matrixWorldInverse;
              a.getNormalMatrix(y),
                (null === g || g.length < m) && (g = new Float32Array(m));
              for (let v = 0, b = f; v !== _; ++v, b += 4)
                o.copy(d[v]).applyMatrix4(y, a),
                  o.normal.toArray(g, b),
                  (g[b + 3] = o.constant);
            }
            (l.value = g), (l.needsUpdate = !0);
          }
          return (e.numPlanes = _), (e.numIntersection = 0), g;
        }
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (d, h) {
            const f = 0 !== d.length || h || 0 !== i || r;
            return (r = h), (i = d.length), f;
          }),
          (this.beginShadows = function () {
            (s = !0), u(null);
          }),
          (this.endShadows = function () {
            s = !1;
          }),
          (this.setGlobalState = function (d, h) {
            t = u(d, h, 0);
          }),
          (this.setState = function (d, h, f) {
            const p = d.clippingPlanes,
              _ = d.clipIntersection,
              g = d.clipShadows,
              m = n.get(d);
            if (!r || null === p || 0 === p.length || (s && !g))
              s
                ? u(null)
                : (function c() {
                    l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
                      (e.numPlanes = i),
                      (e.numIntersection = 0);
                  })();
            else {
              const y = s ? 0 : i,
                v = 4 * y;
              let b = m.clippingState || null;
              (l.value = b), (b = u(p, h, v, f));
              for (let S = 0; S !== v; ++S) b[S] = t[S];
              (m.clippingState = b),
                (this.numIntersection = _ ? this.numPlanes : 0),
                (this.numPlanes += y);
            }
          });
      }
      function _7(n) {
        let e = new WeakMap();
        function t(o, a) {
          return (
            303 === a ? (o.mapping = Bs) : 304 === a && (o.mapping = Io), o
          );
        }
        function r(o) {
          const a = o.target;
          a.removeEventListener("dispose", r);
          const l = e.get(a);
          void 0 !== l && (e.delete(a), l.dispose());
        }
        return {
          get: function i(o) {
            if (o && o.isTexture && !1 === o.isRenderTargetTexture) {
              const a = o.mapping;
              if (303 === a || 304 === a) {
                if (e.has(o)) return t(e.get(o).texture, o.mapping);
                {
                  const l = o.image;
                  if (l && l.height > 0) {
                    const c = new d6(l.height / 2);
                    return (
                      c.fromEquirectangularTexture(n, o),
                      e.set(o, c),
                      o.addEventListener("dispose", r),
                      t(c.texture, o.mapping)
                    );
                  }
                  return null;
                }
              }
            }
            return o;
          },
          dispose: function s() {
            e = new WeakMap();
          },
        };
      }
      class r0 extends e0 {
        constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
          super(),
            (this.isOrthographicCamera = !0),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = i),
            (this.bottom = r),
            (this.near = s),
            (this.far = o),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, i, r, s, o) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = i),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
          let s = i - e,
            o = i + e,
            a = r + t,
            l = r - t;
          if (null !== this.view && this.view.enabled) {
            const c =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (s += c * this.view.offsetX),
              (o = s + c * this.view.width),
              (a -= u * this.view.offsetY),
              (l = a - u * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            s,
            o,
            a,
            l,
            this.near,
            this.far,
            this.coordinateSystem,
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      const RR = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        s0 = new r0(),
        PR = new Ce();
      let o0 = null;
      const jo = (1 + Math.sqrt(5)) / 2,
        Vl = 1 / jo,
        OR = [
          new D(1, 1, 1),
          new D(-1, 1, 1),
          new D(1, 1, -1),
          new D(-1, 1, -1),
          new D(0, jo, Vl),
          new D(0, jo, -Vl),
          new D(Vl, 0, jo),
          new D(-Vl, 0, jo),
          new D(jo, Vl, 0),
          new D(-jo, Vl, 0),
        ];
      class NR {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, i = 0.1, r = 100) {
          (o0 = this._renderer.getRenderTarget()), this._setSize(256);
          const s = this._allocateTargets();
          return (
            (s.depthBuffer = !0),
            this._sceneToCubeUV(e, i, r, s),
            t > 0 && this._blur(s, 0, 0, t),
            this._applyPMREM(s),
            this._cleanup(s),
            s
          );
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          null === this._cubemapMaterial &&
            ((this._cubemapMaterial = kR()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          null === this._equirectMaterial &&
            ((this._equirectMaterial = FR()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
            null !== this._equirectMaterial && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget &&
              this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(o0),
            (e.scissorTest = !1),
            ip(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          this._setSize(
            e.mapping === Bs || e.mapping === Io
              ? 0 === e.image.length
                ? 16
                : e.image[0].width || e.image[0].image.width
              : e.image.width / 4,
          ),
            (o0 = this._renderer.getRenderTarget());
          const i = t || this._allocateTargets();
          return (
            this._textureToCubeUV(e, i),
            this._applyPMREM(i),
            this._cleanup(i),
            i
          );
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            i = {
              magFilter: gn,
              minFilter: gn,
              generateMipmaps: !1,
              type: Cu,
              format: Ki,
              colorSpace: Nr,
              depthBuffer: !1,
            },
            r = LR(e, t, i);
          if (
            null === this._pingPongRenderTarget ||
            this._pingPongRenderTarget.width !== e ||
            this._pingPongRenderTarget.height !== t
          ) {
            null !== this._pingPongRenderTarget && this._dispose(),
              (this._pingPongRenderTarget = LR(e, t, i));
            const { _lodMax: s } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = (function v7(n) {
              const e = [],
                t = [],
                i = [];
              let r = n;
              const s = n - 4 + 1 + RR.length;
              for (let o = 0; o < s; o++) {
                const a = Math.pow(2, r);
                t.push(a);
                let l = 1 / a;
                o > n - 4 ? (l = RR[o - n + 4 - 1]) : 0 === o && (l = 0),
                  i.push(l);
                const c = 1 / (a - 2),
                  u = -c,
                  d = 1 + c,
                  h = [u, u, d, u, d, d, u, u, d, d, u, d],
                  f = 6,
                  p = 6,
                  _ = 3,
                  g = 2,
                  m = 1,
                  y = new Float32Array(_ * p * f),
                  v = new Float32Array(g * p * f),
                  b = new Float32Array(m * p * f);
                for (let E = 0; E < f; E++) {
                  const x = ((E % 3) * 2) / 3 - 1,
                    P = E > 2 ? 0 : -1;
                  y.set(
                    [
                      x,
                      P,
                      0,
                      x + 2 / 3,
                      P,
                      0,
                      x + 2 / 3,
                      P + 1,
                      0,
                      x,
                      P,
                      0,
                      x + 2 / 3,
                      P + 1,
                      0,
                      x,
                      P + 1,
                      0,
                    ],
                    _ * p * E,
                  ),
                    v.set(h, g * p * E),
                    b.set([E, E, E, E, E, E], m * p * E);
                }
                const S = new ht();
                S.setAttribute("position", new Pn(y, _)),
                  S.setAttribute("uv", new Pn(v, g)),
                  S.setAttribute("faceIndex", new Pn(b, m)),
                  e.push(S),
                  r > 4 && r--;
              }
              return { lodPlanes: e, sizeLods: t, sigmas: i };
            })(s)),
              (this._blurMaterial = (function y7(n, e, t) {
                const i = new Float32Array(20),
                  r = new D(0, 1, 0);
                return new Xs({
                  name: "SphericalGaussianBlur",
                  defines: {
                    n: 20,
                    CUBEUV_TEXEL_WIDTH: 1 / e,
                    CUBEUV_TEXEL_HEIGHT: 1 / t,
                    CUBEUV_MAX_MIP: `${n}.0`,
                  },
                  uniforms: {
                    envMap: { value: null },
                    samples: { value: 1 },
                    weights: { value: i },
                    latitudinal: { value: !1 },
                    dTheta: { value: 0 },
                    mipInt: { value: 0 },
                    poleAxis: { value: r },
                  },
                  vertexShader:
                    "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                  fragmentShader:
                    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                  blending: 0,
                  depthTest: !1,
                  depthWrite: !1,
                });
              })(s, e, t));
          }
          return r;
        }
        _compileMaterial(e) {
          const t = new ti(this._lodPlanes[0], e);
          this._renderer.compile(t, s0);
        }
        _sceneToCubeUV(e, t, i, r) {
          const a = new kn(90, 1, t, i),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            u = this._renderer,
            d = u.autoClear,
            h = u.toneMapping;
          u.getClearColor(PR), (u.toneMapping = Us), (u.autoClear = !1);
          const f = new qs({
              name: "PMREM.Background",
              side: 1,
              depthWrite: !1,
              depthTest: !1,
            }),
            p = new ti(new zo(), f);
          let _ = !1;
          const g = e.background;
          g
            ? g.isColor && (f.color.copy(g), (e.background = null), (_ = !0))
            : (f.color.copy(PR), (_ = !0));
          for (let m = 0; m < 6; m++) {
            const y = m % 3;
            0 === y
              ? (a.up.set(0, l[m], 0), a.lookAt(c[m], 0, 0))
              : 1 === y
              ? (a.up.set(0, 0, l[m]), a.lookAt(0, c[m], 0))
              : (a.up.set(0, l[m], 0), a.lookAt(0, 0, c[m]));
            const v = this._cubeSize;
            ip(r, y * v, m > 2 ? v : 0, v, v),
              u.setRenderTarget(r),
              _ && u.render(p, a),
              u.render(e, a);
          }
          p.geometry.dispose(),
            p.material.dispose(),
            (u.toneMapping = h),
            (u.autoClear = d),
            (e.background = g);
        }
        _textureToCubeUV(e, t) {
          const i = this._renderer,
            r = e.mapping === Bs || e.mapping === Io;
          r
            ? (null === this._cubemapMaterial && (this._cubemapMaterial = kR()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                !1 === e.isRenderTargetTexture ? -1 : 1))
            : null === this._equirectMaterial &&
              (this._equirectMaterial = FR());
          const s = r ? this._cubemapMaterial : this._equirectMaterial,
            o = new ti(this._lodPlanes[0], s);
          s.uniforms.envMap.value = e;
          const l = this._cubeSize;
          ip(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, s0);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            i = t.autoClear;
          t.autoClear = !1;
          for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(
              this._sigmas[r] * this._sigmas[r] -
                this._sigmas[r - 1] * this._sigmas[r - 1],
            );
            this._blur(e, r - 1, r, s, OR[(r - 1) % OR.length]);
          }
          t.autoClear = i;
        }
        _blur(e, t, i, r, s) {
          const o = this._pingPongRenderTarget;
          this._halfBlur(e, o, t, i, r, "latitudinal", s),
            this._halfBlur(o, e, i, i, r, "longitudinal", s);
        }
        _halfBlur(e, t, i, r, s, o, a) {
          const l = this._renderer,
            c = this._blurMaterial;
          "latitudinal" !== o &&
            "longitudinal" !== o &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!",
            );
          const d = new ti(this._lodPlanes[r], c),
            h = c.uniforms,
            f = this._sizeLods[i] - 1,
            p = isFinite(s) ? Math.PI / (2 * f) : (2 * Math.PI) / 39,
            _ = s / p,
            g = isFinite(s) ? 1 + Math.floor(3 * _) : 20;
          g > 20 &&
            console.warn(
              `sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to 20`,
            );
          const m = [];
          let y = 0;
          for (let x = 0; x < 20; ++x) {
            const P = x / _,
              M = Math.exp((-P * P) / 2);
            m.push(M), 0 === x ? (y += M) : x < g && (y += 2 * M);
          }
          for (let x = 0; x < m.length; x++) m[x] = m[x] / y;
          (h.envMap.value = e.texture),
            (h.samples.value = g),
            (h.weights.value = m),
            (h.latitudinal.value = "latitudinal" === o),
            a && (h.poleAxis.value = a);
          const { _lodMax: v } = this;
          (h.dTheta.value = p), (h.mipInt.value = v - i);
          const b = this._sizeLods[r];
          ip(
            t,
            3 * b * (r > v - 4 ? r - v + 4 : 0),
            4 * (this._cubeSize - b),
            3 * b,
            2 * b,
          ),
            l.setRenderTarget(t),
            l.render(d, s0);
        }
      }
      function LR(n, e, t) {
        const i = new Uo(n, e, t);
        return (
          (i.texture.mapping = Eu),
          (i.texture.name = "PMREM.cubeUv"),
          (i.scissorTest = !0),
          i
        );
      }
      function ip(n, e, t, i, r) {
        n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
      }
      function FR() {
        return new Xs({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function kR() {
        return new Xs({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function b7(n) {
        let e = new WeakMap(),
          t = null;
        function s(a) {
          const l = a.target;
          l.removeEventListener("dispose", s);
          const c = e.get(l);
          void 0 !== c && (e.delete(l), c.dispose());
        }
        return {
          get: function i(a) {
            if (a && a.isTexture) {
              const l = a.mapping,
                c = 303 === l || 304 === l,
                u = l === Bs || l === Io;
              if (c || u) {
                if (a.isRenderTargetTexture && !0 === a.needsPMREMUpdate) {
                  a.needsPMREMUpdate = !1;
                  let d = e.get(a);
                  return (
                    null === t && (t = new NR(n)),
                    (d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
                    e.set(a, d),
                    d.texture
                  );
                }
                if (e.has(a)) return e.get(a).texture;
                {
                  const d = a.image;
                  if (
                    (c && d && d.height > 0) ||
                    (u &&
                      d &&
                      (function r(a) {
                        let l = 0;
                        for (let u = 0; u < 6; u++) void 0 !== a[u] && l++;
                        return 6 === l;
                      })(d))
                  ) {
                    null === t && (t = new NR(n));
                    const h = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                    return (
                      e.set(a, h), a.addEventListener("dispose", s), h.texture
                    );
                  }
                  return null;
                }
              }
            }
            return a;
          },
          dispose: function o() {
            (e = new WeakMap()), null !== t && (t.dispose(), (t = null));
          },
        };
      }
      function M7(n) {
        const e = {};
        function t(i) {
          if (void 0 !== e[i]) return e[i];
          let r;
          switch (i) {
            case "WEBGL_depth_texture":
              r =
                n.getExtension("WEBGL_depth_texture") ||
                n.getExtension("MOZ_WEBGL_depth_texture") ||
                n.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              r =
                n.getExtension("EXT_texture_filter_anisotropic") ||
                n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              r =
                n.getExtension("WEBGL_compressed_texture_s3tc") ||
                n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              r =
                n.getExtension("WEBGL_compressed_texture_pvrtc") ||
                n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              r = n.getExtension(i);
          }
          return (e[i] = r), r;
        }
        return {
          has: function (i) {
            return null !== t(i);
          },
          init: function (i) {
            i.isWebGL2
              ? t("EXT_color_buffer_float")
              : (t("WEBGL_depth_texture"),
                t("OES_texture_float"),
                t("OES_texture_half_float"),
                t("OES_texture_half_float_linear"),
                t("OES_standard_derivatives"),
                t("OES_element_index_uint"),
                t("OES_vertex_array_object"),
                t("ANGLE_instanced_arrays")),
              t("OES_texture_float_linear"),
              t("EXT_color_buffer_half_float"),
              t("WEBGL_multisampled_render_to_texture");
          },
          get: function (i) {
            const r = t(i);
            return (
              null === r &&
                console.warn(
                  "THREE.WebGLRenderer: " + i + " extension not supported.",
                ),
              r
            );
          },
        };
      }
      function S7(n, e, t, i) {
        const r = {},
          s = new WeakMap();
        function o(d) {
          const h = d.target;
          null !== h.index && e.remove(h.index);
          for (const p in h.attributes) e.remove(h.attributes[p]);
          for (const p in h.morphAttributes) {
            const _ = h.morphAttributes[p];
            for (let g = 0, m = _.length; g < m; g++) e.remove(_[g]);
          }
          h.removeEventListener("dispose", o), delete r[h.id];
          const f = s.get(h);
          f && (e.remove(f), s.delete(h)),
            i.releaseStatesOfGeometry(h),
            !0 === h.isInstancedBufferGeometry && delete h._maxInstanceCount,
            t.memory.geometries--;
        }
        function c(d) {
          const h = [],
            f = d.index,
            p = d.attributes.position;
          let _ = 0;
          if (null !== f) {
            const y = f.array;
            _ = f.version;
            for (let v = 0, b = y.length; v < b; v += 3) {
              const S = y[v + 0],
                E = y[v + 1],
                x = y[v + 2];
              h.push(S, E, E, x, x, S);
            }
          } else {
            if (void 0 === p) return;
            _ = p.version;
            for (let v = 0, b = p.array.length / 3 - 1; v < b; v += 3) {
              const S = v + 0,
                E = v + 1,
                x = v + 2;
              h.push(S, E, E, x, x, S);
            }
          }
          const g = new (lR(h) ? wR : SR)(h, 1);
          g.version = _;
          const m = s.get(d);
          m && e.remove(m), s.set(d, g);
        }
        return {
          get: function a(d, h) {
            return (
              !0 === r[h.id] ||
                (h.addEventListener("dispose", o),
                (r[h.id] = !0),
                t.memory.geometries++),
              h
            );
          },
          update: function l(d) {
            const h = d.attributes;
            for (const p in h) e.update(h[p], n.ARRAY_BUFFER);
            const f = d.morphAttributes;
            for (const p in f) {
              const _ = f[p];
              for (let g = 0, m = _.length; g < m; g++)
                e.update(_[g], n.ARRAY_BUFFER);
            }
          },
          getWireframeAttribute: function u(d) {
            const h = s.get(d);
            if (h) {
              const f = d.index;
              null !== f && h.version < f.version && c(d);
            } else c(d);
            return s.get(d);
          },
        };
      }
      function w7(n, e, t, i) {
        const r = i.isWebGL2;
        let s, a, l;
        (this.setMode = function o(h) {
          s = h;
        }),
          (this.setIndex = function c(h) {
            (a = h.type), (l = h.bytesPerElement);
          }),
          (this.render = function u(h, f) {
            n.drawElements(s, f, a, h * l), t.update(f, s, 1);
          }),
          (this.renderInstances = function d(h, f, p) {
            if (0 === p) return;
            let _, g;
            if (r) (_ = n), (g = "drawElementsInstanced");
            else if (
              ((_ = e.get("ANGLE_instanced_arrays")),
              (g = "drawElementsInstancedANGLE"),
              null === _)
            )
              return void console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
              );
            _[g](s, f, a, h * l, p), t.update(f, s, p);
          });
      }
      function E7(n) {
        const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function r() {
            (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
          },
          update: function i(s, o, a) {
            switch ((t.calls++, o)) {
              case n.TRIANGLES:
                t.triangles += a * (s / 3);
                break;
              case n.LINES:
                t.lines += a * (s / 2);
                break;
              case n.LINE_STRIP:
                t.lines += a * (s - 1);
                break;
              case n.LINE_LOOP:
                t.lines += a * s;
                break;
              case n.POINTS:
                t.points += a * s;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            }
          },
        };
      }
      function C7(n, e) {
        return n[0] - e[0];
      }
      function x7(n, e) {
        return Math.abs(e[1]) - Math.abs(n[1]);
      }
      function T7(n, e, t) {
        const i = {},
          r = new Float32Array(8),
          s = new WeakMap(),
          o = new Ut(),
          a = [];
        for (let c = 0; c < 8; c++) a[c] = [c, 0];
        return {
          update: function l(c, u, d) {
            const h = c.morphTargetInfluences;
            if (!0 === e.isWebGL2) {
              const f =
                  u.morphAttributes.position ||
                  u.morphAttributes.normal ||
                  u.morphAttributes.color,
                p = void 0 !== f ? f.length : 0;
              let _ = s.get(u);
              if (void 0 === _ || _.count !== p) {
                let z = function () {
                  ie.dispose(),
                    s.delete(u),
                    u.removeEventListener("dispose", z);
                };
                void 0 !== _ && _.texture.dispose();
                const y = void 0 !== u.morphAttributes.position,
                  v = void 0 !== u.morphAttributes.normal,
                  b = void 0 !== u.morphAttributes.color,
                  S = u.morphAttributes.position || [],
                  E = u.morphAttributes.normal || [],
                  x = u.morphAttributes.color || [];
                let P = 0;
                !0 === y && (P = 1), !0 === v && (P = 2), !0 === b && (P = 3);
                let M = u.attributes.position.count * P,
                  C = 1;
                M > e.maxTextureSize &&
                  ((C = Math.ceil(M / e.maxTextureSize)),
                  (M = e.maxTextureSize));
                const $ = new Float32Array(M * C * 4 * p),
                  ie = new By($, M, C, p);
                (ie.type = as), (ie.needsUpdate = !0);
                const V = 4 * P;
                for (let W = 0; W < p; W++) {
                  const F = S[W],
                    N = E[W],
                    k = x[W],
                    q = M * C * 4 * W;
                  for (let ee = 0; ee < F.count; ee++) {
                    const U = ee * V;
                    !0 === y &&
                      (o.fromBufferAttribute(F, ee),
                      ($[q + U + 0] = o.x),
                      ($[q + U + 1] = o.y),
                      ($[q + U + 2] = o.z),
                      ($[q + U + 3] = 0)),
                      !0 === v &&
                        (o.fromBufferAttribute(N, ee),
                        ($[q + U + 4] = o.x),
                        ($[q + U + 5] = o.y),
                        ($[q + U + 6] = o.z),
                        ($[q + U + 7] = 0)),
                      !0 === b &&
                        (o.fromBufferAttribute(k, ee),
                        ($[q + U + 8] = o.x),
                        ($[q + U + 9] = o.y),
                        ($[q + U + 10] = o.z),
                        ($[q + U + 11] = 4 === k.itemSize ? o.w : 1));
                  }
                }
                (_ = { count: p, texture: ie, size: new oe(M, C) }),
                  s.set(u, _),
                  u.addEventListener("dispose", z);
              }
              let g = 0;
              for (let y = 0; y < h.length; y++) g += h[y];
              const m = u.morphTargetsRelative ? 1 : 1 - g;
              d.getUniforms().setValue(n, "morphTargetBaseInfluence", m),
                d.getUniforms().setValue(n, "morphTargetInfluences", h),
                d
                  .getUniforms()
                  .setValue(n, "morphTargetsTexture", _.texture, t),
                d.getUniforms().setValue(n, "morphTargetsTextureSize", _.size);
            } else {
              const f = void 0 === h ? 0 : h.length;
              let p = i[u.id];
              if (void 0 === p || p.length !== f) {
                p = [];
                for (let v = 0; v < f; v++) p[v] = [v, 0];
                i[u.id] = p;
              }
              for (let v = 0; v < f; v++) {
                const b = p[v];
                (b[0] = v), (b[1] = h[v]);
              }
              p.sort(x7);
              for (let v = 0; v < 8; v++)
                v < f && p[v][1]
                  ? ((a[v][0] = p[v][0]), (a[v][1] = p[v][1]))
                  : ((a[v][0] = Number.MAX_SAFE_INTEGER), (a[v][1] = 0));
              a.sort(C7);
              const _ = u.morphAttributes.position,
                g = u.morphAttributes.normal;
              let m = 0;
              for (let v = 0; v < 8; v++) {
                const b = a[v],
                  S = b[0],
                  E = b[1];
                S !== Number.MAX_SAFE_INTEGER && E
                  ? (_ &&
                      u.getAttribute("morphTarget" + v) !== _[S] &&
                      u.setAttribute("morphTarget" + v, _[S]),
                    g &&
                      u.getAttribute("morphNormal" + v) !== g[S] &&
                      u.setAttribute("morphNormal" + v, g[S]),
                    (r[v] = E),
                    (m += E))
                  : (_ &&
                      !0 === u.hasAttribute("morphTarget" + v) &&
                      u.deleteAttribute("morphTarget" + v),
                    g &&
                      !0 === u.hasAttribute("morphNormal" + v) &&
                      u.deleteAttribute("morphNormal" + v),
                    (r[v] = 0));
              }
              const y = u.morphTargetsRelative ? 1 : 1 - m;
              d.getUniforms().setValue(n, "morphTargetBaseInfluence", y),
                d.getUniforms().setValue(n, "morphTargetInfluences", r);
            }
          },
        };
      }
      function D7(n, e, t, i) {
        let r = new WeakMap();
        function a(l) {
          const c = l.target;
          c.removeEventListener("dispose", a),
            t.remove(c.instanceMatrix),
            null !== c.instanceColor && t.remove(c.instanceColor);
        }
        return {
          update: function s(l) {
            const c = i.render.frame,
              d = e.get(l, l.geometry);
            if (
              (r.get(d) !== c && (e.update(d), r.set(d, c)),
              l.isInstancedMesh &&
                (!1 === l.hasEventListener("dispose", a) &&
                  l.addEventListener("dispose", a),
                r.get(l) !== c &&
                  (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
                  null !== l.instanceColor &&
                    t.update(l.instanceColor, n.ARRAY_BUFFER),
                  r.set(l, c))),
              l.isSkinnedMesh)
            ) {
              const h = l.skeleton;
              r.get(h) !== c && (h.update(), r.set(h, c));
            }
            return d;
          },
          dispose: function o() {
            r = new WeakMap();
          },
        };
      }
      const UR = new zs(),
        BR = new By(),
        VR = new dR(),
        HR = new Jf(),
        zR = [],
        GR = [],
        WR = new Float32Array(16),
        $R = new Float32Array(9),
        jR = new Float32Array(4);
      function Hl(n, e, t) {
        const i = n[0];
        if (i <= 0 || i > 0) return n;
        const r = e * t;
        let s = zR[r];
        if (
          (void 0 === s && ((s = new Float32Array(r)), (zR[r] = s)), 0 !== e)
        ) {
          i.toArray(s, 0);
          for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
        }
        return s;
      }
      function Tn(n, e) {
        if (n.length !== e.length) return !1;
        for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
        return !0;
      }
      function Dn(n, e) {
        for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
      }
      function rp(n, e) {
        let t = GR[e];
        void 0 === t && ((t = new Int32Array(e)), (GR[e] = t));
        for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
        return t;
      }
      function A7(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
      }
      function I7(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y) &&
            (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (Tn(t, e)) return;
          n.uniform2fv(this.addr, e), Dn(t, e);
        }
      }
      function R7(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (n.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else if (void 0 !== e.r)
          (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (n.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
        else {
          if (Tn(t, e)) return;
          n.uniform3fv(this.addr, e), Dn(t, e);
        }
      }
      function P7(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (Tn(t, e)) return;
          n.uniform4fv(this.addr, e), Dn(t, e);
        }
      }
      function O7(n, e) {
        const t = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (Tn(t, e)) return;
          n.uniformMatrix2fv(this.addr, !1, e), Dn(t, e);
        } else {
          if (Tn(t, i)) return;
          jR.set(i), n.uniformMatrix2fv(this.addr, !1, jR), Dn(t, i);
        }
      }
      function N7(n, e) {
        const t = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (Tn(t, e)) return;
          n.uniformMatrix3fv(this.addr, !1, e), Dn(t, e);
        } else {
          if (Tn(t, i)) return;
          $R.set(i), n.uniformMatrix3fv(this.addr, !1, $R), Dn(t, i);
        }
      }
      function L7(n, e) {
        const t = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (Tn(t, e)) return;
          n.uniformMatrix4fv(this.addr, !1, e), Dn(t, e);
        } else {
          if (Tn(t, i)) return;
          WR.set(i), n.uniformMatrix4fv(this.addr, !1, WR), Dn(t, i);
        }
      }
      function F7(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
      }
      function k7(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y) &&
            (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (Tn(t, e)) return;
          n.uniform2iv(this.addr, e), Dn(t, e);
        }
      }
      function U7(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (n.uniform3i(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else {
          if (Tn(t, e)) return;
          n.uniform3iv(this.addr, e), Dn(t, e);
        }
      }
      function B7(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (Tn(t, e)) return;
          n.uniform4iv(this.addr, e), Dn(t, e);
        }
      }
      function V7(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
      }
      function H7(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y) &&
            (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (Tn(t, e)) return;
          n.uniform2uiv(this.addr, e), Dn(t, e);
        }
      }
      function z7(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (n.uniform3ui(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else {
          if (Tn(t, e)) return;
          n.uniform3uiv(this.addr, e), Dn(t, e);
        }
      }
      function G7(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (Tn(t, e)) return;
          n.uniform4uiv(this.addr, e), Dn(t, e);
        }
      }
      function W7(n, e, t) {
        const i = this.cache,
          r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
          t.setTexture2D(e || UR, r);
      }
      function $7(n, e, t) {
        const i = this.cache,
          r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
          t.setTexture3D(e || VR, r);
      }
      function j7(n, e, t) {
        const i = this.cache,
          r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
          t.setTextureCube(e || HR, r);
      }
      function q7(n, e, t) {
        const i = this.cache,
          r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
          t.setTexture2DArray(e || BR, r);
      }
      function Y7(n, e) {
        n.uniform1fv(this.addr, e);
      }
      function Z7(n, e) {
        const t = Hl(e, this.size, 2);
        n.uniform2fv(this.addr, t);
      }
      function K7(n, e) {
        const t = Hl(e, this.size, 3);
        n.uniform3fv(this.addr, t);
      }
      function Q7(n, e) {
        const t = Hl(e, this.size, 4);
        n.uniform4fv(this.addr, t);
      }
      function J7(n, e) {
        const t = Hl(e, this.size, 4);
        n.uniformMatrix2fv(this.addr, !1, t);
      }
      function e9(n, e) {
        const t = Hl(e, this.size, 9);
        n.uniformMatrix3fv(this.addr, !1, t);
      }
      function t9(n, e) {
        const t = Hl(e, this.size, 16);
        n.uniformMatrix4fv(this.addr, !1, t);
      }
      function n9(n, e) {
        n.uniform1iv(this.addr, e);
      }
      function i9(n, e) {
        n.uniform2iv(this.addr, e);
      }
      function r9(n, e) {
        n.uniform3iv(this.addr, e);
      }
      function s9(n, e) {
        n.uniform4iv(this.addr, e);
      }
      function o9(n, e) {
        n.uniform1uiv(this.addr, e);
      }
      function a9(n, e) {
        n.uniform2uiv(this.addr, e);
      }
      function l9(n, e) {
        n.uniform3uiv(this.addr, e);
      }
      function c9(n, e) {
        n.uniform4uiv(this.addr, e);
      }
      function u9(n, e, t) {
        const i = this.cache,
          r = e.length,
          s = rp(t, r);
        Tn(i, s) || (n.uniform1iv(this.addr, s), Dn(i, s));
        for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || UR, s[o]);
      }
      function d9(n, e, t) {
        const i = this.cache,
          r = e.length,
          s = rp(t, r);
        Tn(i, s) || (n.uniform1iv(this.addr, s), Dn(i, s));
        for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || VR, s[o]);
      }
      function h9(n, e, t) {
        const i = this.cache,
          r = e.length,
          s = rp(t, r);
        Tn(i, s) || (n.uniform1iv(this.addr, s), Dn(i, s));
        for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || HR, s[o]);
      }
      function f9(n, e, t) {
        const i = this.cache,
          r = e.length,
          s = rp(t, r);
        Tn(i, s) || (n.uniform1iv(this.addr, s), Dn(i, s));
        for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || BR, s[o]);
      }
      class m9 {
        constructor(e, t, i) {
          (this.id = e),
            (this.addr = i),
            (this.cache = []),
            (this.setValue = (function X7(n) {
              switch (n) {
                case 5126:
                  return A7;
                case 35664:
                  return I7;
                case 35665:
                  return R7;
                case 35666:
                  return P7;
                case 35674:
                  return O7;
                case 35675:
                  return N7;
                case 35676:
                  return L7;
                case 5124:
                case 35670:
                  return F7;
                case 35667:
                case 35671:
                  return k7;
                case 35668:
                case 35672:
                  return U7;
                case 35669:
                case 35673:
                  return B7;
                case 5125:
                  return V7;
                case 36294:
                  return H7;
                case 36295:
                  return z7;
                case 36296:
                  return G7;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return W7;
                case 35679:
                case 36299:
                case 36307:
                  return $7;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return j7;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return q7;
              }
            })(t.type));
        }
      }
      class g9 {
        constructor(e, t, i) {
          (this.id = e),
            (this.addr = i),
            (this.cache = []),
            (this.size = t.size),
            (this.setValue = (function p9(n) {
              switch (n) {
                case 5126:
                  return Y7;
                case 35664:
                  return Z7;
                case 35665:
                  return K7;
                case 35666:
                  return Q7;
                case 35674:
                  return J7;
                case 35675:
                  return e9;
                case 35676:
                  return t9;
                case 5124:
                case 35670:
                  return n9;
                case 35667:
                case 35671:
                  return i9;
                case 35668:
                case 35672:
                  return r9;
                case 35669:
                case 35673:
                  return s9;
                case 5125:
                  return o9;
                case 36294:
                  return a9;
                case 36295:
                  return l9;
                case 36296:
                  return c9;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return u9;
                case 35679:
                case 36299:
                case 36307:
                  return d9;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return h9;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return f9;
              }
            })(t.type));
        }
      }
      class _9 {
        constructor(e) {
          (this.id = e), (this.seq = []), (this.map = {});
        }
        setValue(e, t, i) {
          const r = this.seq;
          for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i);
          }
        }
      }
      const l0 = /(\w+)(\])?(\[|\.)?/g;
      function qR(n, e) {
        n.seq.push(e), (n.map[e.id] = e);
      }
      function v9(n, e, t) {
        const i = n.name,
          r = i.length;
        for (l0.lastIndex = 0; ; ) {
          const s = l0.exec(i);
          let a = s[1];
          const c = s[3];
          if (
            ("]" === s[2] && (a |= 0),
            void 0 === c || ("[" === c && l0.lastIndex + 2 === r))
          ) {
            qR(t, void 0 === c ? new m9(a, n, e) : new g9(a, n, e));
            break;
          }
          {
            let d = t.map[a];
            void 0 === d && ((d = new _9(a)), qR(t, d)), (t = d);
          }
        }
      }
      class sp {
        constructor(e, t) {
          (this.seq = []), (this.map = {});
          const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
          for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r);
            v9(s, e.getUniformLocation(t, s.name), this);
          }
        }
        setValue(e, t, i, r) {
          const s = this.map[t];
          void 0 !== s && s.setValue(e, i, r);
        }
        setOptional(e, t, i) {
          const r = t[i];
          void 0 !== r && this.setValue(e, i, r);
        }
        static upload(e, t, i, r) {
          for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s],
              l = i[a.id];
            !1 !== l.needsUpdate && a.setValue(e, l.value, r);
          }
        }
        static seqWithValue(e, t) {
          const i = [];
          for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o);
          }
          return i;
        }
      }
      function XR(n, e, t) {
        const i = n.createShader(e);
        return n.shaderSource(i, t), n.compileShader(i), i;
      }
      let y9 = 0;
      function YR(n, e, t) {
        const i = n.getShaderParameter(e, n.COMPILE_STATUS),
          r = n.getShaderInfoLog(e).trim();
        if (i && "" === r) return "";
        const s = /ERROR: 0:(\d+)/.exec(r);
        if (s) {
          const o = parseInt(s[1]);
          return (
            t.toUpperCase() +
            "\n\n" +
            r +
            "\n\n" +
            (function b9(n, e) {
              const t = n.split("\n"),
                i = [],
                r = Math.max(e - 6, 0),
                s = Math.min(e + 6, t.length);
              for (let o = r; o < s; o++) {
                const a = o + 1;
                i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
              }
              return i.join("\n");
            })(n.getShaderSource(e), o)
          );
        }
        return r;
      }
      function S9(n, e) {
        const t = (function M9(n) {
          switch (n) {
            case Nr:
              return ["Linear", "( value )"];
            case rt:
              return ["sRGB", "( value )"];
            default:
              return (
                console.warn("THREE.WebGLProgram: Unsupported color space:", n),
                ["Linear", "( value )"]
              );
          }
        })(e);
        return (
          "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
        );
      }
      function w9(n, e) {
        let t;
        switch (e) {
          case Zj:
            t = "Linear";
            break;
          case Kj:
            t = "Reinhard";
            break;
          case Qj:
            t = "OptimizedCineon";
            break;
          case Jj:
            t = "ACESFilmic";
            break;
          case e8:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (t = "Linear");
        }
        return (
          "vec3 " +
          n +
          "( vec3 color ) { return " +
          t +
          "ToneMapping( color ); }"
        );
      }
      function Fu(n) {
        return "" !== n;
      }
      function ZR(n, e) {
        const t =
          e.numSpotLightShadows +
          e.numSpotLightMaps -
          e.numSpotLightShadowsWithMaps;
        return n
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
          .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(
            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
            e.numSpotLightShadowsWithMaps,
          )
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function KR(n, e) {
        return n
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection,
          );
      }
      const T9 = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function c0(n) {
        return n.replace(T9, A9);
      }
      const D9 = new Map([
        ["encodings_fragment", "colorspace_fragment"],
        ["encodings_pars_fragment", "colorspace_pars_fragment"],
        ["output_fragment", "opaque_fragment"],
      ]);
      function A9(n, e) {
        let t = at[e];
        if (void 0 === t) {
          const i = D9.get(e);
          if (void 0 === i)
            throw new Error("Can not resolve #include <" + e + ">");
          (t = at[i]),
            console.warn(
              'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
              e,
              i,
            );
        }
        return c0(t);
      }
      const I9 =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function QR(n) {
        return n.replace(I9, R9);
      }
      function R9(n, e, t, i) {
        let r = "";
        for (let s = parseInt(e); s < parseInt(t); s++)
          r += i
            .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, s);
        return r;
      }
      function JR(n) {
        let e =
          "precision " +
          n.precision +
          " float;\nprecision " +
          n.precision +
          " int;";
        return (
          "highp" === n.precision
            ? (e += "\n#define HIGH_PRECISION")
            : "mediump" === n.precision
            ? (e += "\n#define MEDIUM_PRECISION")
            : "lowp" === n.precision && (e += "\n#define LOW_PRECISION"),
          e
        );
      }
      function k9(n, e, t, i) {
        const r = n.getContext(),
          s = t.defines;
        let o = t.vertexShader,
          a = t.fragmentShader;
        const l = (function P9(n) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return (
              n.shadowMapType === vI
                ? (e = "SHADOWMAP_TYPE_PCF")
                : n.shadowMapType === Dj
                ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                : n.shadowMapType === ss && (e = "SHADOWMAP_TYPE_VSM"),
              e
            );
          })(t),
          c = (function O9(n) {
            let e = "ENVMAP_TYPE_CUBE";
            if (n.envMap)
              switch (n.envMapMode) {
                case Bs:
                case Io:
                  e = "ENVMAP_TYPE_CUBE";
                  break;
                case Eu:
                  e = "ENVMAP_TYPE_CUBE_UV";
              }
            return e;
          })(t),
          u = (function N9(n) {
            let e = "ENVMAP_MODE_REFLECTION";
            return (
              n.envMap && n.envMapMode === Io && (e = "ENVMAP_MODE_REFRACTION"),
              e
            );
          })(t),
          d = (function L9(n) {
            let e = "ENVMAP_BLENDING_NONE";
            if (n.envMap)
              switch (n.combine) {
                case Ef:
                  e = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case Xj:
                  e = "ENVMAP_BLENDING_MIX";
                  break;
                case Yj:
                  e = "ENVMAP_BLENDING_ADD";
              }
            return e;
          })(t),
          h = (function F9(n) {
            const e = n.envMapCubeUVHeight;
            if (null === e) return null;
            const t = Math.log2(e) - 2,
              i = 1 / e;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
              texelHeight: i,
              maxMip: t,
            };
          })(t),
          f = t.isWebGL2
            ? ""
            : (function E9(n) {
                return [
                  n.extensionDerivatives ||
                  n.envMapCubeUVHeight ||
                  n.bumpMap ||
                  n.normalMapTangentSpace ||
                  n.clearcoatNormalMap ||
                  n.flatShading ||
                  "physical" === n.shaderID
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
                  n.rendererExtensionFragDepth
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
                  n.rendererExtensionShaderTextureLod
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(Fu)
                  .join("\n");
              })(t),
          p = (function C9(n) {
            const e = [];
            for (const t in n) {
              const i = n[t];
              !1 !== i && e.push("#define " + t + " " + i);
            }
            return e.join("\n");
          })(s),
          _ = r.createProgram();
        let g,
          m,
          y = t.glslVersion ? "#version " + t.glslVersion + "\n" : "";
        t.isRawShaderMaterial
          ? ((g = [
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              p,
            ]
              .filter(Fu)
              .join("\n")),
            g.length > 0 && (g += "\n"),
            (m = [
              f,
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              p,
            ]
              .filter(Fu)
              .join("\n")),
            m.length > 0 && (m += "\n"))
          : ((g = [
              JR(t),
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              p,
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + u : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              t.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              t.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaHash ? "#define USE_ALPHAHASH" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              t.mapUv ? "#define MAP_UV " + t.mapUv : "",
              t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
              t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
              t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
              t.emissiveMapUv
                ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv
                : "",
              t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
              t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
              t.displacementMapUv
                ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
                : "",
              t.metalnessMapUv
                ? "#define METALNESSMAP_UV " + t.metalnessMapUv
                : "",
              t.roughnessMapUv
                ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv
                : "",
              t.anisotropyMapUv
                ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
                : "",
              t.clearcoatMapUv
                ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv
                : "",
              t.clearcoatNormalMapUv
                ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
                : "",
              t.clearcoatRoughnessMapUv
                ? "#define CLEARCOAT_ROUGHNESSMAP_UV " +
                  t.clearcoatRoughnessMapUv
                : "",
              t.iridescenceMapUv
                ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
                : "",
              t.iridescenceThicknessMapUv
                ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
                  t.iridescenceThicknessMapUv
                : "",
              t.sheenColorMapUv
                ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
                : "",
              t.sheenRoughnessMapUv
                ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
                : "",
              t.specularMapUv
                ? "#define SPECULARMAP_UV " + t.specularMapUv
                : "",
              t.specularColorMapUv
                ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
                : "",
              t.specularIntensityMapUv
                ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
                : "",
              t.transmissionMapUv
                ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
                : "",
              t.thicknessMapUv
                ? "#define THICKNESSMAP_UV " + t.thicknessMapUv
                : "",
              t.vertexTangents && !1 === t.flatShading
                ? "#define USE_TANGENT"
                : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUv1s ? "#define USE_UV1" : "",
              t.vertexUv2s ? "#define USE_UV2" : "",
              t.vertexUv3s ? "#define USE_UV3" : "",
              t.pointsUvs ? "#define USE_POINTS_UV" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && !1 === t.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
                : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_UV1",
              "\tattribute vec2 uv1;",
              "#endif",
              "#ifdef USE_UV2",
              "\tattribute vec2 uv2;",
              "#endif",
              "#ifdef USE_UV3",
              "\tattribute vec2 uv3;",
              "#endif",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(Fu)
              .join("\n")),
            (m = [
              f,
              JR(t),
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              p,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + c : "",
              t.envMap ? "#define " + u : "",
              t.envMap ? "#define " + d : "",
              h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
              h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
              h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              t.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.anisotropy ? "#define USE_ANISOTROPY" : "",
              t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              t.clearcoat ? "#define USE_CLEARCOAT" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.iridescence ? "#define USE_IRIDESCENCE" : "",
              t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              t.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaTest ? "#define USE_ALPHATEST" : "",
              t.alphaHash ? "#define USE_ALPHAHASH" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents && !1 === t.flatShading
                ? "#define USE_TANGENT"
                : "",
              t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUv1s ? "#define USE_UV1" : "",
              t.vertexUv2s ? "#define USE_UV2" : "",
              t.vertexUv3s ? "#define USE_UV3" : "",
              t.pointsUvs ? "#define USE_POINTS_UV" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== Us ? "#define TONE_MAPPING" : "",
              t.toneMapping !== Us ? at.tonemapping_pars_fragment : "",
              t.toneMapping !== Us ? w9("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              t.opaque ? "#define OPAQUE" : "",
              at.colorspace_pars_fragment,
              S9("linearToOutputTexel", t.outputColorSpace),
              t.useDepthPacking
                ? "#define DEPTH_PACKING " + t.depthPacking
                : "",
              "\n",
            ]
              .filter(Fu)
              .join("\n"))),
          (o = c0(o)),
          (o = ZR(o, t)),
          (o = KR(o, t)),
          (a = c0(a)),
          (a = ZR(a, t)),
          (a = KR(a, t)),
          (o = QR(o)),
          (a = QR(a)),
          t.isWebGL2 &&
            !0 !== t.isRawShaderMaterial &&
            ((y = "#version 300 es\n"),
            (g =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              g),
            (m =
              [
                "#define varying in",
                t.glslVersion === sR
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                t.glslVersion === sR ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              m));
        const b = y + m + a,
          S = XR(r, r.VERTEX_SHADER, y + g + o),
          E = XR(r, r.FRAGMENT_SHADER, b);
        if (
          (r.attachShader(_, S),
          r.attachShader(_, E),
          void 0 !== t.index0AttributeName
            ? r.bindAttribLocation(_, 0, t.index0AttributeName)
            : !0 === t.morphTargets && r.bindAttribLocation(_, 0, "position"),
          r.linkProgram(_),
          n.debug.checkShaderErrors)
        ) {
          const M = r.getProgramInfoLog(_).trim(),
            C = r.getShaderInfoLog(S).trim(),
            $ = r.getShaderInfoLog(E).trim();
          let ie = !0,
            V = !0;
          if (!1 === r.getProgramParameter(_, r.LINK_STATUS))
            if (((ie = !1), "function" == typeof n.debug.onShaderError))
              n.debug.onShaderError(r, _, S, E);
            else {
              const z = YR(r, S, "vertex"),
                W = YR(r, E, "fragment");
              console.error(
                "THREE.WebGLProgram: Shader Error " +
                  r.getError() +
                  " - VALIDATE_STATUS " +
                  r.getProgramParameter(_, r.VALIDATE_STATUS) +
                  "\n\nProgram Info Log: " +
                  M +
                  "\n" +
                  z +
                  "\n" +
                  W,
              );
            }
          else
            "" !== M
              ? console.warn("THREE.WebGLProgram: Program Info Log:", M)
              : ("" === C || "" === $) && (V = !1);
          V &&
            (this.diagnostics = {
              runnable: ie,
              programLog: M,
              vertexShader: { log: C, prefix: g },
              fragmentShader: { log: $, prefix: m },
            });
        }
        let x, P;
        return (
          r.deleteShader(S),
          r.deleteShader(E),
          (this.getUniforms = function () {
            return void 0 === x && (x = new sp(r, _)), x;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === P &&
                (P = (function x9(n, e) {
                  const t = {},
                    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
                  for (let r = 0; r < i; r++) {
                    const s = n.getActiveAttrib(e, r),
                      o = s.name;
                    let a = 1;
                    s.type === n.FLOAT_MAT2 && (a = 2),
                      s.type === n.FLOAT_MAT3 && (a = 3),
                      s.type === n.FLOAT_MAT4 && (a = 4),
                      (t[o] = {
                        type: s.type,
                        location: n.getAttribLocation(e, o),
                        locationSize: a,
                      });
                  }
                  return t;
                })(r, _)),
              P
            );
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              r.deleteProgram(_),
              (this.program = void 0);
          }),
          (this.type = t.shaderType),
          (this.name = t.shaderName),
          (this.id = y9++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = _),
          (this.vertexShader = S),
          (this.fragmentShader = E),
          this
        );
      }
      let U9 = 0;
      class B9 {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
          const i = e.fragmentShader,
            r = this._getShaderStage(e.vertexShader),
            s = this._getShaderStage(i),
            o = this._getShaderCacheForMaterial(e);
          return (
            !1 === o.has(r) && (o.add(r), r.usedTimes++),
            !1 === o.has(s) && (o.add(s), s.usedTimes++),
            this
          );
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const i of t)
            i.usedTimes--, 0 === i.usedTimes && this.shaderCache.delete(i.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let i = t.get(e);
          return void 0 === i && ((i = new Set()), t.set(e, i)), i;
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          let i = t.get(e);
          return void 0 === i && ((i = new V9(e)), t.set(e, i)), i;
        }
      }
      class V9 {
        constructor(e) {
          (this.id = U9++), (this.code = e), (this.usedTimes = 0);
        }
      }
      function H9(n, e, t, i, r, s, o) {
        const a = new jy(),
          l = new B9(),
          c = [],
          u = r.isWebGL2,
          d = r.logarithmicDepthBuffer,
          h = r.vertexTextures;
        let f = r.precision;
        const p = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function _(M) {
          return 0 === M ? "uv" : `uv${M}`;
        }
        return {
          getParameters: function g(M, C, $, ie, V) {
            const z = ie.fog,
              W = V.geometry,
              N = (M.isMeshStandardMaterial ? t : e).get(
                M.envMap || (M.isMeshStandardMaterial ? ie.environment : null),
              ),
              k = N && N.mapping === Eu ? N.image.height : null,
              q = p[M.type];
            null !== M.precision &&
              ((f = r.getMaxPrecision(M.precision)),
              f !== M.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  M.precision,
                  "not supported, using",
                  f,
                  "instead.",
                ));
            const ee =
                W.morphAttributes.position ||
                W.morphAttributes.normal ||
                W.morphAttributes.color,
              U = void 0 !== ee ? ee.length : 0;
            let fe,
              le,
              be,
              Le,
              K = 0;
            if (
              (void 0 !== W.morphAttributes.position && (K = 1),
              void 0 !== W.morphAttributes.normal && (K = 2),
              void 0 !== W.morphAttributes.color && (K = 3),
              q)
            ) {
              const Xt = Fr[q];
              (fe = Xt.vertexShader), (le = Xt.fragmentShader);
            } else
              (fe = M.vertexShader),
                (le = M.fragmentShader),
                l.update(M),
                (be = l.getVertexShaderID(M)),
                (Le = l.getFragmentShaderID(M));
            const Me = n.getRenderTarget(),
              Re = !0 === V.isInstancedMesh,
              Je = !!M.map,
              Be = !!N,
              R = !!M.aoMap,
              me = !!M.lightMap,
              te = !!M.bumpMap,
              he = !!M.normalMap,
              ae = !!M.displacementMap,
              Fe = !!M.emissiveMap,
              xe = !!M.metalnessMap,
              Ae = !!M.roughnessMap,
              et = M.anisotropy > 0,
              _t = M.clearcoat > 0,
              sn = M.iridescence > 0,
              I = M.sheen > 0,
              w = M.transmission > 0,
              G = et && !!M.anisotropyMap,
              ue = _t && !!M.clearcoatMap,
              ce = _t && !!M.clearcoatNormalMap,
              de = _t && !!M.clearcoatRoughnessMap,
              Ne = sn && !!M.iridescenceMap,
              pe = sn && !!M.iridescenceThicknessMap,
              j = I && !!M.sheenColorMap,
              He = I && !!M.sheenRoughnessMap,
              ke = !!M.specularMap,
              Ve = !!M.specularColorMap,
              Pe = !!M.specularIntensityMap,
              Oe = w && !!M.transmissionMap,
              ft = w && !!M.thicknessMap,
              O = !!M.alphaMap,
              ge = !!M.extensions,
              Se = !!W.attributes.uv1,
              St = !!W.attributes.uv2,
              Jt = !!W.attributes.uv3;
            let yn = Us;
            return (
              M.toneMapped &&
                (null === Me || !0 === Me.isXRRenderTarget) &&
                (yn = n.toneMapping),
              {
                isWebGL2: u,
                shaderID: q,
                shaderType: M.type,
                shaderName: M.name,
                vertexShader: fe,
                fragmentShader: le,
                defines: M.defines,
                customVertexShaderID: be,
                customFragmentShaderID: Le,
                isRawShaderMaterial: !0 === M.isRawShaderMaterial,
                glslVersion: M.glslVersion,
                precision: f,
                instancing: Re,
                instancingColor: Re && null !== V.instanceColor,
                supportsVertexTextures: h,
                outputColorSpace:
                  null === Me
                    ? n.outputColorSpace
                    : !0 === Me.isXRRenderTarget
                    ? Me.texture.colorSpace
                    : Nr,
                map: Je,
                matcap: !!M.matcap,
                envMap: Be,
                envMapMode: Be && N.mapping,
                envMapCubeUVHeight: k,
                aoMap: R,
                lightMap: me,
                bumpMap: te,
                normalMap: he,
                displacementMap: h && ae,
                emissiveMap: Fe,
                normalMapObjectSpace: he && 1 === M.normalMapType,
                normalMapTangentSpace: he && 0 === M.normalMapType,
                metalnessMap: xe,
                roughnessMap: Ae,
                anisotropy: et,
                anisotropyMap: G,
                clearcoat: _t,
                clearcoatMap: ue,
                clearcoatNormalMap: ce,
                clearcoatRoughnessMap: de,
                iridescence: sn,
                iridescenceMap: Ne,
                iridescenceThicknessMap: pe,
                sheen: I,
                sheenColorMap: j,
                sheenRoughnessMap: He,
                specularMap: ke,
                specularColorMap: Ve,
                specularIntensityMap: Pe,
                transmission: w,
                transmissionMap: Oe,
                thicknessMap: ft,
                gradientMap: !!M.gradientMap,
                opaque: !1 === M.transparent && 1 === M.blending,
                alphaMap: O,
                alphaTest: M.alphaTest > 0,
                alphaHash: !!M.alphaHash,
                combine: M.combine,
                mapUv: Je && _(M.map.channel),
                aoMapUv: R && _(M.aoMap.channel),
                lightMapUv: me && _(M.lightMap.channel),
                bumpMapUv: te && _(M.bumpMap.channel),
                normalMapUv: he && _(M.normalMap.channel),
                displacementMapUv: ae && _(M.displacementMap.channel),
                emissiveMapUv: Fe && _(M.emissiveMap.channel),
                metalnessMapUv: xe && _(M.metalnessMap.channel),
                roughnessMapUv: Ae && _(M.roughnessMap.channel),
                anisotropyMapUv: G && _(M.anisotropyMap.channel),
                clearcoatMapUv: ue && _(M.clearcoatMap.channel),
                clearcoatNormalMapUv: ce && _(M.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv:
                  de && _(M.clearcoatRoughnessMap.channel),
                iridescenceMapUv: Ne && _(M.iridescenceMap.channel),
                iridescenceThicknessMapUv:
                  pe && _(M.iridescenceThicknessMap.channel),
                sheenColorMapUv: j && _(M.sheenColorMap.channel),
                sheenRoughnessMapUv: He && _(M.sheenRoughnessMap.channel),
                specularMapUv: ke && _(M.specularMap.channel),
                specularColorMapUv: Ve && _(M.specularColorMap.channel),
                specularIntensityMapUv: Pe && _(M.specularIntensityMap.channel),
                transmissionMapUv: Oe && _(M.transmissionMap.channel),
                thicknessMapUv: ft && _(M.thicknessMap.channel),
                alphaMapUv: O && _(M.alphaMap.channel),
                vertexTangents: !!W.attributes.tangent && (he || et),
                vertexColors: M.vertexColors,
                vertexAlphas:
                  !0 === M.vertexColors &&
                  !!W.attributes.color &&
                  4 === W.attributes.color.itemSize,
                vertexUv1s: Se,
                vertexUv2s: St,
                vertexUv3s: Jt,
                pointsUvs: !0 === V.isPoints && !!W.attributes.uv && (Je || O),
                fog: !!z,
                useFog: !0 === M.fog,
                fogExp2: z && z.isFogExp2,
                flatShading: !0 === M.flatShading,
                sizeAttenuation: !0 === M.sizeAttenuation,
                logarithmicDepthBuffer: d,
                skinning: !0 === V.isSkinnedMesh,
                morphTargets: void 0 !== W.morphAttributes.position,
                morphNormals: void 0 !== W.morphAttributes.normal,
                morphColors: void 0 !== W.morphAttributes.color,
                morphTargetsCount: U,
                morphTextureStride: K,
                numDirLights: C.directional.length,
                numPointLights: C.point.length,
                numSpotLights: C.spot.length,
                numSpotLightMaps: C.spotLightMap.length,
                numRectAreaLights: C.rectArea.length,
                numHemiLights: C.hemi.length,
                numDirLightShadows: C.directionalShadowMap.length,
                numPointLightShadows: C.pointShadowMap.length,
                numSpotLightShadows: C.spotShadowMap.length,
                numSpotLightShadowsWithMaps: C.numSpotLightShadowsWithMaps,
                numClippingPlanes: o.numPlanes,
                numClipIntersection: o.numIntersection,
                dithering: M.dithering,
                shadowMapEnabled: n.shadowMap.enabled && $.length > 0,
                shadowMapType: n.shadowMap.type,
                toneMapping: yn,
                useLegacyLights: n._useLegacyLights,
                premultipliedAlpha: M.premultipliedAlpha,
                doubleSided: 2 === M.side,
                flipSided: 1 === M.side,
                useDepthPacking: M.depthPacking >= 0,
                depthPacking: M.depthPacking || 0,
                index0AttributeName: M.index0AttributeName,
                extensionDerivatives: ge && !0 === M.extensions.derivatives,
                extensionFragDepth: ge && !0 === M.extensions.fragDepth,
                extensionDrawBuffers: ge && !0 === M.extensions.drawBuffers,
                extensionShaderTextureLOD:
                  ge && !0 === M.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod:
                  u || i.has("EXT_shader_texture_lod"),
                customProgramCacheKey: M.customProgramCacheKey(),
              }
            );
          },
          getProgramCacheKey: function m(M) {
            const C = [];
            if (
              (M.shaderID
                ? C.push(M.shaderID)
                : (C.push(M.customVertexShaderID),
                  C.push(M.customFragmentShaderID)),
              void 0 !== M.defines)
            )
              for (const $ in M.defines) C.push($), C.push(M.defines[$]);
            return (
              !1 === M.isRawShaderMaterial &&
                ((function y(M, C) {
                  M.push(C.precision),
                    M.push(C.outputColorSpace),
                    M.push(C.envMapMode),
                    M.push(C.envMapCubeUVHeight),
                    M.push(C.mapUv),
                    M.push(C.alphaMapUv),
                    M.push(C.lightMapUv),
                    M.push(C.aoMapUv),
                    M.push(C.bumpMapUv),
                    M.push(C.normalMapUv),
                    M.push(C.displacementMapUv),
                    M.push(C.emissiveMapUv),
                    M.push(C.metalnessMapUv),
                    M.push(C.roughnessMapUv),
                    M.push(C.anisotropyMapUv),
                    M.push(C.clearcoatMapUv),
                    M.push(C.clearcoatNormalMapUv),
                    M.push(C.clearcoatRoughnessMapUv),
                    M.push(C.iridescenceMapUv),
                    M.push(C.iridescenceThicknessMapUv),
                    M.push(C.sheenColorMapUv),
                    M.push(C.sheenRoughnessMapUv),
                    M.push(C.specularMapUv),
                    M.push(C.specularColorMapUv),
                    M.push(C.specularIntensityMapUv),
                    M.push(C.transmissionMapUv),
                    M.push(C.thicknessMapUv),
                    M.push(C.combine),
                    M.push(C.fogExp2),
                    M.push(C.sizeAttenuation),
                    M.push(C.morphTargetsCount),
                    M.push(C.morphAttributeCount),
                    M.push(C.numDirLights),
                    M.push(C.numPointLights),
                    M.push(C.numSpotLights),
                    M.push(C.numSpotLightMaps),
                    M.push(C.numHemiLights),
                    M.push(C.numRectAreaLights),
                    M.push(C.numDirLightShadows),
                    M.push(C.numPointLightShadows),
                    M.push(C.numSpotLightShadows),
                    M.push(C.numSpotLightShadowsWithMaps),
                    M.push(C.shadowMapType),
                    M.push(C.toneMapping),
                    M.push(C.numClippingPlanes),
                    M.push(C.numClipIntersection),
                    M.push(C.depthPacking);
                })(C, M),
                (function v(M, C) {
                  a.disableAll(),
                    C.isWebGL2 && a.enable(0),
                    C.supportsVertexTextures && a.enable(1),
                    C.instancing && a.enable(2),
                    C.instancingColor && a.enable(3),
                    C.matcap && a.enable(4),
                    C.envMap && a.enable(5),
                    C.normalMapObjectSpace && a.enable(6),
                    C.normalMapTangentSpace && a.enable(7),
                    C.clearcoat && a.enable(8),
                    C.iridescence && a.enable(9),
                    C.alphaTest && a.enable(10),
                    C.vertexColors && a.enable(11),
                    C.vertexAlphas && a.enable(12),
                    C.vertexUv1s && a.enable(13),
                    C.vertexUv2s && a.enable(14),
                    C.vertexUv3s && a.enable(15),
                    C.vertexTangents && a.enable(16),
                    C.anisotropy && a.enable(17),
                    M.push(a.mask),
                    a.disableAll(),
                    C.fog && a.enable(0),
                    C.useFog && a.enable(1),
                    C.flatShading && a.enable(2),
                    C.logarithmicDepthBuffer && a.enable(3),
                    C.skinning && a.enable(4),
                    C.morphTargets && a.enable(5),
                    C.morphNormals && a.enable(6),
                    C.morphColors && a.enable(7),
                    C.premultipliedAlpha && a.enable(8),
                    C.shadowMapEnabled && a.enable(9),
                    C.useLegacyLights && a.enable(10),
                    C.doubleSided && a.enable(11),
                    C.flipSided && a.enable(12),
                    C.useDepthPacking && a.enable(13),
                    C.dithering && a.enable(14),
                    C.transmission && a.enable(15),
                    C.sheen && a.enable(16),
                    C.opaque && a.enable(17),
                    C.pointsUvs && a.enable(18),
                    M.push(a.mask);
                })(C, M),
                C.push(n.outputColorSpace)),
              C.push(M.customProgramCacheKey),
              C.join()
            );
          },
          getUniforms: function b(M) {
            const C = p[M.type];
            let $;
            return ($ = C ? a6.clone(Fr[C].uniforms) : M.uniforms), $;
          },
          acquireProgram: function S(M, C) {
            let $;
            for (let ie = 0, V = c.length; ie < V; ie++) {
              const z = c[ie];
              if (z.cacheKey === C) {
                ($ = z), ++$.usedTimes;
                break;
              }
            }
            return void 0 === $ && (($ = new k9(n, C, M, s)), c.push($)), $;
          },
          releaseProgram: function E(M) {
            if (0 == --M.usedTimes) {
              const C = c.indexOf(M);
              (c[C] = c[c.length - 1]), c.pop(), M.destroy();
            }
          },
          releaseShaderCache: function x(M) {
            l.remove(M);
          },
          programs: c,
          dispose: function P() {
            l.dispose();
          },
        };
      }
      function z9() {
        let n = new WeakMap();
        return {
          get: function e(s) {
            let o = n.get(s);
            return void 0 === o && ((o = {}), n.set(s, o)), o;
          },
          remove: function t(s) {
            n.delete(s);
          },
          update: function i(s, o, a) {
            n.get(s)[o] = a;
          },
          dispose: function r() {
            n = new WeakMap();
          },
        };
      }
      function G9(n, e) {
        return n.groupOrder !== e.groupOrder
          ? n.groupOrder - e.groupOrder
          : n.renderOrder !== e.renderOrder
          ? n.renderOrder - e.renderOrder
          : n.material.id !== e.material.id
          ? n.material.id - e.material.id
          : n.z !== e.z
          ? n.z - e.z
          : n.id - e.id;
      }
      function eP(n, e) {
        return n.groupOrder !== e.groupOrder
          ? n.groupOrder - e.groupOrder
          : n.renderOrder !== e.renderOrder
          ? n.renderOrder - e.renderOrder
          : n.z !== e.z
          ? e.z - n.z
          : n.id - e.id;
      }
      function tP() {
        const n = [];
        let e = 0;
        const t = [],
          i = [],
          r = [];
        function o(d, h, f, p, _, g) {
          let m = n[e];
          return (
            void 0 === m
              ? ((m = {
                  id: d.id,
                  object: d,
                  geometry: h,
                  material: f,
                  groupOrder: p,
                  renderOrder: d.renderOrder,
                  z: _,
                  group: g,
                }),
                (n[e] = m))
              : ((m.id = d.id),
                (m.object = d),
                (m.geometry = h),
                (m.material = f),
                (m.groupOrder = p),
                (m.renderOrder = d.renderOrder),
                (m.z = _),
                (m.group = g)),
            e++,
            m
          );
        }
        return {
          opaque: t,
          transmissive: i,
          transparent: r,
          init: function s() {
            (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
          },
          push: function a(d, h, f, p, _, g) {
            const m = o(d, h, f, p, _, g);
            f.transmission > 0
              ? i.push(m)
              : !0 === f.transparent
              ? r.push(m)
              : t.push(m);
          },
          unshift: function l(d, h, f, p, _, g) {
            const m = o(d, h, f, p, _, g);
            f.transmission > 0
              ? i.unshift(m)
              : !0 === f.transparent
              ? r.unshift(m)
              : t.unshift(m);
          },
          finish: function u() {
            for (let d = e, h = n.length; d < h; d++) {
              const f = n[d];
              if (null === f.id) break;
              (f.id = null),
                (f.object = null),
                (f.geometry = null),
                (f.material = null),
                (f.group = null);
            }
          },
          sort: function c(d, h) {
            t.length > 1 && t.sort(d || G9),
              i.length > 1 && i.sort(h || eP),
              r.length > 1 && r.sort(h || eP);
          },
        };
      }
      function W9() {
        let n = new WeakMap();
        return {
          get: function e(i, r) {
            const s = n.get(i);
            let o;
            return (
              void 0 === s
                ? ((o = new tP()), n.set(i, [o]))
                : r >= s.length
                ? ((o = new tP()), s.push(o))
                : (o = s[r]),
              o
            );
          },
          dispose: function t() {
            n = new WeakMap();
          },
        };
      }
      function $9() {
        const n = {};
        return {
          get: function (e) {
            if (void 0 !== n[e.id]) return n[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { direction: new D(), color: new Ce() };
                break;
              case "SpotLight":
                t = {
                  position: new D(),
                  direction: new D(),
                  color: new Ce(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                t = {
                  position: new D(),
                  color: new Ce(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new D(),
                  skyColor: new Ce(),
                  groundColor: new Ce(),
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new Ce(),
                  position: new D(),
                  halfWidth: new D(),
                  halfHeight: new D(),
                };
            }
            return (n[e.id] = t), t;
          },
        };
      }
      let q9 = 0;
      function X9(n, e) {
        return (
          (e.castShadow ? 2 : 0) -
          (n.castShadow ? 2 : 0) +
          (e.map ? 1 : 0) -
          (n.map ? 1 : 0)
        );
      }
      function Y9(n, e) {
        const t = new $9(),
          i = (function j9() {
            const n = {};
            return {
              get: function (e) {
                if (void 0 !== n[e.id]) return n[e.id];
                let t;
                switch (e.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    t = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new oe(),
                    };
                    break;
                  case "PointLight":
                    t = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new oe(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (n[e.id] = t), t;
              },
            };
          })(),
          r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
          };
        for (let u = 0; u < 9; u++) r.probe.push(new D());
        const s = new D(),
          o = new it(),
          a = new it();
        return {
          setup: function l(u, d) {
            let h = 0,
              f = 0,
              p = 0;
            for (let $ = 0; $ < 9; $++) r.probe[$].set(0, 0, 0);
            let _ = 0,
              g = 0,
              m = 0,
              y = 0,
              v = 0,
              b = 0,
              S = 0,
              E = 0,
              x = 0,
              P = 0;
            u.sort(X9);
            const M = !0 === d ? Math.PI : 1;
            for (let $ = 0, ie = u.length; $ < ie; $++) {
              const V = u[$],
                z = V.color,
                W = V.intensity,
                F = V.distance,
                N = V.shadow && V.shadow.map ? V.shadow.map.texture : null;
              if (V.isAmbientLight)
                (h += z.r * W * M), (f += z.g * W * M), (p += z.b * W * M);
              else if (V.isLightProbe)
                for (let k = 0; k < 9; k++)
                  r.probe[k].addScaledVector(V.sh.coefficients[k], W);
              else if (V.isDirectionalLight) {
                const k = t.get(V);
                if (
                  (k.color.copy(V.color).multiplyScalar(V.intensity * M),
                  V.castShadow)
                ) {
                  const q = V.shadow,
                    ee = i.get(V);
                  (ee.shadowBias = q.bias),
                    (ee.shadowNormalBias = q.normalBias),
                    (ee.shadowRadius = q.radius),
                    (ee.shadowMapSize = q.mapSize),
                    (r.directionalShadow[_] = ee),
                    (r.directionalShadowMap[_] = N),
                    (r.directionalShadowMatrix[_] = V.shadow.matrix),
                    b++;
                }
                (r.directional[_] = k), _++;
              } else if (V.isSpotLight) {
                const k = t.get(V);
                k.position.setFromMatrixPosition(V.matrixWorld),
                  k.color.copy(z).multiplyScalar(W * M),
                  (k.distance = F),
                  (k.coneCos = Math.cos(V.angle)),
                  (k.penumbraCos = Math.cos(V.angle * (1 - V.penumbra))),
                  (k.decay = V.decay),
                  (r.spot[m] = k);
                const q = V.shadow;
                if (
                  (V.map &&
                    ((r.spotLightMap[x] = V.map),
                    x++,
                    q.updateMatrices(V),
                    V.castShadow && P++),
                  (r.spotLightMatrix[m] = q.matrix),
                  V.castShadow)
                ) {
                  const ee = i.get(V);
                  (ee.shadowBias = q.bias),
                    (ee.shadowNormalBias = q.normalBias),
                    (ee.shadowRadius = q.radius),
                    (ee.shadowMapSize = q.mapSize),
                    (r.spotShadow[m] = ee),
                    (r.spotShadowMap[m] = N),
                    E++;
                }
                m++;
              } else if (V.isRectAreaLight) {
                const k = t.get(V);
                k.color.copy(z).multiplyScalar(W),
                  k.halfWidth.set(0.5 * V.width, 0, 0),
                  k.halfHeight.set(0, 0.5 * V.height, 0),
                  (r.rectArea[y] = k),
                  y++;
              } else if (V.isPointLight) {
                const k = t.get(V);
                if (
                  (k.color.copy(V.color).multiplyScalar(V.intensity * M),
                  (k.distance = V.distance),
                  (k.decay = V.decay),
                  V.castShadow)
                ) {
                  const q = V.shadow,
                    ee = i.get(V);
                  (ee.shadowBias = q.bias),
                    (ee.shadowNormalBias = q.normalBias),
                    (ee.shadowRadius = q.radius),
                    (ee.shadowMapSize = q.mapSize),
                    (ee.shadowCameraNear = q.camera.near),
                    (ee.shadowCameraFar = q.camera.far),
                    (r.pointShadow[g] = ee),
                    (r.pointShadowMap[g] = N),
                    (r.pointShadowMatrix[g] = V.shadow.matrix),
                    S++;
                }
                (r.point[g] = k), g++;
              } else if (V.isHemisphereLight) {
                const k = t.get(V);
                k.skyColor.copy(V.color).multiplyScalar(W * M),
                  k.groundColor.copy(V.groundColor).multiplyScalar(W * M),
                  (r.hemi[v] = k),
                  v++;
              }
            }
            y > 0 &&
              (e.isWebGL2 || !0 === n.has("OES_texture_float_linear")
                ? ((r.rectAreaLTC1 = _e.LTC_FLOAT_1),
                  (r.rectAreaLTC2 = _e.LTC_FLOAT_2))
                : !0 === n.has("OES_texture_half_float_linear")
                ? ((r.rectAreaLTC1 = _e.LTC_HALF_1),
                  (r.rectAreaLTC2 = _e.LTC_HALF_2))
                : console.error(
                    "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.",
                  )),
              (r.ambient[0] = h),
              (r.ambient[1] = f),
              (r.ambient[2] = p);
            const C = r.hash;
            (C.directionalLength !== _ ||
              C.pointLength !== g ||
              C.spotLength !== m ||
              C.rectAreaLength !== y ||
              C.hemiLength !== v ||
              C.numDirectionalShadows !== b ||
              C.numPointShadows !== S ||
              C.numSpotShadows !== E ||
              C.numSpotMaps !== x) &&
              ((r.directional.length = _),
              (r.spot.length = m),
              (r.rectArea.length = y),
              (r.point.length = g),
              (r.hemi.length = v),
              (r.directionalShadow.length = b),
              (r.directionalShadowMap.length = b),
              (r.pointShadow.length = S),
              (r.pointShadowMap.length = S),
              (r.spotShadow.length = E),
              (r.spotShadowMap.length = E),
              (r.directionalShadowMatrix.length = b),
              (r.pointShadowMatrix.length = S),
              (r.spotLightMatrix.length = E + x - P),
              (r.spotLightMap.length = x),
              (r.numSpotLightShadowsWithMaps = P),
              (C.directionalLength = _),
              (C.pointLength = g),
              (C.spotLength = m),
              (C.rectAreaLength = y),
              (C.hemiLength = v),
              (C.numDirectionalShadows = b),
              (C.numPointShadows = S),
              (C.numSpotShadows = E),
              (C.numSpotMaps = x),
              (r.version = q9++));
          },
          setupView: function c(u, d) {
            let h = 0,
              f = 0,
              p = 0,
              _ = 0,
              g = 0;
            const m = d.matrixWorldInverse;
            for (let y = 0, v = u.length; y < v; y++) {
              const b = u[y];
              if (b.isDirectionalLight) {
                const S = r.directional[h];
                S.direction.setFromMatrixPosition(b.matrixWorld),
                  s.setFromMatrixPosition(b.target.matrixWorld),
                  S.direction.sub(s),
                  S.direction.transformDirection(m),
                  h++;
              } else if (b.isSpotLight) {
                const S = r.spot[p];
                S.position.setFromMatrixPosition(b.matrixWorld),
                  S.position.applyMatrix4(m),
                  S.direction.setFromMatrixPosition(b.matrixWorld),
                  s.setFromMatrixPosition(b.target.matrixWorld),
                  S.direction.sub(s),
                  S.direction.transformDirection(m),
                  p++;
              } else if (b.isRectAreaLight) {
                const S = r.rectArea[_];
                S.position.setFromMatrixPosition(b.matrixWorld),
                  S.position.applyMatrix4(m),
                  a.identity(),
                  o.copy(b.matrixWorld),
                  o.premultiply(m),
                  a.extractRotation(o),
                  S.halfWidth.set(0.5 * b.width, 0, 0),
                  S.halfHeight.set(0, 0.5 * b.height, 0),
                  S.halfWidth.applyMatrix4(a),
                  S.halfHeight.applyMatrix4(a),
                  _++;
              } else if (b.isPointLight) {
                const S = r.point[f];
                S.position.setFromMatrixPosition(b.matrixWorld),
                  S.position.applyMatrix4(m),
                  f++;
              } else if (b.isHemisphereLight) {
                const S = r.hemi[g];
                S.direction.setFromMatrixPosition(b.matrixWorld),
                  S.direction.transformDirection(m),
                  g++;
              }
            }
          },
          state: r,
        };
      }
      function nP(n, e) {
        const t = new Y9(n, e),
          i = [],
          r = [];
        return {
          init: function s() {
            (i.length = 0), (r.length = 0);
          },
          state: { lightsArray: i, shadowsArray: r, lights: t },
          setupLights: function l(d) {
            t.setup(i, d);
          },
          setupLightsView: function c(d) {
            t.setupView(i, d);
          },
          pushLight: function o(d) {
            i.push(d);
          },
          pushShadow: function a(d) {
            r.push(d);
          },
        };
      }
      function Z9(n, e) {
        let t = new WeakMap();
        return {
          get: function i(s, o = 0) {
            const a = t.get(s);
            let l;
            return (
              void 0 === a
                ? ((l = new nP(n, e)), t.set(s, [l]))
                : o >= a.length
                ? ((l = new nP(n, e)), a.push(l))
                : (l = a[o]),
              l
            );
          },
          dispose: function r() {
            t = new WeakMap();
          },
        };
      }
      class iP extends Ou {
        constructor(e) {
          super(),
            (this.isMeshDepthMaterial = !0),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = 3200),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      class rP extends Ou {
        constructor(e) {
          super(),
            (this.isMeshDistanceMaterial = !0),
            (this.type = "MeshDistanceMaterial"),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      function J9(n, e, t) {
        let i = new n0();
        const r = new oe(),
          s = new oe(),
          o = new Ut(),
          a = new iP({ depthPacking: 3201 }),
          l = new rP(),
          c = {},
          u = t.maxTextureSize,
          d = { 0: 1, 1: 0, 2: 2 },
          h = new Xs({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new oe() },
              radius: { value: 4 },
            },
            vertexShader:
              "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader:
              "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          }),
          f = h.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const p = new ht();
        p.setAttribute(
          "position",
          new Pn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
        );
        const _ = new ti(p, h),
          g = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = vI);
        let m = this.type;
        function y(S, E) {
          const x = e.update(_);
          h.defines.VSM_SAMPLES !== S.blurSamples &&
            ((h.defines.VSM_SAMPLES = S.blurSamples),
            (f.defines.VSM_SAMPLES = S.blurSamples),
            (h.needsUpdate = !0),
            (f.needsUpdate = !0)),
            null === S.mapPass && (S.mapPass = new Uo(r.x, r.y)),
            (h.uniforms.shadow_pass.value = S.map.texture),
            (h.uniforms.resolution.value = S.mapSize),
            (h.uniforms.radius.value = S.radius),
            n.setRenderTarget(S.mapPass),
            n.clear(),
            n.renderBufferDirect(E, null, x, h, _, null),
            (f.uniforms.shadow_pass.value = S.mapPass.texture),
            (f.uniforms.resolution.value = S.mapSize),
            (f.uniforms.radius.value = S.radius),
            n.setRenderTarget(S.map),
            n.clear(),
            n.renderBufferDirect(E, null, x, f, _, null);
        }
        function v(S, E, x, P) {
          let M = null;
          const C =
            !0 === x.isPointLight
              ? S.customDistanceMaterial
              : S.customDepthMaterial;
          if (void 0 !== C) M = C;
          else if (
            ((M = !0 === x.isPointLight ? l : a),
            (n.localClippingEnabled &&
              !0 === E.clipShadows &&
              Array.isArray(E.clippingPlanes) &&
              0 !== E.clippingPlanes.length) ||
              (E.displacementMap && 0 !== E.displacementScale) ||
              (E.alphaMap && E.alphaTest > 0) ||
              (E.map && E.alphaTest > 0))
          ) {
            const $ = M.uuid,
              ie = E.uuid;
            let V = c[$];
            void 0 === V && ((V = {}), (c[$] = V));
            let z = V[ie];
            void 0 === z && ((z = M.clone()), (V[ie] = z)), (M = z);
          }
          return (
            (M.visible = E.visible),
            (M.wireframe = E.wireframe),
            (M.side =
              P === ss
                ? null !== E.shadowSide
                  ? E.shadowSide
                  : E.side
                : null !== E.shadowSide
                ? E.shadowSide
                : d[E.side]),
            (M.alphaMap = E.alphaMap),
            (M.alphaTest = E.alphaTest),
            (M.map = E.map),
            (M.clipShadows = E.clipShadows),
            (M.clippingPlanes = E.clippingPlanes),
            (M.clipIntersection = E.clipIntersection),
            (M.displacementMap = E.displacementMap),
            (M.displacementScale = E.displacementScale),
            (M.displacementBias = E.displacementBias),
            (M.wireframeLinewidth = E.wireframeLinewidth),
            (M.linewidth = E.linewidth),
            !0 === x.isPointLight &&
              !0 === M.isMeshDistanceMaterial &&
              (n.properties.get(M).light = x),
            M
          );
        }
        function b(S, E, x, P, M) {
          if (!1 === S.visible) return;
          if (
            S.layers.test(E.layers) &&
            (S.isMesh || S.isLine || S.isPoints) &&
            (S.castShadow || (S.receiveShadow && M === ss)) &&
            (!S.frustumCulled || i.intersectsObject(S))
          ) {
            S.modelViewMatrix.multiplyMatrices(
              x.matrixWorldInverse,
              S.matrixWorld,
            );
            const ie = e.update(S),
              V = S.material;
            if (Array.isArray(V)) {
              const z = ie.groups;
              for (let W = 0, F = z.length; W < F; W++) {
                const N = z[W],
                  k = V[N.materialIndex];
                if (k && k.visible) {
                  const q = v(S, k, P, M);
                  n.renderBufferDirect(x, null, ie, q, S, N);
                }
              }
            } else if (V.visible) {
              const z = v(S, V, P, M);
              n.renderBufferDirect(x, null, ie, z, S, null);
            }
          }
          const $ = S.children;
          for (let ie = 0, V = $.length; ie < V; ie++) b($[ie], E, x, P, M);
        }
        this.render = function (S, E, x) {
          if (
            !1 === g.enabled ||
            (!1 === g.autoUpdate && !1 === g.needsUpdate) ||
            0 === S.length
          )
            return;
          const P = n.getRenderTarget(),
            M = n.getActiveCubeFace(),
            C = n.getActiveMipmapLevel(),
            $ = n.state;
          $.setBlending(0),
            $.buffers.color.setClear(1, 1, 1, 1),
            $.buffers.depth.setTest(!0),
            $.setScissorTest(!1);
          const ie = m !== ss && this.type === ss,
            V = m === ss && this.type !== ss;
          for (let z = 0, W = S.length; z < W; z++) {
            const F = S[z],
              N = F.shadow;
            if (void 0 === N) {
              console.warn("THREE.WebGLShadowMap:", F, "has no shadow.");
              continue;
            }
            if (!1 === N.autoUpdate && !1 === N.needsUpdate) continue;
            r.copy(N.mapSize);
            const k = N.getFrameExtents();
            if (
              (r.multiply(k),
              s.copy(N.mapSize),
              (r.x > u || r.y > u) &&
                (r.x > u &&
                  ((s.x = Math.floor(u / k.x)),
                  (r.x = s.x * k.x),
                  (N.mapSize.x = s.x)),
                r.y > u &&
                  ((s.y = Math.floor(u / k.y)),
                  (r.y = s.y * k.y),
                  (N.mapSize.y = s.y))),
              null === N.map || !0 === ie || !0 === V)
            ) {
              const ee =
                this.type !== ss ? { minFilter: mn, magFilter: mn } : {};
              null !== N.map && N.map.dispose(),
                (N.map = new Uo(r.x, r.y, ee)),
                (N.map.texture.name = F.name + ".shadowMap"),
                N.camera.updateProjectionMatrix();
            }
            n.setRenderTarget(N.map), n.clear();
            const q = N.getViewportCount();
            for (let ee = 0; ee < q; ee++) {
              const U = N.getViewport(ee);
              o.set(s.x * U.x, s.y * U.y, s.x * U.z, s.y * U.w),
                $.viewport(o),
                N.updateMatrices(F, ee),
                (i = N.getFrustum()),
                b(E, x, N.camera, F, this.type);
            }
            !0 !== N.isPointLightShadow && this.type === ss && y(N, x),
              (N.needsUpdate = !1);
          }
          (m = this.type), (g.needsUpdate = !1), n.setRenderTarget(P, M, C);
        };
      }
      function eX(n, e, t) {
        const i = t.isWebGL2,
          a = new (function r() {
            let O = !1;
            const ye = new Ut();
            let X = null;
            const ge = new Ut(0, 0, 0, 0);
            return {
              setMask: function (Se) {
                X !== Se && !O && (n.colorMask(Se, Se, Se, Se), (X = Se));
              },
              setLocked: function (Se) {
                O = Se;
              },
              setClear: function (Se, St, Jt, yn, io) {
                !0 === io && ((Se *= yn), (St *= yn), (Jt *= yn)),
                  ye.set(Se, St, Jt, yn),
                  !1 === ge.equals(ye) &&
                    (n.clearColor(Se, St, Jt, yn), ge.copy(ye));
              },
              reset: function () {
                (O = !1), (X = null), ge.set(-1, 0, 0, 0);
              },
            };
          })(),
          l = new (function s() {
            let O = !1,
              ye = null,
              X = null,
              ge = null;
            return {
              setTest: function (Se) {
                Se ? Me(n.DEPTH_TEST) : Re(n.DEPTH_TEST);
              },
              setMask: function (Se) {
                ye !== Se && !O && (n.depthMask(Se), (ye = Se));
              },
              setFunc: function (Se) {
                if (X !== Se) {
                  switch (Se) {
                    case 0:
                      n.depthFunc(n.NEVER);
                      break;
                    case 1:
                      n.depthFunc(n.ALWAYS);
                      break;
                    case 2:
                      n.depthFunc(n.LESS);
                      break;
                    case 3:
                    default:
                      n.depthFunc(n.LEQUAL);
                      break;
                    case 4:
                      n.depthFunc(n.EQUAL);
                      break;
                    case 5:
                      n.depthFunc(n.GEQUAL);
                      break;
                    case 6:
                      n.depthFunc(n.GREATER);
                      break;
                    case 7:
                      n.depthFunc(n.NOTEQUAL);
                  }
                  X = Se;
                }
              },
              setLocked: function (Se) {
                O = Se;
              },
              setClear: function (Se) {
                ge !== Se && (n.clearDepth(Se), (ge = Se));
              },
              reset: function () {
                (O = !1), (ye = null), (X = null), (ge = null);
              },
            };
          })(),
          c = new (function o() {
            let O = !1,
              ye = null,
              X = null,
              ge = null,
              Se = null,
              St = null,
              Jt = null,
              yn = null,
              io = null;
            return {
              setTest: function (Xt) {
                O || (Xt ? Me(n.STENCIL_TEST) : Re(n.STENCIL_TEST));
              },
              setMask: function (Xt) {
                ye !== Xt && !O && (n.stencilMask(Xt), (ye = Xt));
              },
              setFunc: function (Xt, Vr, si) {
                (X !== Xt || ge !== Vr || Se !== si) &&
                  (n.stencilFunc(Xt, Vr, si), (X = Xt), (ge = Vr), (Se = si));
              },
              setOp: function (Xt, Vr, si) {
                (St !== Xt || Jt !== Vr || yn !== si) &&
                  (n.stencilOp(Xt, Vr, si), (St = Xt), (Jt = Vr), (yn = si));
              },
              setLocked: function (Xt) {
                O = Xt;
              },
              setClear: function (Xt) {
                io !== Xt && (n.clearStencil(Xt), (io = Xt));
              },
              reset: function () {
                (O = !1),
                  (ye = null),
                  (X = null),
                  (ge = null),
                  (Se = null),
                  (St = null),
                  (Jt = null),
                  (yn = null),
                  (io = null);
              },
            };
          })(),
          u = new WeakMap(),
          d = new WeakMap();
        let h = {},
          f = {},
          p = new WeakMap(),
          _ = [],
          g = null,
          m = !1,
          y = null,
          v = null,
          b = null,
          S = null,
          E = null,
          x = null,
          P = null,
          M = !1,
          C = null,
          $ = null,
          ie = null,
          V = null,
          z = null;
        const W = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let F = !1,
          N = 0;
        const k = n.getParameter(n.VERSION);
        -1 !== k.indexOf("WebGL")
          ? ((N = parseFloat(/^WebGL (\d)/.exec(k)[1])), (F = N >= 1))
          : -1 !== k.indexOf("OpenGL ES") &&
            ((N = parseFloat(/^OpenGL ES (\d)/.exec(k)[1])), (F = N >= 2));
        let q = null,
          ee = {};
        const U = n.getParameter(n.SCISSOR_BOX),
          K = n.getParameter(n.VIEWPORT),
          fe = new Ut().fromArray(U),
          le = new Ut().fromArray(K);
        function be(O, ye, X, ge) {
          const Se = new Uint8Array(4),
            St = n.createTexture();
          n.bindTexture(O, St),
            n.texParameteri(O, n.TEXTURE_MIN_FILTER, n.NEAREST),
            n.texParameteri(O, n.TEXTURE_MAG_FILTER, n.NEAREST);
          for (let Jt = 0; Jt < X; Jt++)
            !i || (O !== n.TEXTURE_3D && O !== n.TEXTURE_2D_ARRAY)
              ? n.texImage2D(
                  ye + Jt,
                  0,
                  n.RGBA,
                  1,
                  1,
                  0,
                  n.RGBA,
                  n.UNSIGNED_BYTE,
                  Se,
                )
              : n.texImage3D(
                  ye,
                  0,
                  n.RGBA,
                  1,
                  1,
                  ge,
                  0,
                  n.RGBA,
                  n.UNSIGNED_BYTE,
                  Se,
                );
          return St;
        }
        const Le = {};
        function Me(O) {
          !0 !== h[O] && (n.enable(O), (h[O] = !0));
        }
        function Re(O) {
          !1 !== h[O] && (n.disable(O), (h[O] = !1));
        }
        (Le[n.TEXTURE_2D] = be(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
          (Le[n.TEXTURE_CUBE_MAP] = be(
            n.TEXTURE_CUBE_MAP,
            n.TEXTURE_CUBE_MAP_POSITIVE_X,
            6,
          )),
          i &&
            ((Le[n.TEXTURE_2D_ARRAY] = be(
              n.TEXTURE_2D_ARRAY,
              n.TEXTURE_2D_ARRAY,
              1,
              1,
            )),
            (Le[n.TEXTURE_3D] = be(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1))),
          a.setClear(0, 0, 0, 1),
          l.setClear(1),
          c.setClear(0),
          Me(n.DEPTH_TEST),
          l.setFunc(3),
          ae(!1),
          Fe(1),
          Me(n.CULL_FACE),
          te(0);
        const R = {
          100: n.FUNC_ADD,
          101: n.FUNC_SUBTRACT,
          102: n.FUNC_REVERSE_SUBTRACT,
        };
        if (i) (R[103] = n.MIN), (R[104] = n.MAX);
        else {
          const O = e.get("EXT_blend_minmax");
          null !== O && ((R[103] = O.MIN_EXT), (R[104] = O.MAX_EXT));
        }
        const me = {
          200: n.ZERO,
          201: n.ONE,
          202: n.SRC_COLOR,
          204: n.SRC_ALPHA,
          210: n.SRC_ALPHA_SATURATE,
          208: n.DST_COLOR,
          206: n.DST_ALPHA,
          203: n.ONE_MINUS_SRC_COLOR,
          205: n.ONE_MINUS_SRC_ALPHA,
          209: n.ONE_MINUS_DST_COLOR,
          207: n.ONE_MINUS_DST_ALPHA,
        };
        function te(O, ye, X, ge, Se, St, Jt, yn) {
          if (0 !== O) {
            if ((!1 === m && (Me(n.BLEND), (m = !0)), 5 === O))
              (Se = Se || ye),
                (St = St || X),
                (Jt = Jt || ge),
                (ye !== v || Se !== E) &&
                  (n.blendEquationSeparate(R[ye], R[Se]), (v = ye), (E = Se)),
                (X !== b || ge !== S || St !== x || Jt !== P) &&
                  (n.blendFuncSeparate(me[X], me[ge], me[St], me[Jt]),
                  (b = X),
                  (S = ge),
                  (x = St),
                  (P = Jt)),
                (y = O),
                (M = !1);
            else if (O !== y || yn !== M) {
              if (
                ((100 !== v || 100 !== E) &&
                  (n.blendEquation(n.FUNC_ADD), (v = 100), (E = 100)),
                yn)
              )
                switch (O) {
                  case 1:
                    n.blendFuncSeparate(
                      n.ONE,
                      n.ONE_MINUS_SRC_ALPHA,
                      n.ONE,
                      n.ONE_MINUS_SRC_ALPHA,
                    );
                    break;
                  case 2:
                    n.blendFunc(n.ONE, n.ONE);
                    break;
                  case 3:
                    n.blendFuncSeparate(
                      n.ZERO,
                      n.ONE_MINUS_SRC_COLOR,
                      n.ZERO,
                      n.ONE,
                    );
                    break;
                  case 4:
                    n.blendFuncSeparate(
                      n.ZERO,
                      n.SRC_COLOR,
                      n.ZERO,
                      n.SRC_ALPHA,
                    );
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", O);
                }
              else
                switch (O) {
                  case 1:
                    n.blendFuncSeparate(
                      n.SRC_ALPHA,
                      n.ONE_MINUS_SRC_ALPHA,
                      n.ONE,
                      n.ONE_MINUS_SRC_ALPHA,
                    );
                    break;
                  case 2:
                    n.blendFunc(n.SRC_ALPHA, n.ONE);
                    break;
                  case 3:
                    n.blendFuncSeparate(
                      n.ZERO,
                      n.ONE_MINUS_SRC_COLOR,
                      n.ZERO,
                      n.ONE,
                    );
                    break;
                  case 4:
                    n.blendFunc(n.ZERO, n.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", O);
                }
              (b = null), (S = null), (x = null), (P = null), (y = O), (M = yn);
            }
          } else !0 === m && (Re(n.BLEND), (m = !1));
        }
        function ae(O) {
          C !== O && (n.frontFace(O ? n.CW : n.CCW), (C = O));
        }
        function Fe(O) {
          0 !== O
            ? (Me(n.CULL_FACE),
              O !== $ &&
                n.cullFace(
                  1 === O ? n.BACK : 2 === O ? n.FRONT : n.FRONT_AND_BACK,
                ))
            : Re(n.CULL_FACE),
            ($ = O);
        }
        function Ae(O, ye, X) {
          O
            ? (Me(n.POLYGON_OFFSET_FILL),
              (V !== ye || z !== X) &&
                (n.polygonOffset(ye, X), (V = ye), (z = X)))
            : Re(n.POLYGON_OFFSET_FILL);
        }
        return {
          buffers: { color: a, depth: l, stencil: c },
          enable: Me,
          disable: Re,
          bindFramebuffer: function Je(O, ye) {
            return (
              f[O] !== ye &&
              (n.bindFramebuffer(O, ye),
              (f[O] = ye),
              i &&
                (O === n.DRAW_FRAMEBUFFER && (f[n.FRAMEBUFFER] = ye),
                O === n.FRAMEBUFFER && (f[n.DRAW_FRAMEBUFFER] = ye)),
              !0)
            );
          },
          drawBuffers: function Ft(O, ye) {
            let X = _,
              ge = !1;
            if (O)
              if (
                ((X = p.get(ye)),
                void 0 === X && ((X = []), p.set(ye, X)),
                O.isWebGLMultipleRenderTargets)
              ) {
                const Se = O.texture;
                if (X.length !== Se.length || X[0] !== n.COLOR_ATTACHMENT0) {
                  for (let St = 0, Jt = Se.length; St < Jt; St++)
                    X[St] = n.COLOR_ATTACHMENT0 + St;
                  (X.length = Se.length), (ge = !0);
                }
              } else
                X[0] !== n.COLOR_ATTACHMENT0 &&
                  ((X[0] = n.COLOR_ATTACHMENT0), (ge = !0));
            else X[0] !== n.BACK && ((X[0] = n.BACK), (ge = !0));
            ge &&
              (t.isWebGL2
                ? n.drawBuffers(X)
                : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(X));
          },
          useProgram: function Be(O) {
            return g !== O && (n.useProgram(O), (g = O), !0);
          },
          setBlending: te,
          setMaterial: function he(O, ye) {
            2 === O.side ? Re(n.CULL_FACE) : Me(n.CULL_FACE);
            let X = 1 === O.side;
            ye && (X = !X),
              ae(X),
              1 === O.blending && !1 === O.transparent
                ? te(0)
                : te(
                    O.blending,
                    O.blendEquation,
                    O.blendSrc,
                    O.blendDst,
                    O.blendEquationAlpha,
                    O.blendSrcAlpha,
                    O.blendDstAlpha,
                    O.premultipliedAlpha,
                  ),
              l.setFunc(O.depthFunc),
              l.setTest(O.depthTest),
              l.setMask(O.depthWrite),
              a.setMask(O.colorWrite);
            const ge = O.stencilWrite;
            c.setTest(ge),
              ge &&
                (c.setMask(O.stencilWriteMask),
                c.setFunc(O.stencilFunc, O.stencilRef, O.stencilFuncMask),
                c.setOp(O.stencilFail, O.stencilZFail, O.stencilZPass)),
              Ae(O.polygonOffset, O.polygonOffsetFactor, O.polygonOffsetUnits),
              !0 === O.alphaToCoverage
                ? Me(n.SAMPLE_ALPHA_TO_COVERAGE)
                : Re(n.SAMPLE_ALPHA_TO_COVERAGE);
          },
          setFlipSided: ae,
          setCullFace: Fe,
          setLineWidth: function xe(O) {
            O !== ie && (F && n.lineWidth(O), (ie = O));
          },
          setPolygonOffset: Ae,
          setScissorTest: function et(O) {
            O ? Me(n.SCISSOR_TEST) : Re(n.SCISSOR_TEST);
          },
          activeTexture: function _t(O) {
            void 0 === O && (O = n.TEXTURE0 + W - 1),
              q !== O && (n.activeTexture(O), (q = O));
          },
          bindTexture: function sn(O, ye, X) {
            void 0 === X && (X = null === q ? n.TEXTURE0 + W - 1 : q);
            let ge = ee[X];
            void 0 === ge &&
              ((ge = { type: void 0, texture: void 0 }), (ee[X] = ge)),
              (ge.type !== O || ge.texture !== ye) &&
                (q !== X && (n.activeTexture(X), (q = X)),
                n.bindTexture(O, ye || Le[O]),
                (ge.type = O),
                (ge.texture = ye));
          },
          unbindTexture: function I() {
            const O = ee[q];
            void 0 !== O &&
              void 0 !== O.type &&
              (n.bindTexture(O.type, null),
              (O.type = void 0),
              (O.texture = void 0));
          },
          compressedTexImage2D: function w() {
            try {
              n.compressedTexImage2D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          compressedTexImage3D: function G() {
            try {
              n.compressedTexImage3D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          texImage2D: function He() {
            try {
              n.texImage2D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          texImage3D: function ke() {
            try {
              n.texImage3D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          updateUBOMapping: function Oe(O, ye) {
            let X = d.get(ye);
            void 0 === X && ((X = new WeakMap()), d.set(ye, X));
            let ge = X.get(O);
            void 0 === ge &&
              ((ge = n.getUniformBlockIndex(ye, O.name)), X.set(O, ge));
          },
          uniformBlockBinding: function ft(O, ye) {
            const ge = d.get(ye).get(O);
            u.get(ye) !== ge &&
              (n.uniformBlockBinding(ye, ge, O.__bindingPointIndex),
              u.set(ye, ge));
          },
          texStorage2D: function pe() {
            try {
              n.texStorage2D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          texStorage3D: function j() {
            try {
              n.texStorage3D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          texSubImage2D: function ue() {
            try {
              n.texSubImage2D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          texSubImage3D: function ce() {
            try {
              n.texSubImage3D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          compressedTexSubImage2D: function de() {
            try {
              n.compressedTexSubImage2D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          compressedTexSubImage3D: function Ne() {
            try {
              n.compressedTexSubImage3D.apply(n, arguments);
            } catch (O) {
              console.error("THREE.WebGLState:", O);
            }
          },
          scissor: function Ve(O) {
            !1 === fe.equals(O) && (n.scissor(O.x, O.y, O.z, O.w), fe.copy(O));
          },
          viewport: function Pe(O) {
            !1 === le.equals(O) && (n.viewport(O.x, O.y, O.z, O.w), le.copy(O));
          },
          reset: function $t() {
            n.disable(n.BLEND),
              n.disable(n.CULL_FACE),
              n.disable(n.DEPTH_TEST),
              n.disable(n.POLYGON_OFFSET_FILL),
              n.disable(n.SCISSOR_TEST),
              n.disable(n.STENCIL_TEST),
              n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
              n.blendEquation(n.FUNC_ADD),
              n.blendFunc(n.ONE, n.ZERO),
              n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
              n.colorMask(!0, !0, !0, !0),
              n.clearColor(0, 0, 0, 0),
              n.depthMask(!0),
              n.depthFunc(n.LESS),
              n.clearDepth(1),
              n.stencilMask(4294967295),
              n.stencilFunc(n.ALWAYS, 0, 4294967295),
              n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
              n.clearStencil(0),
              n.cullFace(n.BACK),
              n.frontFace(n.CCW),
              n.polygonOffset(0, 0),
              n.activeTexture(n.TEXTURE0),
              n.bindFramebuffer(n.FRAMEBUFFER, null),
              !0 === i &&
                (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
              n.useProgram(null),
              n.lineWidth(1),
              n.scissor(0, 0, n.canvas.width, n.canvas.height),
              n.viewport(0, 0, n.canvas.width, n.canvas.height),
              (h = {}),
              (q = null),
              (ee = {}),
              (f = {}),
              (p = new WeakMap()),
              (_ = []),
              (g = null),
              (m = !1),
              (y = null),
              (v = null),
              (b = null),
              (S = null),
              (E = null),
              (x = null),
              (P = null),
              (M = !1),
              (C = null),
              ($ = null),
              (ie = null),
              (V = null),
              (z = null),
              fe.set(0, 0, n.canvas.width, n.canvas.height),
              le.set(0, 0, n.canvas.width, n.canvas.height),
              a.reset(),
              l.reset(),
              c.reset();
          },
        };
      }
      function tX(n, e, t, i, r, s, o) {
        const a = r.isWebGL2,
          l = r.maxTextures,
          c = r.maxCubemapSize,
          u = r.maxTextureSize,
          d = r.maxSamples,
          h = e.has("WEBGL_multisampled_render_to_texture")
            ? e.get("WEBGL_multisampled_render_to_texture")
            : null,
          f =
            !(typeof navigator > "u") &&
            /OculusBrowser/g.test(navigator.userAgent),
          p = new WeakMap();
        let _;
        const g = new WeakMap();
        let m = !1;
        try {
          m =
            typeof OffscreenCanvas < "u" &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch {}
        function y(I, w) {
          return m ? new OffscreenCanvas(I, w) : Tu("canvas");
        }
        function v(I, w, G, ue) {
          let ce = 1;
          if (
            ((I.width > ue || I.height > ue) &&
              (ce = ue / Math.max(I.width, I.height)),
            ce < 1 || !0 === w)
          ) {
            if (
              (typeof HTMLImageElement < "u" &&
                I instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement < "u" &&
                I instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap < "u" && I instanceof ImageBitmap)
            ) {
              const de = w ? Lf : Math.floor,
                Ne = de(ce * I.width),
                pe = de(ce * I.height);
              void 0 === _ && (_ = y(Ne, pe));
              const j = G ? y(Ne, pe) : _;
              return (
                (j.width = Ne),
                (j.height = pe),
                j.getContext("2d").drawImage(I, 0, 0, Ne, pe),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    I.width +
                    "x" +
                    I.height +
                    ") to (" +
                    Ne +
                    "x" +
                    pe +
                    ").",
                ),
                j
              );
            }
            return (
              "data" in I &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    I.width +
                    "x" +
                    I.height +
                    ").",
                ),
              I
            );
          }
          return I;
        }
        function b(I) {
          return Ly(I.width) && Ly(I.height);
        }
        function E(I, w) {
          return (
            I.generateMipmaps && w && I.minFilter !== mn && I.minFilter !== gn
          );
        }
        function x(I) {
          n.generateMipmap(I);
        }
        function P(I, w, G, ue, ce = !1) {
          if (!1 === a) return w;
          if (null !== I) {
            if (void 0 !== n[I]) return n[I];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                I +
                "'",
            );
          }
          let de = w;
          return (
            w === n.RED &&
              (G === n.FLOAT && (de = n.R32F),
              G === n.HALF_FLOAT && (de = n.R16F),
              G === n.UNSIGNED_BYTE && (de = n.R8)),
            w === n.RED_INTEGER &&
              (G === n.UNSIGNED_BYTE && (de = n.R8UI),
              G === n.UNSIGNED_SHORT && (de = n.R16UI),
              G === n.UNSIGNED_INT && (de = n.R32UI),
              G === n.BYTE && (de = n.R8I),
              G === n.SHORT && (de = n.R16I),
              G === n.INT && (de = n.R32I)),
            w === n.RG &&
              (G === n.FLOAT && (de = n.RG32F),
              G === n.HALF_FLOAT && (de = n.RG16F),
              G === n.UNSIGNED_BYTE && (de = n.RG8)),
            w === n.RGBA &&
              (G === n.FLOAT && (de = n.RGBA32F),
              G === n.HALF_FLOAT && (de = n.RGBA16F),
              G === n.UNSIGNED_BYTE &&
                (de = ue === rt && !1 === ce ? n.SRGB8_ALPHA8 : n.RGBA8),
              G === n.UNSIGNED_SHORT_4_4_4_4 && (de = n.RGBA4),
              G === n.UNSIGNED_SHORT_5_5_5_1 && (de = n.RGB5_A1)),
            (de === n.R16F ||
              de === n.R32F ||
              de === n.RG16F ||
              de === n.RG32F ||
              de === n.RGBA16F ||
              de === n.RGBA32F) &&
              e.get("EXT_color_buffer_float"),
            de
          );
        }
        function M(I, w, G) {
          return !0 === E(I, G) ||
            (I.isFramebufferTexture && I.minFilter !== mn && I.minFilter !== gn)
            ? Math.log2(Math.max(w.width, w.height)) + 1
            : void 0 !== I.mipmaps && I.mipmaps.length > 0
            ? I.mipmaps.length
            : I.isCompressedTexture && Array.isArray(I.image)
            ? w.mipmaps.length
            : 1;
        }
        function C(I) {
          return I === mn || 1004 === I || 1005 === I ? n.NEAREST : n.LINEAR;
        }
        function $(I) {
          const w = I.target;
          w.removeEventListener("dispose", $),
            (function V(I) {
              const w = i.get(I);
              if (void 0 === w.__webglInit) return;
              const G = I.source,
                ue = g.get(G);
              if (ue) {
                const ce = ue[w.__cacheKey];
                ce.usedTimes--,
                  0 === ce.usedTimes && z(I),
                  0 === Object.keys(ue).length && g.delete(G);
              }
              i.remove(I);
            })(w),
            w.isVideoTexture && p.delete(w);
        }
        function ie(I) {
          const w = I.target;
          w.removeEventListener("dispose", ie),
            (function W(I) {
              const w = I.texture,
                G = i.get(I),
                ue = i.get(w);
              if (
                (void 0 !== ue.__webglTexture &&
                  (n.deleteTexture(ue.__webglTexture), o.memory.textures--),
                I.depthTexture && I.depthTexture.dispose(),
                I.isWebGLCubeRenderTarget)
              )
                for (let ce = 0; ce < 6; ce++) {
                  if (Array.isArray(G.__webglFramebuffer[ce]))
                    for (let de = 0; de < G.__webglFramebuffer[ce].length; de++)
                      n.deleteFramebuffer(G.__webglFramebuffer[ce][de]);
                  else n.deleteFramebuffer(G.__webglFramebuffer[ce]);
                  G.__webglDepthbuffer &&
                    n.deleteRenderbuffer(G.__webglDepthbuffer[ce]);
                }
              else {
                if (Array.isArray(G.__webglFramebuffer))
                  for (let ce = 0; ce < G.__webglFramebuffer.length; ce++)
                    n.deleteFramebuffer(G.__webglFramebuffer[ce]);
                else n.deleteFramebuffer(G.__webglFramebuffer);
                if (
                  (G.__webglDepthbuffer &&
                    n.deleteRenderbuffer(G.__webglDepthbuffer),
                  G.__webglMultisampledFramebuffer &&
                    n.deleteFramebuffer(G.__webglMultisampledFramebuffer),
                  G.__webglColorRenderbuffer)
                )
                  for (let ce = 0; ce < G.__webglColorRenderbuffer.length; ce++)
                    G.__webglColorRenderbuffer[ce] &&
                      n.deleteRenderbuffer(G.__webglColorRenderbuffer[ce]);
                G.__webglDepthRenderbuffer &&
                  n.deleteRenderbuffer(G.__webglDepthRenderbuffer);
              }
              if (I.isWebGLMultipleRenderTargets)
                for (let ce = 0, de = w.length; ce < de; ce++) {
                  const Ne = i.get(w[ce]);
                  Ne.__webglTexture &&
                    (n.deleteTexture(Ne.__webglTexture), o.memory.textures--),
                    i.remove(w[ce]);
                }
              i.remove(w), i.remove(I);
            })(w);
        }
        function z(I) {
          const w = i.get(I);
          n.deleteTexture(w.__webglTexture),
            delete g.get(I.source)[w.__cacheKey],
            o.memory.textures--;
        }
        let F = 0;
        function ee(I, w) {
          const G = i.get(I);
          if (
            (I.isVideoTexture &&
              (function _t(I) {
                const w = o.render.frame;
                p.get(I) !== w && (p.set(I, w), I.update());
              })(I),
            !1 === I.isRenderTargetTexture &&
              I.version > 0 &&
              G.__version !== I.version)
          ) {
            const ue = I.image;
            if (null === ue)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found.",
              );
            else {
              if (!1 !== ue.complete) return void Je(G, I, w);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
              );
            }
          }
          t.bindTexture(n.TEXTURE_2D, G.__webglTexture, n.TEXTURE0 + w);
        }
        const le = {
            1e3: n.REPEAT,
            [ei]: n.CLAMP_TO_EDGE,
            1002: n.MIRRORED_REPEAT,
          },
          be = {
            [mn]: n.NEAREST,
            1004: n.NEAREST_MIPMAP_NEAREST,
            1005: n.NEAREST_MIPMAP_LINEAR,
            [gn]: n.LINEAR,
            1007: n.LINEAR_MIPMAP_NEAREST,
            [Ro]: n.LINEAR_MIPMAP_LINEAR,
          },
          Le = {
            512: n.NEVER,
            519: n.ALWAYS,
            513: n.LESS,
            515: n.LEQUAL,
            514: n.EQUAL,
            518: n.GEQUAL,
            516: n.GREATER,
            517: n.NOTEQUAL,
          };
        function Me(I, w, G) {
          if (
            (G
              ? (n.texParameteri(I, n.TEXTURE_WRAP_S, le[w.wrapS]),
                n.texParameteri(I, n.TEXTURE_WRAP_T, le[w.wrapT]),
                (I === n.TEXTURE_3D || I === n.TEXTURE_2D_ARRAY) &&
                  n.texParameteri(I, n.TEXTURE_WRAP_R, le[w.wrapR]),
                n.texParameteri(I, n.TEXTURE_MAG_FILTER, be[w.magFilter]),
                n.texParameteri(I, n.TEXTURE_MIN_FILTER, be[w.minFilter]))
              : (n.texParameteri(I, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
                n.texParameteri(I, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
                (I === n.TEXTURE_3D || I === n.TEXTURE_2D_ARRAY) &&
                  n.texParameteri(I, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
                (w.wrapS !== ei || w.wrapT !== ei) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
                  ),
                n.texParameteri(I, n.TEXTURE_MAG_FILTER, C(w.magFilter)),
                n.texParameteri(I, n.TEXTURE_MIN_FILTER, C(w.minFilter)),
                w.minFilter !== mn &&
                  w.minFilter !== gn &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
                  )),
            w.compareFunction &&
              (n.texParameteri(
                I,
                n.TEXTURE_COMPARE_MODE,
                n.COMPARE_REF_TO_TEXTURE,
              ),
              n.texParameteri(
                I,
                n.TEXTURE_COMPARE_FUNC,
                Le[w.compareFunction],
              )),
            !0 === e.has("EXT_texture_filter_anisotropic"))
          ) {
            const ue = e.get("EXT_texture_filter_anisotropic");
            if (
              w.magFilter === mn ||
              (1005 !== w.minFilter && w.minFilter !== Ro) ||
              (w.type === as && !1 === e.has("OES_texture_float_linear")) ||
              (!1 === a &&
                w.type === Cu &&
                !1 === e.has("OES_texture_half_float_linear"))
            )
              return;
            (w.anisotropy > 1 || i.get(w).__currentAnisotropy) &&
              (n.texParameterf(
                I,
                ue.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(w.anisotropy, r.getMaxAnisotropy()),
              ),
              (i.get(w).__currentAnisotropy = w.anisotropy));
          }
        }
        function Re(I, w) {
          let G = !1;
          void 0 === I.__webglInit &&
            ((I.__webglInit = !0), w.addEventListener("dispose", $));
          const ue = w.source;
          let ce = g.get(ue);
          void 0 === ce && ((ce = {}), g.set(ue, ce));
          const de = (function q(I) {
            const w = [];
            return (
              w.push(I.wrapS),
              w.push(I.wrapT),
              w.push(I.wrapR || 0),
              w.push(I.magFilter),
              w.push(I.minFilter),
              w.push(I.anisotropy),
              w.push(I.internalFormat),
              w.push(I.format),
              w.push(I.type),
              w.push(I.generateMipmaps),
              w.push(I.premultiplyAlpha),
              w.push(I.flipY),
              w.push(I.unpackAlignment),
              w.push(I.colorSpace),
              w.join()
            );
          })(w);
          if (de !== I.__cacheKey) {
            void 0 === ce[de] &&
              ((ce[de] = { texture: n.createTexture(), usedTimes: 0 }),
              o.memory.textures++,
              (G = !0)),
              ce[de].usedTimes++;
            const Ne = ce[I.__cacheKey];
            void 0 !== Ne &&
              (ce[I.__cacheKey].usedTimes--, 0 === Ne.usedTimes && z(w)),
              (I.__cacheKey = de),
              (I.__webglTexture = ce[de].texture);
          }
          return G;
        }
        function Je(I, w, G) {
          let ue = n.TEXTURE_2D;
          (w.isDataArrayTexture || w.isCompressedArrayTexture) &&
            (ue = n.TEXTURE_2D_ARRAY),
            w.isData3DTexture && (ue = n.TEXTURE_3D);
          const ce = Re(I, w),
            de = w.source;
          t.bindTexture(ue, I.__webglTexture, n.TEXTURE0 + G);
          const Ne = i.get(de);
          if (de.version !== Ne.__version || !0 === ce) {
            t.activeTexture(n.TEXTURE0 + G),
              n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, w.flipY),
              n.pixelStorei(
                n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                w.premultiplyAlpha,
              ),
              n.pixelStorei(n.UNPACK_ALIGNMENT, w.unpackAlignment),
              n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
            const pe =
              (function S(I) {
                return (
                  !a &&
                  (I.wrapS !== ei ||
                    I.wrapT !== ei ||
                    (I.minFilter !== mn && I.minFilter !== gn))
                );
              })(w) && !1 === b(w.image);
            let j = v(w.image, pe, !1, u);
            j = sn(w, j);
            const He = b(j) || a,
              ke = s.convert(w.format, w.colorSpace);
            let Oe,
              Ve = s.convert(w.type),
              Pe = P(w.internalFormat, ke, Ve, w.colorSpace);
            Me(ue, w, He);
            const ft = w.mipmaps,
              $t = a && !0 !== w.isVideoTexture,
              O = void 0 === Ne.__version || !0 === ce,
              ye = M(w, j, He);
            if (w.isDepthTexture)
              (Pe = n.DEPTH_COMPONENT),
                a
                  ? (Pe =
                      w.type === as
                        ? n.DEPTH_COMPONENT32F
                        : w.type === Hs
                        ? n.DEPTH_COMPONENT24
                        : w.type === Po
                        ? n.DEPTH24_STENCIL8
                        : n.DEPTH_COMPONENT16)
                  : w.type === as &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2.",
                    ),
                w.format === Oo &&
                  Pe === n.DEPTH_COMPONENT &&
                  1012 !== w.type &&
                  w.type !== Hs &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.",
                  ),
                  (w.type = Hs),
                  (Ve = s.convert(w.type))),
                w.format === ml &&
                  Pe === n.DEPTH_COMPONENT &&
                  ((Pe = n.DEPTH_STENCIL),
                  w.type !== Po &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
                    ),
                    (w.type = Po),
                    (Ve = s.convert(w.type)))),
                O &&
                  ($t
                    ? t.texStorage2D(n.TEXTURE_2D, 1, Pe, j.width, j.height)
                    : t.texImage2D(
                        n.TEXTURE_2D,
                        0,
                        Pe,
                        j.width,
                        j.height,
                        0,
                        ke,
                        Ve,
                        null,
                      ));
            else if (w.isDataTexture)
              if (ft.length > 0 && He) {
                $t &&
                  O &&
                  t.texStorage2D(
                    n.TEXTURE_2D,
                    ye,
                    Pe,
                    ft[0].width,
                    ft[0].height,
                  );
                for (let X = 0, ge = ft.length; X < ge; X++)
                  (Oe = ft[X]),
                    $t
                      ? t.texSubImage2D(
                          n.TEXTURE_2D,
                          X,
                          0,
                          0,
                          Oe.width,
                          Oe.height,
                          ke,
                          Ve,
                          Oe.data,
                        )
                      : t.texImage2D(
                          n.TEXTURE_2D,
                          X,
                          Pe,
                          Oe.width,
                          Oe.height,
                          0,
                          ke,
                          Ve,
                          Oe.data,
                        );
                w.generateMipmaps = !1;
              } else
                $t
                  ? (O &&
                      t.texStorage2D(n.TEXTURE_2D, ye, Pe, j.width, j.height),
                    t.texSubImage2D(
                      n.TEXTURE_2D,
                      0,
                      0,
                      0,
                      j.width,
                      j.height,
                      ke,
                      Ve,
                      j.data,
                    ))
                  : t.texImage2D(
                      n.TEXTURE_2D,
                      0,
                      Pe,
                      j.width,
                      j.height,
                      0,
                      ke,
                      Ve,
                      j.data,
                    );
            else if (w.isCompressedTexture)
              if (w.isCompressedArrayTexture) {
                $t &&
                  O &&
                  t.texStorage3D(
                    n.TEXTURE_2D_ARRAY,
                    ye,
                    Pe,
                    ft[0].width,
                    ft[0].height,
                    j.depth,
                  );
                for (let X = 0, ge = ft.length; X < ge; X++)
                  (Oe = ft[X]),
                    w.format !== Ki
                      ? null !== ke
                        ? $t
                          ? t.compressedTexSubImage3D(
                              n.TEXTURE_2D_ARRAY,
                              X,
                              0,
                              0,
                              0,
                              Oe.width,
                              Oe.height,
                              j.depth,
                              ke,
                              Oe.data,
                              0,
                              0,
                            )
                          : t.compressedTexImage3D(
                              n.TEXTURE_2D_ARRAY,
                              X,
                              Pe,
                              Oe.width,
                              Oe.height,
                              j.depth,
                              0,
                              Oe.data,
                              0,
                              0,
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                          )
                      : $t
                      ? t.texSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          X,
                          0,
                          0,
                          0,
                          Oe.width,
                          Oe.height,
                          j.depth,
                          ke,
                          Ve,
                          Oe.data,
                        )
                      : t.texImage3D(
                          n.TEXTURE_2D_ARRAY,
                          X,
                          Pe,
                          Oe.width,
                          Oe.height,
                          j.depth,
                          0,
                          ke,
                          Ve,
                          Oe.data,
                        );
              } else {
                $t &&
                  O &&
                  t.texStorage2D(
                    n.TEXTURE_2D,
                    ye,
                    Pe,
                    ft[0].width,
                    ft[0].height,
                  );
                for (let X = 0, ge = ft.length; X < ge; X++)
                  (Oe = ft[X]),
                    w.format !== Ki
                      ? null !== ke
                        ? $t
                          ? t.compressedTexSubImage2D(
                              n.TEXTURE_2D,
                              X,
                              0,
                              0,
                              Oe.width,
                              Oe.height,
                              ke,
                              Oe.data,
                            )
                          : t.compressedTexImage2D(
                              n.TEXTURE_2D,
                              X,
                              Pe,
                              Oe.width,
                              Oe.height,
                              0,
                              Oe.data,
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                          )
                      : $t
                      ? t.texSubImage2D(
                          n.TEXTURE_2D,
                          X,
                          0,
                          0,
                          Oe.width,
                          Oe.height,
                          ke,
                          Ve,
                          Oe.data,
                        )
                      : t.texImage2D(
                          n.TEXTURE_2D,
                          X,
                          Pe,
                          Oe.width,
                          Oe.height,
                          0,
                          ke,
                          Ve,
                          Oe.data,
                        );
              }
            else if (w.isDataArrayTexture)
              $t
                ? (O &&
                    t.texStorage3D(
                      n.TEXTURE_2D_ARRAY,
                      ye,
                      Pe,
                      j.width,
                      j.height,
                      j.depth,
                    ),
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    0,
                    0,
                    0,
                    0,
                    j.width,
                    j.height,
                    j.depth,
                    ke,
                    Ve,
                    j.data,
                  ))
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    0,
                    Pe,
                    j.width,
                    j.height,
                    j.depth,
                    0,
                    ke,
                    Ve,
                    j.data,
                  );
            else if (w.isData3DTexture)
              $t
                ? (O &&
                    t.texStorage3D(
                      n.TEXTURE_3D,
                      ye,
                      Pe,
                      j.width,
                      j.height,
                      j.depth,
                    ),
                  t.texSubImage3D(
                    n.TEXTURE_3D,
                    0,
                    0,
                    0,
                    0,
                    j.width,
                    j.height,
                    j.depth,
                    ke,
                    Ve,
                    j.data,
                  ))
                : t.texImage3D(
                    n.TEXTURE_3D,
                    0,
                    Pe,
                    j.width,
                    j.height,
                    j.depth,
                    0,
                    ke,
                    Ve,
                    j.data,
                  );
            else if (w.isFramebufferTexture) {
              if (O)
                if ($t) t.texStorage2D(n.TEXTURE_2D, ye, Pe, j.width, j.height);
                else {
                  let X = j.width,
                    ge = j.height;
                  for (let Se = 0; Se < ye; Se++)
                    t.texImage2D(n.TEXTURE_2D, Se, Pe, X, ge, 0, ke, Ve, null),
                      (X >>= 1),
                      (ge >>= 1);
                }
            } else if (ft.length > 0 && He) {
              $t &&
                O &&
                t.texStorage2D(n.TEXTURE_2D, ye, Pe, ft[0].width, ft[0].height);
              for (let X = 0, ge = ft.length; X < ge; X++)
                (Oe = ft[X]),
                  $t
                    ? t.texSubImage2D(n.TEXTURE_2D, X, 0, 0, ke, Ve, Oe)
                    : t.texImage2D(n.TEXTURE_2D, X, Pe, ke, Ve, Oe);
              w.generateMipmaps = !1;
            } else
              $t
                ? (O && t.texStorage2D(n.TEXTURE_2D, ye, Pe, j.width, j.height),
                  t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, ke, Ve, j))
                : t.texImage2D(n.TEXTURE_2D, 0, Pe, ke, Ve, j);
            E(w, He) && x(ue),
              (Ne.__version = de.version),
              w.onUpdate && w.onUpdate(w);
          }
          I.__version = w.version;
        }
        function Be(I, w, G, ue, ce, de) {
          const Ne = s.convert(G.format, G.colorSpace),
            pe = s.convert(G.type),
            j = P(G.internalFormat, Ne, pe, G.colorSpace);
          if (!i.get(w).__hasExternalTextures) {
            const ke = Math.max(1, w.width >> de),
              Ve = Math.max(1, w.height >> de);
            ce === n.TEXTURE_3D || ce === n.TEXTURE_2D_ARRAY
              ? t.texImage3D(ce, de, j, ke, Ve, w.depth, 0, Ne, pe, null)
              : t.texImage2D(ce, de, j, ke, Ve, 0, Ne, pe, null);
          }
          t.bindFramebuffer(n.FRAMEBUFFER, I),
            et(w)
              ? h.framebufferTexture2DMultisampleEXT(
                  n.FRAMEBUFFER,
                  ue,
                  ce,
                  i.get(G).__webglTexture,
                  0,
                  Ae(w),
                )
              : (ce === n.TEXTURE_2D ||
                  (ce >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
                    ce <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                n.framebufferTexture2D(
                  n.FRAMEBUFFER,
                  ue,
                  ce,
                  i.get(G).__webglTexture,
                  de,
                ),
            t.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function R(I, w, G) {
          if (
            (n.bindRenderbuffer(n.RENDERBUFFER, I),
            w.depthBuffer && !w.stencilBuffer)
          ) {
            let ue = n.DEPTH_COMPONENT16;
            if (G || et(w)) {
              const ce = w.depthTexture;
              ce &&
                ce.isDepthTexture &&
                (ce.type === as
                  ? (ue = n.DEPTH_COMPONENT32F)
                  : ce.type === Hs && (ue = n.DEPTH_COMPONENT24));
              const de = Ae(w);
              et(w)
                ? h.renderbufferStorageMultisampleEXT(
                    n.RENDERBUFFER,
                    de,
                    ue,
                    w.width,
                    w.height,
                  )
                : n.renderbufferStorageMultisample(
                    n.RENDERBUFFER,
                    de,
                    ue,
                    w.width,
                    w.height,
                  );
            } else n.renderbufferStorage(n.RENDERBUFFER, ue, w.width, w.height);
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.DEPTH_ATTACHMENT,
              n.RENDERBUFFER,
              I,
            );
          } else if (w.depthBuffer && w.stencilBuffer) {
            const ue = Ae(w);
            G && !1 === et(w)
              ? n.renderbufferStorageMultisample(
                  n.RENDERBUFFER,
                  ue,
                  n.DEPTH24_STENCIL8,
                  w.width,
                  w.height,
                )
              : et(w)
              ? h.renderbufferStorageMultisampleEXT(
                  n.RENDERBUFFER,
                  ue,
                  n.DEPTH24_STENCIL8,
                  w.width,
                  w.height,
                )
              : n.renderbufferStorage(
                  n.RENDERBUFFER,
                  n.DEPTH_STENCIL,
                  w.width,
                  w.height,
                ),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.DEPTH_STENCIL_ATTACHMENT,
                n.RENDERBUFFER,
                I,
              );
          } else {
            const ue =
              !0 === w.isWebGLMultipleRenderTargets ? w.texture : [w.texture];
            for (let ce = 0; ce < ue.length; ce++) {
              const de = ue[ce],
                Ne = s.convert(de.format, de.colorSpace),
                pe = s.convert(de.type),
                j = P(de.internalFormat, Ne, pe, de.colorSpace),
                He = Ae(w);
              G && !1 === et(w)
                ? n.renderbufferStorageMultisample(
                    n.RENDERBUFFER,
                    He,
                    j,
                    w.width,
                    w.height,
                  )
                : et(w)
                ? h.renderbufferStorageMultisampleEXT(
                    n.RENDERBUFFER,
                    He,
                    j,
                    w.width,
                    w.height,
                  )
                : n.renderbufferStorage(n.RENDERBUFFER, j, w.width, w.height);
            }
          }
          n.bindRenderbuffer(n.RENDERBUFFER, null);
        }
        function te(I) {
          const w = i.get(I),
            G = !0 === I.isWebGLCubeRenderTarget;
          if (I.depthTexture && !w.__autoAllocateDepthBuffer) {
            if (G)
              throw new Error(
                "target.depthTexture not supported in Cube render targets",
              );
            !(function me(I, w) {
              if (w && w.isWebGLCubeRenderTarget)
                throw new Error(
                  "Depth Texture with cube render targets is not supported",
                );
              if (
                (t.bindFramebuffer(n.FRAMEBUFFER, I),
                !w.depthTexture || !w.depthTexture.isDepthTexture)
              )
                throw new Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
                );
              (!i.get(w.depthTexture).__webglTexture ||
                w.depthTexture.image.width !== w.width ||
                w.depthTexture.image.height !== w.height) &&
                ((w.depthTexture.image.width = w.width),
                (w.depthTexture.image.height = w.height),
                (w.depthTexture.needsUpdate = !0)),
                ee(w.depthTexture, 0);
              const ue = i.get(w.depthTexture).__webglTexture,
                ce = Ae(w);
              if (w.depthTexture.format === Oo)
                et(w)
                  ? h.framebufferTexture2DMultisampleEXT(
                      n.FRAMEBUFFER,
                      n.DEPTH_ATTACHMENT,
                      n.TEXTURE_2D,
                      ue,
                      0,
                      ce,
                    )
                  : n.framebufferTexture2D(
                      n.FRAMEBUFFER,
                      n.DEPTH_ATTACHMENT,
                      n.TEXTURE_2D,
                      ue,
                      0,
                    );
              else {
                if (w.depthTexture.format !== ml)
                  throw new Error("Unknown depthTexture format");
                et(w)
                  ? h.framebufferTexture2DMultisampleEXT(
                      n.FRAMEBUFFER,
                      n.DEPTH_STENCIL_ATTACHMENT,
                      n.TEXTURE_2D,
                      ue,
                      0,
                      ce,
                    )
                  : n.framebufferTexture2D(
                      n.FRAMEBUFFER,
                      n.DEPTH_STENCIL_ATTACHMENT,
                      n.TEXTURE_2D,
                      ue,
                      0,
                    );
              }
            })(w.__webglFramebuffer, I);
          } else if (G) {
            w.__webglDepthbuffer = [];
            for (let ue = 0; ue < 6; ue++)
              t.bindFramebuffer(n.FRAMEBUFFER, w.__webglFramebuffer[ue]),
                (w.__webglDepthbuffer[ue] = n.createRenderbuffer()),
                R(w.__webglDepthbuffer[ue], I, !1);
          } else
            t.bindFramebuffer(n.FRAMEBUFFER, w.__webglFramebuffer),
              (w.__webglDepthbuffer = n.createRenderbuffer()),
              R(w.__webglDepthbuffer, I, !1);
          t.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function Ae(I) {
          return Math.min(d, I.samples);
        }
        function et(I) {
          const w = i.get(I);
          return (
            a &&
            I.samples > 0 &&
            !0 === e.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== w.__useRenderToTexture
          );
        }
        function sn(I, w) {
          const G = I.colorSpace,
            ue = I.format,
            ce = I.type;
          return (
            !0 === I.isCompressedTexture ||
              1035 === I.format ||
              (G !== Nr &&
                "" !== G &&
                (G === rt
                  ? !1 === a
                    ? !0 === e.has("EXT_sRGB") && ue === Ki
                      ? ((I.format = 1035),
                        (I.minFilter = gn),
                        (I.generateMipmaps = !1))
                      : (w = uR.sRGBToLinear(w))
                    : (ue !== Ki || ce !== Vs) &&
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture color space:",
                      G,
                    ))),
            w
          );
        }
        (this.allocateTextureUnit = function k() {
          const I = F;
          return (
            I >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  I +
                  " texture units while this GPU supports only " +
                  l,
              ),
            (F += 1),
            I
          );
        }),
          (this.resetTextureUnits = function N() {
            F = 0;
          }),
          (this.setTexture2D = ee),
          (this.setTexture2DArray = function U(I, w) {
            const G = i.get(I);
            I.version > 0 && G.__version !== I.version
              ? Je(G, I, w)
              : t.bindTexture(
                  n.TEXTURE_2D_ARRAY,
                  G.__webglTexture,
                  n.TEXTURE0 + w,
                );
          }),
          (this.setTexture3D = function K(I, w) {
            const G = i.get(I);
            I.version > 0 && G.__version !== I.version
              ? Je(G, I, w)
              : t.bindTexture(n.TEXTURE_3D, G.__webglTexture, n.TEXTURE0 + w);
          }),
          (this.setTextureCube = function fe(I, w) {
            const G = i.get(I);
            I.version > 0 && G.__version !== I.version
              ? (function Ft(I, w, G) {
                  if (6 !== w.image.length) return;
                  const ue = Re(I, w),
                    ce = w.source;
                  t.bindTexture(
                    n.TEXTURE_CUBE_MAP,
                    I.__webglTexture,
                    n.TEXTURE0 + G,
                  );
                  const de = i.get(ce);
                  if (ce.version !== de.__version || !0 === ue) {
                    t.activeTexture(n.TEXTURE0 + G),
                      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, w.flipY),
                      n.pixelStorei(
                        n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                        w.premultiplyAlpha,
                      ),
                      n.pixelStorei(n.UNPACK_ALIGNMENT, w.unpackAlignment),
                      n.pixelStorei(
                        n.UNPACK_COLORSPACE_CONVERSION_WEBGL,
                        n.NONE,
                      );
                    const Ne =
                        w.isCompressedTexture || w.image[0].isCompressedTexture,
                      pe = w.image[0] && w.image[0].isDataTexture,
                      j = [];
                    for (let X = 0; X < 6; X++)
                      (j[X] =
                        Ne || pe
                          ? pe
                            ? w.image[X].image
                            : w.image[X]
                          : v(w.image[X], !1, !0, c)),
                        (j[X] = sn(w, j[X]));
                    const He = j[0],
                      ke = b(He) || a,
                      Ve = s.convert(w.format, w.colorSpace),
                      Pe = s.convert(w.type),
                      Oe = P(w.internalFormat, Ve, Pe, w.colorSpace),
                      ft = a && !0 !== w.isVideoTexture,
                      $t = void 0 === de.__version || !0 === ue;
                    let ye,
                      O = M(w, He, ke);
                    if ((Me(n.TEXTURE_CUBE_MAP, w, ke), Ne)) {
                      ft &&
                        $t &&
                        t.texStorage2D(
                          n.TEXTURE_CUBE_MAP,
                          O,
                          Oe,
                          He.width,
                          He.height,
                        );
                      for (let X = 0; X < 6; X++) {
                        ye = j[X].mipmaps;
                        for (let ge = 0; ge < ye.length; ge++) {
                          const Se = ye[ge];
                          w.format !== Ki
                            ? null !== Ve
                              ? ft
                                ? t.compressedTexSubImage2D(
                                    n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                    ge,
                                    0,
                                    0,
                                    Se.width,
                                    Se.height,
                                    Ve,
                                    Se.data,
                                  )
                                : t.compressedTexImage2D(
                                    n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                    ge,
                                    Oe,
                                    Se.width,
                                    Se.height,
                                    0,
                                    Se.data,
                                  )
                              : console.warn(
                                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                                )
                            : ft
                            ? t.texSubImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                ge,
                                0,
                                0,
                                Se.width,
                                Se.height,
                                Ve,
                                Pe,
                                Se.data,
                              )
                            : t.texImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                ge,
                                Oe,
                                Se.width,
                                Se.height,
                                0,
                                Ve,
                                Pe,
                                Se.data,
                              );
                        }
                      }
                    } else {
                      (ye = w.mipmaps),
                        ft &&
                          $t &&
                          (ye.length > 0 && O++,
                          t.texStorage2D(
                            n.TEXTURE_CUBE_MAP,
                            O,
                            Oe,
                            j[0].width,
                            j[0].height,
                          ));
                      for (let X = 0; X < 6; X++)
                        if (pe) {
                          ft
                            ? t.texSubImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                0,
                                0,
                                0,
                                j[X].width,
                                j[X].height,
                                Ve,
                                Pe,
                                j[X].data,
                              )
                            : t.texImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                0,
                                Oe,
                                j[X].width,
                                j[X].height,
                                0,
                                Ve,
                                Pe,
                                j[X].data,
                              );
                          for (let ge = 0; ge < ye.length; ge++) {
                            const St = ye[ge].image[X].image;
                            ft
                              ? t.texSubImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                  ge + 1,
                                  0,
                                  0,
                                  St.width,
                                  St.height,
                                  Ve,
                                  Pe,
                                  St.data,
                                )
                              : t.texImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                  ge + 1,
                                  Oe,
                                  St.width,
                                  St.height,
                                  0,
                                  Ve,
                                  Pe,
                                  St.data,
                                );
                          }
                        } else {
                          ft
                            ? t.texSubImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                0,
                                0,
                                0,
                                Ve,
                                Pe,
                                j[X],
                              )
                            : t.texImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                0,
                                Oe,
                                Ve,
                                Pe,
                                j[X],
                              );
                          for (let ge = 0; ge < ye.length; ge++) {
                            const Se = ye[ge];
                            ft
                              ? t.texSubImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                  ge + 1,
                                  0,
                                  0,
                                  Ve,
                                  Pe,
                                  Se.image[X],
                                )
                              : t.texImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                                  ge + 1,
                                  Oe,
                                  Ve,
                                  Pe,
                                  Se.image[X],
                                );
                          }
                        }
                    }
                    E(w, ke) && x(n.TEXTURE_CUBE_MAP),
                      (de.__version = ce.version),
                      w.onUpdate && w.onUpdate(w);
                  }
                  I.__version = w.version;
                })(G, I, w)
              : t.bindTexture(
                  n.TEXTURE_CUBE_MAP,
                  G.__webglTexture,
                  n.TEXTURE0 + w,
                );
          }),
          (this.rebindTextures = function he(I, w, G) {
            const ue = i.get(I);
            void 0 !== w &&
              Be(
                ue.__webglFramebuffer,
                I,
                I.texture,
                n.COLOR_ATTACHMENT0,
                n.TEXTURE_2D,
                0,
              ),
              void 0 !== G && te(I);
          }),
          (this.setupRenderTarget = function ae(I) {
            const w = I.texture,
              G = i.get(I),
              ue = i.get(w);
            I.addEventListener("dispose", ie),
              !0 !== I.isWebGLMultipleRenderTargets &&
                (void 0 === ue.__webglTexture &&
                  (ue.__webglTexture = n.createTexture()),
                (ue.__version = w.version),
                o.memory.textures++);
            const ce = !0 === I.isWebGLCubeRenderTarget,
              de = !0 === I.isWebGLMultipleRenderTargets,
              Ne = b(I) || a;
            if (ce) {
              G.__webglFramebuffer = [];
              for (let pe = 0; pe < 6; pe++)
                if (a && w.mipmaps && w.mipmaps.length > 0) {
                  G.__webglFramebuffer[pe] = [];
                  for (let j = 0; j < w.mipmaps.length; j++)
                    G.__webglFramebuffer[pe][j] = n.createFramebuffer();
                } else G.__webglFramebuffer[pe] = n.createFramebuffer();
            } else {
              if (a && w.mipmaps && w.mipmaps.length > 0) {
                G.__webglFramebuffer = [];
                for (let pe = 0; pe < w.mipmaps.length; pe++)
                  G.__webglFramebuffer[pe] = n.createFramebuffer();
              } else G.__webglFramebuffer = n.createFramebuffer();
              if (de)
                if (r.drawBuffers) {
                  const pe = I.texture;
                  for (let j = 0, He = pe.length; j < He; j++) {
                    const ke = i.get(pe[j]);
                    void 0 === ke.__webglTexture &&
                      ((ke.__webglTexture = n.createTexture()),
                      o.memory.textures++);
                  }
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.",
                  );
              if (a && I.samples > 0 && !1 === et(I)) {
                const pe = de ? w : [w];
                (G.__webglMultisampledFramebuffer = n.createFramebuffer()),
                  (G.__webglColorRenderbuffer = []),
                  t.bindFramebuffer(
                    n.FRAMEBUFFER,
                    G.__webglMultisampledFramebuffer,
                  );
                for (let j = 0; j < pe.length; j++) {
                  const He = pe[j];
                  (G.__webglColorRenderbuffer[j] = n.createRenderbuffer()),
                    n.bindRenderbuffer(
                      n.RENDERBUFFER,
                      G.__webglColorRenderbuffer[j],
                    );
                  const ke = s.convert(He.format, He.colorSpace),
                    Ve = s.convert(He.type),
                    Pe = P(
                      He.internalFormat,
                      ke,
                      Ve,
                      He.colorSpace,
                      !0 === I.isXRRenderTarget,
                    ),
                    Oe = Ae(I);
                  n.renderbufferStorageMultisample(
                    n.RENDERBUFFER,
                    Oe,
                    Pe,
                    I.width,
                    I.height,
                  ),
                    n.framebufferRenderbuffer(
                      n.FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + j,
                      n.RENDERBUFFER,
                      G.__webglColorRenderbuffer[j],
                    );
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                  I.depthBuffer &&
                    ((G.__webglDepthRenderbuffer = n.createRenderbuffer()),
                    R(G.__webglDepthRenderbuffer, I, !0)),
                  t.bindFramebuffer(n.FRAMEBUFFER, null);
              }
            }
            if (ce) {
              t.bindTexture(n.TEXTURE_CUBE_MAP, ue.__webglTexture),
                Me(n.TEXTURE_CUBE_MAP, w, Ne);
              for (let pe = 0; pe < 6; pe++)
                if (a && w.mipmaps && w.mipmaps.length > 0)
                  for (let j = 0; j < w.mipmaps.length; j++)
                    Be(
                      G.__webglFramebuffer[pe][j],
                      I,
                      w,
                      n.COLOR_ATTACHMENT0,
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + pe,
                      j,
                    );
                else
                  Be(
                    G.__webglFramebuffer[pe],
                    I,
                    w,
                    n.COLOR_ATTACHMENT0,
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + pe,
                    0,
                  );
              E(w, Ne) && x(n.TEXTURE_CUBE_MAP), t.unbindTexture();
            } else if (de) {
              const pe = I.texture;
              for (let j = 0, He = pe.length; j < He; j++) {
                const ke = pe[j],
                  Ve = i.get(ke);
                t.bindTexture(n.TEXTURE_2D, Ve.__webglTexture),
                  Me(n.TEXTURE_2D, ke, Ne),
                  Be(
                    G.__webglFramebuffer,
                    I,
                    ke,
                    n.COLOR_ATTACHMENT0 + j,
                    n.TEXTURE_2D,
                    0,
                  ),
                  E(ke, Ne) && x(n.TEXTURE_2D);
              }
              t.unbindTexture();
            } else {
              let pe = n.TEXTURE_2D;
              if (
                ((I.isWebGL3DRenderTarget || I.isWebGLArrayRenderTarget) &&
                  (a
                    ? (pe = I.isWebGL3DRenderTarget
                        ? n.TEXTURE_3D
                        : n.TEXTURE_2D_ARRAY)
                    : console.error(
                        "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.",
                      )),
                t.bindTexture(pe, ue.__webglTexture),
                Me(pe, w, Ne),
                a && w.mipmaps && w.mipmaps.length > 0)
              )
                for (let j = 0; j < w.mipmaps.length; j++)
                  Be(G.__webglFramebuffer[j], I, w, n.COLOR_ATTACHMENT0, pe, j);
              else Be(G.__webglFramebuffer, I, w, n.COLOR_ATTACHMENT0, pe, 0);
              E(w, Ne) && x(pe), t.unbindTexture();
            }
            I.depthBuffer && te(I);
          }),
          (this.updateRenderTargetMipmap = function Fe(I) {
            const w = b(I) || a,
              G =
                !0 === I.isWebGLMultipleRenderTargets ? I.texture : [I.texture];
            for (let ue = 0, ce = G.length; ue < ce; ue++) {
              const de = G[ue];
              if (E(de, w)) {
                const Ne = I.isWebGLCubeRenderTarget
                    ? n.TEXTURE_CUBE_MAP
                    : n.TEXTURE_2D,
                  pe = i.get(de).__webglTexture;
                t.bindTexture(Ne, pe), x(Ne), t.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function xe(I) {
            if (a && I.samples > 0 && !1 === et(I)) {
              const w = I.isWebGLMultipleRenderTargets
                  ? I.texture
                  : [I.texture],
                G = I.width,
                ue = I.height;
              let ce = n.COLOR_BUFFER_BIT;
              const de = [],
                Ne = I.stencilBuffer
                  ? n.DEPTH_STENCIL_ATTACHMENT
                  : n.DEPTH_ATTACHMENT,
                pe = i.get(I),
                j = !0 === I.isWebGLMultipleRenderTargets;
              if (j)
                for (let He = 0; He < w.length; He++)
                  t.bindFramebuffer(
                    n.FRAMEBUFFER,
                    pe.__webglMultisampledFramebuffer,
                  ),
                    n.framebufferRenderbuffer(
                      n.FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + He,
                      n.RENDERBUFFER,
                      null,
                    ),
                    t.bindFramebuffer(n.FRAMEBUFFER, pe.__webglFramebuffer),
                    n.framebufferTexture2D(
                      n.DRAW_FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + He,
                      n.TEXTURE_2D,
                      null,
                      0,
                    );
              t.bindFramebuffer(
                n.READ_FRAMEBUFFER,
                pe.__webglMultisampledFramebuffer,
              ),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, pe.__webglFramebuffer);
              for (let He = 0; He < w.length; He++) {
                de.push(n.COLOR_ATTACHMENT0 + He), I.depthBuffer && de.push(Ne);
                const ke =
                  void 0 !== pe.__ignoreDepthValues && pe.__ignoreDepthValues;
                if (
                  (!1 === ke &&
                    (I.depthBuffer && (ce |= n.DEPTH_BUFFER_BIT),
                    I.stencilBuffer && (ce |= n.STENCIL_BUFFER_BIT)),
                  j &&
                    n.framebufferRenderbuffer(
                      n.READ_FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0,
                      n.RENDERBUFFER,
                      pe.__webglColorRenderbuffer[He],
                    ),
                  !0 === ke &&
                    (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [Ne]),
                    n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Ne])),
                  j)
                ) {
                  const Ve = i.get(w[He]).__webglTexture;
                  n.framebufferTexture2D(
                    n.DRAW_FRAMEBUFFER,
                    n.COLOR_ATTACHMENT0,
                    n.TEXTURE_2D,
                    Ve,
                    0,
                  );
                }
                n.blitFramebuffer(0, 0, G, ue, 0, 0, G, ue, ce, n.NEAREST),
                  f && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, de);
              }
              if (
                (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                j)
              )
                for (let He = 0; He < w.length; He++) {
                  t.bindFramebuffer(
                    n.FRAMEBUFFER,
                    pe.__webglMultisampledFramebuffer,
                  ),
                    n.framebufferRenderbuffer(
                      n.FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + He,
                      n.RENDERBUFFER,
                      pe.__webglColorRenderbuffer[He],
                    );
                  const ke = i.get(w[He]).__webglTexture;
                  t.bindFramebuffer(n.FRAMEBUFFER, pe.__webglFramebuffer),
                    n.framebufferTexture2D(
                      n.DRAW_FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + He,
                      n.TEXTURE_2D,
                      ke,
                      0,
                    );
                }
              t.bindFramebuffer(
                n.DRAW_FRAMEBUFFER,
                pe.__webglMultisampledFramebuffer,
              );
            }
          }),
          (this.setupDepthRenderbuffer = te),
          (this.setupFrameBufferTexture = Be),
          (this.useMultisampledRTT = et);
      }
      function nX(n, e, t) {
        const i = t.isWebGL2;
        return {
          convert: function r(s, o = "") {
            let a;
            if (s === Vs) return n.UNSIGNED_BYTE;
            if (1017 === s) return n.UNSIGNED_SHORT_4_4_4_4;
            if (1018 === s) return n.UNSIGNED_SHORT_5_5_5_1;
            if (1010 === s) return n.BYTE;
            if (1011 === s) return n.SHORT;
            if (1012 === s) return n.UNSIGNED_SHORT;
            if (1013 === s) return n.INT;
            if (s === Hs) return n.UNSIGNED_INT;
            if (s === as) return n.FLOAT;
            if (s === Cu)
              return i
                ? n.HALF_FLOAT
                : ((a = e.get("OES_texture_half_float")),
                  null !== a ? a.HALF_FLOAT_OES : null);
            if (1021 === s) return n.ALPHA;
            if (s === Ki) return n.RGBA;
            if (1024 === s) return n.LUMINANCE;
            if (1025 === s) return n.LUMINANCE_ALPHA;
            if (s === Oo) return n.DEPTH_COMPONENT;
            if (s === ml) return n.DEPTH_STENCIL;
            if (1035 === s)
              return (
                (a = e.get("EXT_sRGB")), null !== a ? a.SRGB_ALPHA_EXT : null
              );
            if (1028 === s) return n.RED;
            if (1029 === s) return n.RED_INTEGER;
            if (1030 === s) return n.RG;
            if (1031 === s) return n.RG_INTEGER;
            if (1033 === s) return n.RGBA_INTEGER;
            if (33776 === s || 33777 === s || 33778 === s || 33779 === s)
              if (o === rt) {
                if (
                  ((a = e.get("WEBGL_compressed_texture_s3tc_srgb")),
                  null === a)
                )
                  return null;
                if (33776 === s) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (33777 === s) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (33778 === s) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (33779 === s) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (((a = e.get("WEBGL_compressed_texture_s3tc")), null === a))
                  return null;
                if (33776 === s) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (33777 === s) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (33778 === s) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (33779 === s) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            if (35840 === s || 35841 === s || 35842 === s || 35843 === s) {
              if (((a = e.get("WEBGL_compressed_texture_pvrtc")), null === a))
                return null;
              if (35840 === s) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (35841 === s) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (35842 === s) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (35843 === s) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (36196 === s)
              return (
                (a = e.get("WEBGL_compressed_texture_etc1")),
                null !== a ? a.COMPRESSED_RGB_ETC1_WEBGL : null
              );
            if (37492 === s || 37496 === s) {
              if (((a = e.get("WEBGL_compressed_texture_etc")), null === a))
                return null;
              if (37492 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ETC2
                  : a.COMPRESSED_RGB8_ETC2;
              if (37496 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : a.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              37808 === s ||
              37809 === s ||
              37810 === s ||
              37811 === s ||
              37812 === s ||
              37813 === s ||
              37814 === s ||
              37815 === s ||
              37816 === s ||
              37817 === s ||
              37818 === s ||
              37819 === s ||
              37820 === s ||
              37821 === s
            ) {
              if (((a = e.get("WEBGL_compressed_texture_astc")), null === a))
                return null;
              if (37808 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (37809 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (37810 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (37811 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (37812 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (37813 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (37814 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (37815 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (37816 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (37817 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (37818 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (37819 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (37820 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (37821 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (36492 === s) {
              if (((a = e.get("EXT_texture_compression_bptc")), null === a))
                return null;
              if (36492 === s)
                return o === rt
                  ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
            if (36283 === s || 36284 === s || 36285 === s || 36286 === s) {
              if (((a = e.get("EXT_texture_compression_rgtc")), null === a))
                return null;
              if (36492 === s) return a.COMPRESSED_RED_RGTC1_EXT;
              if (36284 === s) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
              if (36285 === s) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
              if (36286 === s) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            }
            return s === Po
              ? i
                ? n.UNSIGNED_INT_24_8
                : ((a = e.get("WEBGL_depth_texture")),
                  null !== a ? a.UNSIGNED_INT_24_8_WEBGL : null)
              : void 0 !== n[s]
              ? n[s]
              : null;
          },
        };
      }
      class iX extends kn {
        constructor(e = []) {
          super(), (this.isArrayCamera = !0), (this.cameras = e);
        }
      }
      class ku extends Ii {
        constructor() {
          super(), (this.isGroup = !0), (this.type = "Group");
        }
      }
      const rX = { type: "move" };
      class u0 {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new ku()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new ku()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new D()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new D())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new ku()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new D()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new D())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(e),
            null !== this._grip && this._grip.dispatchEvent(e),
            null !== this._hand && this._hand.dispatchEvent(e),
            this
          );
        }
        connect(e) {
          if (e && e.hand) {
            const t = this._hand;
            if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
          }
          return this.dispatchEvent({ type: "connected", data: e }), this;
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, i) {
          let r = null,
            s = null,
            o = null;
          const a = this._targetRay,
            l = this._grip,
            c = this._hand;
          if (e && "visible-blurred" !== t.session.visibilityState) {
            if (c && e.hand) {
              o = !0;
              for (const _ of e.hand.values()) {
                const g = t.getJointPose(_, i),
                  m = this._getHandJoint(c, _);
                null !== g &&
                  (m.matrix.fromArray(g.transform.matrix),
                  m.matrix.decompose(m.position, m.rotation, m.scale),
                  (m.matrixWorldNeedsUpdate = !0),
                  (m.jointRadius = g.radius)),
                  (m.visible = null !== g);
              }
              const h = c.joints["index-finger-tip"].position.distanceTo(
                  c.joints["thumb-tip"].position,
                ),
                f = 0.02,
                p = 0.005;
              c.inputState.pinching && h > f + p
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  h <= f - p &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              null !== l &&
                e.gripSpace &&
                ((s = t.getPose(e.gripSpace, i)),
                null !== s &&
                  (l.matrix.fromArray(s.transform.matrix),
                  l.matrix.decompose(l.position, l.rotation, l.scale),
                  (l.matrixWorldNeedsUpdate = !0),
                  s.linearVelocity
                    ? ((l.hasLinearVelocity = !0),
                      l.linearVelocity.copy(s.linearVelocity))
                    : (l.hasLinearVelocity = !1),
                  s.angularVelocity
                    ? ((l.hasAngularVelocity = !0),
                      l.angularVelocity.copy(s.angularVelocity))
                    : (l.hasAngularVelocity = !1)));
            null !== a &&
              ((r = t.getPose(e.targetRaySpace, i)),
              null === r && null !== s && (r = s),
              null !== r &&
                (a.matrix.fromArray(r.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                (a.matrixWorldNeedsUpdate = !0),
                r.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(r.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                r.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(r.angularVelocity))
                  : (a.hasAngularVelocity = !1),
                this.dispatchEvent(rX)));
          }
          return (
            null !== a && (a.visible = null !== r),
            null !== l && (l.visible = null !== s),
            null !== c && (c.visible = null !== o),
            this
          );
        }
        _getHandJoint(e, t) {
          if (void 0 === e.joints[t.jointName]) {
            const i = new ku();
            (i.matrixAutoUpdate = !1),
              (i.visible = !1),
              (e.joints[t.jointName] = i),
              e.add(i);
          }
          return e.joints[t.jointName];
        }
      }
      class sX extends zs {
        constructor(e, t, i, r, s, o, a, l, c, u) {
          if ((u = void 0 !== u ? u : Oo) !== Oo && u !== ml)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
            );
          void 0 === i && u === Oo && (i = Hs),
            void 0 === i && u === ml && (i = Po),
            super(null, r, s, o, a, l, u, i, c),
            (this.isDepthTexture = !0),
            (this.image = { width: e, height: t }),
            (this.magFilter = void 0 !== a ? a : mn),
            (this.minFilter = void 0 !== l ? l : mn),
            (this.flipY = !1),
            (this.generateMipmaps = !1),
            (this.compareFunction = null);
        }
        copy(e) {
          return (
            super.copy(e), (this.compareFunction = e.compareFunction), this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            null !== this.compareFunction &&
              (t.compareFunction = this.compareFunction),
            t
          );
        }
      }
      class oX extends vl {
        constructor(e, t) {
          super();
          const i = this;
          let r = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = 1,
            c = null,
            u = null,
            d = null,
            h = null,
            f = null,
            p = null;
          const _ = t.getContextAttributes();
          let g = null,
            m = null;
          const y = [],
            v = [],
            b = new kn();
          b.layers.enable(1), (b.viewport = new Ut());
          const S = new kn();
          S.layers.enable(2), (S.viewport = new Ut());
          const E = [b, S],
            x = new iX();
          x.layers.enable(1), x.layers.enable(2);
          let P = null,
            M = null;
          function C(U) {
            const K = v.indexOf(U.inputSource);
            if (-1 === K) return;
            const fe = y[K];
            void 0 !== fe &&
              (fe.update(U.inputSource, U.frame, c || o),
              fe.dispatchEvent({ type: U.type, data: U.inputSource }));
          }
          function $() {
            r.removeEventListener("select", C),
              r.removeEventListener("selectstart", C),
              r.removeEventListener("selectend", C),
              r.removeEventListener("squeeze", C),
              r.removeEventListener("squeezestart", C),
              r.removeEventListener("squeezeend", C),
              r.removeEventListener("end", $),
              r.removeEventListener("inputsourceschange", ie);
            for (let U = 0; U < y.length; U++) {
              const K = v[U];
              null !== K && ((v[U] = null), y[U].disconnect(K));
            }
            (P = null),
              (M = null),
              e.setRenderTarget(g),
              (f = null),
              (h = null),
              (d = null),
              (r = null),
              (m = null),
              ee.stop(),
              (i.isPresenting = !1),
              i.dispatchEvent({ type: "sessionend" });
          }
          function ie(U) {
            for (let K = 0; K < U.removed.length; K++) {
              const fe = U.removed[K],
                le = v.indexOf(fe);
              le >= 0 && ((v[le] = null), y[le].disconnect(fe));
            }
            for (let K = 0; K < U.added.length; K++) {
              const fe = U.added[K];
              let le = v.indexOf(fe);
              if (-1 === le) {
                for (let Le = 0; Le < y.length; Le++) {
                  if (Le >= v.length) {
                    v.push(fe), (le = Le);
                    break;
                  }
                  if (null === v[Le]) {
                    (v[Le] = fe), (le = Le);
                    break;
                  }
                }
                if (-1 === le) break;
              }
              const be = y[le];
              be && be.connect(fe);
            }
          }
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (U) {
              let K = y[U];
              return (
                void 0 === K && ((K = new u0()), (y[U] = K)),
                K.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (U) {
              let K = y[U];
              return (
                void 0 === K && ((K = new u0()), (y[U] = K)), K.getGripSpace()
              );
            }),
            (this.getHand = function (U) {
              let K = y[U];
              return (
                void 0 === K && ((K = new u0()), (y[U] = K)), K.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (U) {
              (s = U),
                !0 === i.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
                  );
            }),
            (this.setReferenceSpaceType = function (U) {
              (a = U),
                !0 === i.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting.",
                  );
            }),
            (this.getReferenceSpace = function () {
              return c || o;
            }),
            (this.setReferenceSpace = function (U) {
              c = U;
            }),
            (this.getBaseLayer = function () {
              return null !== h ? h : f;
            }),
            (this.getBinding = function () {
              return d;
            }),
            (this.getFrame = function () {
              return p;
            }),
            (this.getSession = function () {
              return r;
            }),
            (this.setSession = (function () {
              var U = (function Cj(n) {
                return function () {
                  var e = this,
                    t = arguments;
                  return new Promise(function (i, r) {
                    var s = n.apply(e, t);
                    function o(l) {
                      gI(s, i, r, o, a, "next", l);
                    }
                    function a(l) {
                      gI(s, i, r, o, a, "throw", l);
                    }
                    o(void 0);
                  });
                };
              })(function* (K) {
                if (((r = K), null !== r)) {
                  if (
                    ((g = e.getRenderTarget()),
                    r.addEventListener("select", C),
                    r.addEventListener("selectstart", C),
                    r.addEventListener("selectend", C),
                    r.addEventListener("squeeze", C),
                    r.addEventListener("squeezestart", C),
                    r.addEventListener("squeezeend", C),
                    r.addEventListener("end", $),
                    r.addEventListener("inputsourceschange", ie),
                    !0 !== _.xrCompatible && (yield t.makeXRCompatible()),
                    void 0 === r.renderState.layers ||
                      !1 === e.capabilities.isWebGL2)
                  )
                    (f = new XRWebGLLayer(r, t, {
                      antialias: void 0 !== r.renderState.layers || _.antialias,
                      alpha: !0,
                      depth: _.depth,
                      stencil: _.stencil,
                      framebufferScaleFactor: s,
                    })),
                      r.updateRenderState({ baseLayer: f }),
                      (m = new Uo(f.framebufferWidth, f.framebufferHeight, {
                        format: Ki,
                        type: Vs,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: _.stencil,
                      }));
                  else {
                    let fe = null,
                      le = null,
                      be = null;
                    _.depth &&
                      ((be = _.stencil
                        ? t.DEPTH24_STENCIL8
                        : t.DEPTH_COMPONENT24),
                      (fe = _.stencil ? ml : Oo),
                      (le = _.stencil ? Po : Hs));
                    const Le = {
                      colorFormat: t.RGBA8,
                      depthFormat: be,
                      scaleFactor: s,
                    };
                    (d = new XRWebGLBinding(r, t)),
                      (h = d.createProjectionLayer(Le)),
                      r.updateRenderState({ layers: [h] }),
                      (m = new Uo(h.textureWidth, h.textureHeight, {
                        format: Ki,
                        type: Vs,
                        depthTexture: new sX(
                          h.textureWidth,
                          h.textureHeight,
                          le,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          fe,
                        ),
                        stencilBuffer: _.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: _.antialias ? 4 : 0,
                      })),
                      (e.properties.get(m).__ignoreDepthValues =
                        h.ignoreDepthValues);
                  }
                  (m.isXRRenderTarget = !0),
                    this.setFoveation(l),
                    (c = null),
                    (o = yield r.requestReferenceSpace(a)),
                    ee.setContext(r),
                    ee.start(),
                    (i.isPresenting = !0),
                    i.dispatchEvent({ type: "sessionstart" });
                }
              });
              return function (K) {
                return U.apply(this, arguments);
              };
            })()),
            (this.getEnvironmentBlendMode = function () {
              if (null !== r) return r.environmentBlendMode;
            });
          const V = new D(),
            z = new D();
          function F(U, K) {
            null === K
              ? U.matrixWorld.copy(U.matrix)
              : U.matrixWorld.multiplyMatrices(K.matrixWorld, U.matrix),
              U.matrixWorldInverse.copy(U.matrixWorld).invert();
          }
          (this.updateCamera = function (U) {
            if (null === r) return;
            (x.near = S.near = b.near = U.near),
              (x.far = S.far = b.far = U.far),
              (P !== x.near || M !== x.far) &&
                (r.updateRenderState({ depthNear: x.near, depthFar: x.far }),
                (P = x.near),
                (M = x.far));
            const K = U.parent,
              fe = x.cameras;
            F(x, K);
            for (let le = 0; le < fe.length; le++) F(fe[le], K);
            2 === fe.length
              ? (function W(U, K, fe) {
                  V.setFromMatrixPosition(K.matrixWorld),
                    z.setFromMatrixPosition(fe.matrixWorld);
                  const le = V.distanceTo(z),
                    be = K.projectionMatrix.elements,
                    Le = fe.projectionMatrix.elements,
                    Me = be[14] / (be[10] - 1),
                    Re = be[14] / (be[10] + 1),
                    Je = (be[9] + 1) / be[5],
                    Ft = (be[9] - 1) / be[5],
                    Be = (be[8] - 1) / be[0],
                    R = (Le[8] + 1) / Le[0],
                    me = Me * Be,
                    te = Me * R,
                    he = le / (-Be + R),
                    ae = he * -Be;
                  K.matrixWorld.decompose(U.position, U.quaternion, U.scale),
                    U.translateX(ae),
                    U.translateZ(he),
                    U.matrixWorld.compose(U.position, U.quaternion, U.scale),
                    U.matrixWorldInverse.copy(U.matrixWorld).invert();
                  const Fe = Me + he,
                    xe = Re + he;
                  U.projectionMatrix.makePerspective(
                    me - ae,
                    te + (le - ae),
                    ((Je * Re) / xe) * Fe,
                    ((Ft * Re) / xe) * Fe,
                    Fe,
                    xe,
                  ),
                    U.projectionMatrixInverse.copy(U.projectionMatrix).invert();
                })(x, b, S)
              : x.projectionMatrix.copy(b.projectionMatrix),
              (function N(U, K, fe) {
                null === fe
                  ? U.matrix.copy(K.matrixWorld)
                  : (U.matrix.copy(fe.matrixWorld),
                    U.matrix.invert(),
                    U.matrix.multiply(K.matrixWorld)),
                  U.matrix.decompose(U.position, U.quaternion, U.scale),
                  U.updateMatrixWorld(!0);
                const le = U.children;
                for (let be = 0, Le = le.length; be < Le; be++)
                  le[be].updateMatrixWorld(!0);
                U.projectionMatrix.copy(K.projectionMatrix),
                  U.projectionMatrixInverse.copy(K.projectionMatrixInverse),
                  U.isPerspectiveCamera &&
                    ((U.fov =
                      2 * yl * Math.atan(1 / U.projectionMatrix.elements[5])),
                    (U.zoom = 1));
              })(U, x, K);
          }),
            (this.getCamera = function () {
              return x;
            }),
            (this.getFoveation = function () {
              if (null !== h || null !== f) return l;
            }),
            (this.setFoveation = function (U) {
              (l = U),
                null !== h && (h.fixedFoveation = U),
                null !== f &&
                  void 0 !== f.fixedFoveation &&
                  (f.fixedFoveation = U);
            });
          let k = null;
          const ee = new IR();
          ee.setAnimationLoop(function q(U, K) {
            if (((u = K.getViewerPose(c || o)), (p = K), null !== u)) {
              const fe = u.views;
              null !== f &&
                (e.setRenderTargetFramebuffer(m, f.framebuffer),
                e.setRenderTarget(m));
              let le = !1;
              fe.length !== x.cameras.length &&
                ((x.cameras.length = 0), (le = !0));
              for (let be = 0; be < fe.length; be++) {
                const Le = fe[be];
                let Me = null;
                if (null !== f) Me = f.getViewport(Le);
                else {
                  const Je = d.getViewSubImage(h, Le);
                  (Me = Je.viewport),
                    0 === be &&
                      (e.setRenderTargetTextures(
                        m,
                        Je.colorTexture,
                        h.ignoreDepthValues ? void 0 : Je.depthStencilTexture,
                      ),
                      e.setRenderTarget(m));
                }
                let Re = E[be];
                void 0 === Re &&
                  ((Re = new kn()),
                  Re.layers.enable(be),
                  (Re.viewport = new Ut()),
                  (E[be] = Re)),
                  Re.matrix.fromArray(Le.transform.matrix),
                  Re.matrix.decompose(Re.position, Re.quaternion, Re.scale),
                  Re.projectionMatrix.fromArray(Le.projectionMatrix),
                  Re.projectionMatrixInverse.copy(Re.projectionMatrix).invert(),
                  Re.viewport.set(Me.x, Me.y, Me.width, Me.height),
                  0 === be &&
                    (x.matrix.copy(Re.matrix),
                    x.matrix.decompose(x.position, x.quaternion, x.scale)),
                  !0 === le && x.cameras.push(Re);
              }
            }
            for (let fe = 0; fe < y.length; fe++) {
              const le = v[fe],
                be = y[fe];
              null !== le && void 0 !== be && be.update(le, K, c || o);
            }
            k && k(U, K),
              K.detectedPlanes &&
                i.dispatchEvent({ type: "planesdetected", data: K }),
              (p = null);
          }),
            (this.setAnimationLoop = function (U) {
              k = U;
            }),
            (this.dispose = function () {});
        }
      }
      function aX(n, e) {
        function t(g, m) {
          !0 === g.matrixAutoUpdate && g.updateMatrix(), m.value.copy(g.matrix);
        }
        function s(g, m) {
          (g.opacity.value = m.opacity),
            m.color && g.diffuse.value.copy(m.color),
            m.emissive &&
              g.emissive.value
                .copy(m.emissive)
                .multiplyScalar(m.emissiveIntensity),
            m.map && ((g.map.value = m.map), t(m.map, g.mapTransform)),
            m.alphaMap &&
              ((g.alphaMap.value = m.alphaMap),
              t(m.alphaMap, g.alphaMapTransform)),
            m.bumpMap &&
              ((g.bumpMap.value = m.bumpMap),
              t(m.bumpMap, g.bumpMapTransform),
              (g.bumpScale.value = m.bumpScale),
              1 === m.side && (g.bumpScale.value *= -1)),
            m.normalMap &&
              ((g.normalMap.value = m.normalMap),
              t(m.normalMap, g.normalMapTransform),
              g.normalScale.value.copy(m.normalScale),
              1 === m.side && g.normalScale.value.negate()),
            m.displacementMap &&
              ((g.displacementMap.value = m.displacementMap),
              t(m.displacementMap, g.displacementMapTransform),
              (g.displacementScale.value = m.displacementScale),
              (g.displacementBias.value = m.displacementBias)),
            m.emissiveMap &&
              ((g.emissiveMap.value = m.emissiveMap),
              t(m.emissiveMap, g.emissiveMapTransform)),
            m.specularMap &&
              ((g.specularMap.value = m.specularMap),
              t(m.specularMap, g.specularMapTransform)),
            m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
          const y = e.get(m).envMap;
          if (
            (y &&
              ((g.envMap.value = y),
              (g.flipEnvMap.value =
                y.isCubeTexture && !1 === y.isRenderTargetTexture ? -1 : 1),
              (g.reflectivity.value = m.reflectivity),
              (g.ior.value = m.ior),
              (g.refractionRatio.value = m.refractionRatio)),
            m.lightMap)
          ) {
            g.lightMap.value = m.lightMap;
            const v = !0 === n._useLegacyLights ? Math.PI : 1;
            (g.lightMapIntensity.value = m.lightMapIntensity * v),
              t(m.lightMap, g.lightMapTransform);
          }
          m.aoMap &&
            ((g.aoMap.value = m.aoMap),
            (g.aoMapIntensity.value = m.aoMapIntensity),
            t(m.aoMap, g.aoMapTransform));
        }
        return {
          refreshFogUniforms: function i(g, m) {
            m.color.getRGB(g.fogColor.value, AR(n)),
              m.isFog
                ? ((g.fogNear.value = m.near), (g.fogFar.value = m.far))
                : m.isFogExp2 && (g.fogDensity.value = m.density);
          },
          refreshMaterialUniforms: function r(g, m, y, v, b) {
            m.isMeshBasicMaterial || m.isMeshLambertMaterial
              ? s(g, m)
              : m.isMeshToonMaterial
              ? (s(g, m),
                (function d(g, m) {
                  m.gradientMap && (g.gradientMap.value = m.gradientMap);
                })(g, m))
              : m.isMeshPhongMaterial
              ? (s(g, m),
                (function u(g, m) {
                  g.specular.value.copy(m.specular),
                    (g.shininess.value = Math.max(m.shininess, 1e-4));
                })(g, m))
              : m.isMeshStandardMaterial
              ? (s(g, m),
                (function h(g, m) {
                  (g.metalness.value = m.metalness),
                    m.metalnessMap &&
                      ((g.metalnessMap.value = m.metalnessMap),
                      t(m.metalnessMap, g.metalnessMapTransform)),
                    (g.roughness.value = m.roughness),
                    m.roughnessMap &&
                      ((g.roughnessMap.value = m.roughnessMap),
                      t(m.roughnessMap, g.roughnessMapTransform)),
                    e.get(m).envMap &&
                      (g.envMapIntensity.value = m.envMapIntensity);
                })(g, m),
                m.isMeshPhysicalMaterial &&
                  (function f(g, m, y) {
                    (g.ior.value = m.ior),
                      m.sheen > 0 &&
                        (g.sheenColor.value
                          .copy(m.sheenColor)
                          .multiplyScalar(m.sheen),
                        (g.sheenRoughness.value = m.sheenRoughness),
                        m.sheenColorMap &&
                          ((g.sheenColorMap.value = m.sheenColorMap),
                          t(m.sheenColorMap, g.sheenColorMapTransform)),
                        m.sheenRoughnessMap &&
                          ((g.sheenRoughnessMap.value = m.sheenRoughnessMap),
                          t(
                            m.sheenRoughnessMap,
                            g.sheenRoughnessMapTransform,
                          ))),
                      m.clearcoat > 0 &&
                        ((g.clearcoat.value = m.clearcoat),
                        (g.clearcoatRoughness.value = m.clearcoatRoughness),
                        m.clearcoatMap &&
                          ((g.clearcoatMap.value = m.clearcoatMap),
                          t(m.clearcoatMap, g.clearcoatMapTransform)),
                        m.clearcoatRoughnessMap &&
                          ((g.clearcoatRoughnessMap.value =
                            m.clearcoatRoughnessMap),
                          t(
                            m.clearcoatRoughnessMap,
                            g.clearcoatRoughnessMapTransform,
                          )),
                        m.clearcoatNormalMap &&
                          ((g.clearcoatNormalMap.value = m.clearcoatNormalMap),
                          t(
                            m.clearcoatNormalMap,
                            g.clearcoatNormalMapTransform,
                          ),
                          g.clearcoatNormalScale.value.copy(
                            m.clearcoatNormalScale,
                          ),
                          1 === m.side &&
                            g.clearcoatNormalScale.value.negate())),
                      m.iridescence > 0 &&
                        ((g.iridescence.value = m.iridescence),
                        (g.iridescenceIOR.value = m.iridescenceIOR),
                        (g.iridescenceThicknessMinimum.value =
                          m.iridescenceThicknessRange[0]),
                        (g.iridescenceThicknessMaximum.value =
                          m.iridescenceThicknessRange[1]),
                        m.iridescenceMap &&
                          ((g.iridescenceMap.value = m.iridescenceMap),
                          t(m.iridescenceMap, g.iridescenceMapTransform)),
                        m.iridescenceThicknessMap &&
                          ((g.iridescenceThicknessMap.value =
                            m.iridescenceThicknessMap),
                          t(
                            m.iridescenceThicknessMap,
                            g.iridescenceThicknessMapTransform,
                          ))),
                      m.transmission > 0 &&
                        ((g.transmission.value = m.transmission),
                        (g.transmissionSamplerMap.value = y.texture),
                        g.transmissionSamplerSize.value.set(y.width, y.height),
                        m.transmissionMap &&
                          ((g.transmissionMap.value = m.transmissionMap),
                          t(m.transmissionMap, g.transmissionMapTransform)),
                        (g.thickness.value = m.thickness),
                        m.thicknessMap &&
                          ((g.thicknessMap.value = m.thicknessMap),
                          t(m.thicknessMap, g.thicknessMapTransform)),
                        (g.attenuationDistance.value = m.attenuationDistance),
                        g.attenuationColor.value.copy(m.attenuationColor)),
                      m.anisotropy > 0 &&
                        (g.anisotropyVector.value.set(
                          m.anisotropy * Math.cos(m.anisotropyRotation),
                          m.anisotropy * Math.sin(m.anisotropyRotation),
                        ),
                        m.anisotropyMap &&
                          ((g.anisotropyMap.value = m.anisotropyMap),
                          t(m.anisotropyMap, g.anisotropyMapTransform))),
                      (g.specularIntensity.value = m.specularIntensity),
                      g.specularColor.value.copy(m.specularColor),
                      m.specularColorMap &&
                        ((g.specularColorMap.value = m.specularColorMap),
                        t(m.specularColorMap, g.specularColorMapTransform)),
                      m.specularIntensityMap &&
                        ((g.specularIntensityMap.value =
                          m.specularIntensityMap),
                        t(
                          m.specularIntensityMap,
                          g.specularIntensityMapTransform,
                        ));
                  })(g, m, b))
              : m.isMeshMatcapMaterial
              ? (s(g, m),
                (function p(g, m) {
                  m.matcap && (g.matcap.value = m.matcap);
                })(g, m))
              : m.isMeshDepthMaterial
              ? s(g, m)
              : m.isMeshDistanceMaterial
              ? (s(g, m),
                (function _(g, m) {
                  const y = e.get(m).light;
                  g.referencePosition.value.setFromMatrixPosition(
                    y.matrixWorld,
                  ),
                    (g.nearDistance.value = y.shadow.camera.near),
                    (g.farDistance.value = y.shadow.camera.far);
                })(g, m))
              : m.isMeshNormalMaterial
              ? s(g, m)
              : m.isLineBasicMaterial
              ? ((function o(g, m) {
                  g.diffuse.value.copy(m.color),
                    (g.opacity.value = m.opacity),
                    m.map && ((g.map.value = m.map), t(m.map, g.mapTransform));
                })(g, m),
                m.isLineDashedMaterial &&
                  (function a(g, m) {
                    (g.dashSize.value = m.dashSize),
                      (g.totalSize.value = m.dashSize + m.gapSize),
                      (g.scale.value = m.scale);
                  })(g, m))
              : m.isPointsMaterial
              ? (function l(g, m, y, v) {
                  g.diffuse.value.copy(m.color),
                    (g.opacity.value = m.opacity),
                    (g.size.value = m.size * y),
                    (g.scale.value = 0.5 * v),
                    m.map && ((g.map.value = m.map), t(m.map, g.uvTransform)),
                    m.alphaMap &&
                      ((g.alphaMap.value = m.alphaMap),
                      t(m.alphaMap, g.alphaMapTransform)),
                    m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
                })(g, m, y, v)
              : m.isSpriteMaterial
              ? (function c(g, m) {
                  g.diffuse.value.copy(m.color),
                    (g.opacity.value = m.opacity),
                    (g.rotation.value = m.rotation),
                    m.map && ((g.map.value = m.map), t(m.map, g.mapTransform)),
                    m.alphaMap &&
                      ((g.alphaMap.value = m.alphaMap),
                      t(m.alphaMap, g.alphaMapTransform)),
                    m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
                })(g, m)
              : m.isShadowMaterial
              ? (g.color.value.copy(m.color), (g.opacity.value = m.opacity))
              : m.isShaderMaterial && (m.uniformsNeedUpdate = !1);
          },
        };
      }
      function lX(n, e, t, i) {
        let r = {},
          s = {},
          o = [];
        const a = t.isWebGL2
          ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS)
          : 0;
        function f(y, v, b) {
          const S = y.value;
          if (void 0 === b[v]) {
            if ("number" == typeof S) b[v] = S;
            else {
              const E = Array.isArray(S) ? S : [S],
                x = [];
              for (let P = 0; P < E.length; P++) x.push(E[P].clone());
              b[v] = x;
            }
            return !0;
          }
          if ("number" == typeof S) {
            if (b[v] !== S) return (b[v] = S), !0;
          } else {
            const E = Array.isArray(b[v]) ? b[v] : [b[v]],
              x = Array.isArray(S) ? S : [S];
            for (let P = 0; P < E.length; P++) {
              const M = E[P];
              if (!1 === M.equals(x[P])) return M.copy(x[P]), !0;
            }
          }
          return !1;
        }
        function _(y) {
          const v = { boundary: 0, storage: 0 };
          return (
            "number" == typeof y
              ? ((v.boundary = 4), (v.storage = 4))
              : y.isVector2
              ? ((v.boundary = 8), (v.storage = 8))
              : y.isVector3 || y.isColor
              ? ((v.boundary = 16), (v.storage = 12))
              : y.isVector4
              ? ((v.boundary = 16), (v.storage = 16))
              : y.isMatrix3
              ? ((v.boundary = 48), (v.storage = 48))
              : y.isMatrix4
              ? ((v.boundary = 64), (v.storage = 64))
              : y.isTexture
              ? console.warn(
                  "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
                )
              : console.warn(
                  "THREE.WebGLRenderer: Unsupported uniform value type.",
                  y,
                ),
            v
          );
        }
        function g(y) {
          const v = y.target;
          v.removeEventListener("dispose", g);
          const b = o.indexOf(v.__bindingPointIndex);
          o.splice(b, 1),
            n.deleteBuffer(r[v.id]),
            delete r[v.id],
            delete s[v.id];
        }
        return {
          bind: function l(y, v) {
            i.uniformBlockBinding(y, v.program);
          },
          update: function c(y, v) {
            let b = r[y.id];
            void 0 === b &&
              ((function p(y) {
                const v = y.uniforms;
                let b = 0;
                let E = 0;
                for (let x = 0, P = v.length; x < P; x++) {
                  const M = v[x],
                    C = { boundary: 0, storage: 0 },
                    $ = Array.isArray(M.value) ? M.value : [M.value];
                  for (let ie = 0, V = $.length; ie < V; ie++) {
                    const W = _($[ie]);
                    (C.boundary += W.boundary), (C.storage += W.storage);
                  }
                  (M.__data = new Float32Array(
                    C.storage / Float32Array.BYTES_PER_ELEMENT,
                  )),
                    (M.__offset = b),
                    x > 0 &&
                      ((E = b % 16),
                      0 !== E &&
                        16 - E - C.boundary < 0 &&
                        ((b += 16 - E), (M.__offset = b))),
                    (b += C.storage);
                }
                (E = b % 16),
                  E > 0 && (b += 16 - E),
                  (y.__size = b),
                  (y.__cache = {});
              })(y),
              (b = (function u(y) {
                const v = (function d() {
                  for (let y = 0; y < a; y++)
                    if (-1 === o.indexOf(y)) return o.push(y), y;
                  return (
                    console.error(
                      "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
                    ),
                    0
                  );
                })();
                y.__bindingPointIndex = v;
                const b = n.createBuffer(),
                  S = y.__size,
                  E = y.usage;
                return (
                  n.bindBuffer(n.UNIFORM_BUFFER, b),
                  n.bufferData(n.UNIFORM_BUFFER, S, E),
                  n.bindBuffer(n.UNIFORM_BUFFER, null),
                  n.bindBufferBase(n.UNIFORM_BUFFER, v, b),
                  b
                );
              })(y)),
              (r[y.id] = b),
              y.addEventListener("dispose", g)),
              i.updateUBOMapping(y, v.program);
            const E = e.render.frame;
            s[y.id] !== E &&
              ((function h(y) {
                const b = y.uniforms,
                  S = y.__cache;
                n.bindBuffer(n.UNIFORM_BUFFER, r[y.id]);
                for (let E = 0, x = b.length; E < x; E++) {
                  const P = b[E];
                  if (!0 === f(P, E, S)) {
                    const M = P.__offset,
                      C = Array.isArray(P.value) ? P.value : [P.value];
                    let $ = 0;
                    for (let ie = 0; ie < C.length; ie++) {
                      const V = C[ie],
                        z = _(V);
                      "number" == typeof V
                        ? ((P.__data[0] = V),
                          n.bufferSubData(n.UNIFORM_BUFFER, M + $, P.__data))
                        : V.isMatrix3
                        ? ((P.__data[0] = V.elements[0]),
                          (P.__data[1] = V.elements[1]),
                          (P.__data[2] = V.elements[2]),
                          (P.__data[3] = V.elements[0]),
                          (P.__data[4] = V.elements[3]),
                          (P.__data[5] = V.elements[4]),
                          (P.__data[6] = V.elements[5]),
                          (P.__data[7] = V.elements[0]),
                          (P.__data[8] = V.elements[6]),
                          (P.__data[9] = V.elements[7]),
                          (P.__data[10] = V.elements[8]),
                          (P.__data[11] = V.elements[0]))
                        : (V.toArray(P.__data, $),
                          ($ += z.storage / Float32Array.BYTES_PER_ELEMENT));
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, M, P.__data);
                  }
                }
                n.bindBuffer(n.UNIFORM_BUFFER, null);
              })(y),
              (s[y.id] = E));
          },
          dispose: function m() {
            for (const y in r) n.deleteBuffer(r[y]);
            (o = []), (r = {}), (s = {});
          },
        };
      }
      function cX() {
        const n = Tu("canvas");
        return (n.style.display = "block"), n;
      }
      class sP {
        constructor(e = {}) {
          const {
            canvas: t = cX(),
            context: i = null,
            depth: r = !0,
            stencil: s = !0,
            alpha: o = !1,
            antialias: a = !1,
            premultipliedAlpha: l = !0,
            preserveDrawingBuffer: c = !1,
            powerPreference: u = "default",
            failIfMajorPerformanceCaveat: d = !1,
          } = e;
          let h;
          (this.isWebGLRenderer = !0),
            (h = null !== i ? i.getContextAttributes().alpha : o);
          const f = new Uint32Array(4),
            p = new Int32Array(4);
          let _ = null,
            g = null;
          const m = [],
            y = [];
          (this.domElement = t),
            (this.debug = { checkShaderErrors: !0, onShaderError: null }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this.outputColorSpace = rt),
            (this._useLegacyLights = !1),
            (this.toneMapping = Us),
            (this.toneMappingExposure = 1);
          const v = this;
          let b = !1,
            S = 0,
            E = 0,
            x = null,
            P = -1,
            M = null;
          const C = new Ut(),
            $ = new Ut();
          let ie = null;
          const V = new Ce(0);
          let z = 0,
            W = t.width,
            F = t.height,
            N = 1,
            k = null,
            q = null;
          const ee = new Ut(0, 0, W, F),
            U = new Ut(0, 0, W, F);
          let K = !1;
          const fe = new n0();
          let le = !1,
            be = !1,
            Le = null;
          const Me = new it(),
            Re = new oe(),
            Je = new D(),
            Ft = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          function Be() {
            return null === x ? N : 1;
          }
          let te,
            he,
            ae,
            Fe,
            xe,
            Ae,
            et,
            _t,
            sn,
            I,
            w,
            G,
            ue,
            ce,
            de,
            Ne,
            pe,
            j,
            He,
            ke,
            Ve,
            Pe,
            Oe,
            ft,
            R = i;
          function me(T, H) {
            for (let J = 0; J < T.length; J++) {
              const Q = t.getContext(T[J], H);
              if (null !== Q) return Q;
            }
            return null;
          }
          try {
            const T = {
              alpha: !0,
              depth: r,
              stencil: s,
              antialias: a,
              premultipliedAlpha: l,
              preserveDrawingBuffer: c,
              powerPreference: u,
              failIfMajorPerformanceCaveat: d,
            };
            if (
              ("setAttribute" in t &&
                t.setAttribute("data-engine", "three.js r155"),
              t.addEventListener("webglcontextlost", ye, !1),
              t.addEventListener("webglcontextrestored", X, !1),
              t.addEventListener("webglcontextcreationerror", ge, !1),
              null === R)
            ) {
              const H = ["webgl2", "webgl", "experimental-webgl"];
              if (
                (!0 === v.isWebGL1Renderer && H.shift(),
                (R = me(H, T)),
                null === R)
              )
                throw me(H)
                  ? new Error(
                      "Error creating WebGL context with your selected attributes.",
                    )
                  : new Error("Error creating WebGL context.");
            }
            typeof WebGLRenderingContext < "u" &&
              R instanceof WebGLRenderingContext &&
              console.warn(
                "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.",
              ),
              void 0 === R.getShaderPrecisionFormat &&
                (R.getShaderPrecisionFormat = function () {
                  return { rangeMin: 1, rangeMax: 1, precision: 1 };
                });
          } catch (T) {
            throw (console.error("THREE.WebGLRenderer: " + T.message), T);
          }
          function $t() {
            (te = new M7(R)),
              (he = new m7(R, te, e)),
              te.init(he),
              (Pe = new nX(R, te, he)),
              (ae = new eX(R, te, he)),
              (Fe = new E7(R)),
              (xe = new z9()),
              (Ae = new tX(R, te, ae, xe, he, Pe, Fe)),
              (et = new _7(v)),
              (_t = new b7(v)),
              (sn = new p6(R, he)),
              (Oe = new f7(R, te, sn, he)),
              (I = new S7(R, sn, Fe, Oe)),
              (w = new D7(R, I, sn, Fe)),
              (He = new T7(R, he, Ae)),
              (Ne = new g7(xe)),
              (G = new H9(v, et, _t, te, he, Oe, Ne)),
              (ue = new aX(v, xe)),
              (ce = new W9()),
              (de = new Z9(te, he)),
              (j = new h7(v, et, _t, ae, w, h, l)),
              (pe = new J9(v, w, he)),
              (ft = new lX(R, Fe, he, ae)),
              (ke = new p7(R, te, Fe, he)),
              (Ve = new w7(R, te, Fe, he)),
              (Fe.programs = G.programs),
              (v.capabilities = he),
              (v.extensions = te),
              (v.properties = xe),
              (v.renderLists = ce),
              (v.shadowMap = pe),
              (v.state = ae),
              (v.info = Fe);
          }
          $t();
          const O = new oX(v, R);
          function ye(T) {
            T.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              (b = !0);
          }
          function X() {
            console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
            const T = Fe.autoReset,
              H = pe.enabled,
              J = pe.autoUpdate,
              B = pe.needsUpdate,
              Q = pe.type;
            $t(),
              (Fe.autoReset = T),
              (pe.enabled = H),
              (pe.autoUpdate = J),
              (pe.needsUpdate = B),
              (pe.type = Q);
          }
          function ge(T) {
            console.error(
              "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
              T.statusMessage,
            );
          }
          function Se(T) {
            const H = T.target;
            H.removeEventListener("dispose", Se),
              (function St(T) {
                (function Jt(T) {
                  const H = xe.get(T).programs;
                  void 0 !== H &&
                    (H.forEach(function (J) {
                      G.releaseProgram(J);
                    }),
                    T.isShaderMaterial && G.releaseShaderCache(T));
                })(T),
                  xe.remove(T);
              })(H);
          }
          (this.xr = O),
            (this.getContext = function () {
              return R;
            }),
            (this.getContextAttributes = function () {
              return R.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const T = te.get("WEBGL_lose_context");
              T && T.loseContext();
            }),
            (this.forceContextRestore = function () {
              const T = te.get("WEBGL_lose_context");
              T && T.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return N;
            }),
            (this.setPixelRatio = function (T) {
              void 0 !== T && ((N = T), this.setSize(W, F, !1));
            }),
            (this.getSize = function (T) {
              return T.set(W, F);
            }),
            (this.setSize = function (T, H, J = !0) {
              O.isPresenting
                ? console.warn(
                    "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
                  )
                : ((W = T),
                  (F = H),
                  (t.width = Math.floor(T * N)),
                  (t.height = Math.floor(H * N)),
                  !0 === J &&
                    ((t.style.width = T + "px"), (t.style.height = H + "px")),
                  this.setViewport(0, 0, T, H));
            }),
            (this.getDrawingBufferSize = function (T) {
              return T.set(W * N, F * N).floor();
            }),
            (this.setDrawingBufferSize = function (T, H, J) {
              (W = T),
                (F = H),
                (N = J),
                (t.width = Math.floor(T * J)),
                (t.height = Math.floor(H * J)),
                this.setViewport(0, 0, T, H);
            }),
            (this.getCurrentViewport = function (T) {
              return T.copy(C);
            }),
            (this.getViewport = function (T) {
              return T.copy(ee);
            }),
            (this.setViewport = function (T, H, J, B) {
              T.isVector4 ? ee.set(T.x, T.y, T.z, T.w) : ee.set(T, H, J, B),
                ae.viewport(C.copy(ee).multiplyScalar(N).floor());
            }),
            (this.getScissor = function (T) {
              return T.copy(U);
            }),
            (this.setScissor = function (T, H, J, B) {
              T.isVector4 ? U.set(T.x, T.y, T.z, T.w) : U.set(T, H, J, B),
                ae.scissor($.copy(U).multiplyScalar(N).floor());
            }),
            (this.getScissorTest = function () {
              return K;
            }),
            (this.setScissorTest = function (T) {
              ae.setScissorTest((K = T));
            }),
            (this.setOpaqueSort = function (T) {
              k = T;
            }),
            (this.setTransparentSort = function (T) {
              q = T;
            }),
            (this.getClearColor = function (T) {
              return T.copy(j.getClearColor());
            }),
            (this.setClearColor = function () {
              j.setClearColor.apply(j, arguments);
            }),
            (this.getClearAlpha = function () {
              return j.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              j.setClearAlpha.apply(j, arguments);
            }),
            (this.clear = function (T = !0, H = !0, J = !0) {
              let B = 0;
              if (T) {
                let Q = !1;
                if (null !== x) {
                  const De = x.texture.format;
                  Q = 1033 === De || 1031 === De || 1029 === De;
                }
                if (Q) {
                  const De = x.texture.type,
                    ze =
                      De === Vs ||
                      De === Hs ||
                      1012 === De ||
                      De === Po ||
                      1017 === De ||
                      1018 === De,
                    Xe = j.getClearColor(),
                    Ye = j.getClearAlpha(),
                    pt = Xe.r,
                    je = Xe.g,
                    lt = Xe.b;
                  ze
                    ? ((f[0] = pt),
                      (f[1] = je),
                      (f[2] = lt),
                      (f[3] = Ye),
                      R.clearBufferuiv(R.COLOR, 0, f))
                    : ((p[0] = pt),
                      (p[1] = je),
                      (p[2] = lt),
                      (p[3] = Ye),
                      R.clearBufferiv(R.COLOR, 0, p));
                } else B |= R.COLOR_BUFFER_BIT;
              }
              H && (B |= R.DEPTH_BUFFER_BIT),
                J && (B |= R.STENCIL_BUFFER_BIT),
                R.clear(B);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              t.removeEventListener("webglcontextlost", ye, !1),
                t.removeEventListener("webglcontextrestored", X, !1),
                t.removeEventListener("webglcontextcreationerror", ge, !1),
                ce.dispose(),
                de.dispose(),
                xe.dispose(),
                et.dispose(),
                _t.dispose(),
                w.dispose(),
                Oe.dispose(),
                ft.dispose(),
                G.dispose(),
                O.dispose(),
                O.removeEventListener("sessionstart", Xt),
                O.removeEventListener("sessionend", Vr),
                Le && (Le.dispose(), (Le = null)),
                si.stop();
            }),
            (this.renderBufferDirect = function (T, H, J, B, Q, De) {
              null === H && (H = Ft);
              const ze = Q.isMesh && Q.matrixWorld.determinant() < 0,
                Xe = (function fte(T, H, J, B, Q) {
                  !0 !== H.isScene && (H = Ft), Ae.resetTextureUnits();
                  const De = H.fog,
                    Xe =
                      null === x
                        ? v.outputColorSpace
                        : !0 === x.isXRRenderTarget
                        ? x.texture.colorSpace
                        : Nr,
                    Ye = (B.isMeshStandardMaterial ? _t : et).get(
                      B.envMap ||
                        (B.isMeshStandardMaterial ? H.environment : null),
                    ),
                    pt =
                      !0 === B.vertexColors &&
                      !!J.attributes.color &&
                      4 === J.attributes.color.itemSize,
                    je =
                      !!J.attributes.tangent &&
                      (!!B.normalMap || B.anisotropy > 0),
                    lt = !!J.morphAttributes.position,
                    on = !!J.morphAttributes.normal,
                    hn = !!J.morphAttributes.color;
                  let tr = Us;
                  B.toneMapped &&
                    (null === x || !0 === x.isXRRenderTarget) &&
                    (tr = v.toneMapping);
                  const Ms =
                      J.morphAttributes.position ||
                      J.morphAttributes.normal ||
                      J.morphAttributes.color,
                    bn = void 0 !== Ms ? Ms.length : 0,
                    mt = xe.get(B),
                    nM = g.state.lights;
                  !0 !== le ||
                    (!0 !== be && T === M) ||
                    Ne.setState(B, T, T === M && B.id === P);
                  let Mn = !1;
                  B.version === mt.__version
                    ? ((mt.needsLights &&
                        mt.lightsStateVersion !== nM.state.version) ||
                        mt.outputColorSpace !== Xe ||
                        (Q.isInstancedMesh && !1 === mt.instancing) ||
                        (!Q.isInstancedMesh && !0 === mt.instancing) ||
                        (Q.isSkinnedMesh && !1 === mt.skinning) ||
                        (!Q.isSkinnedMesh && !0 === mt.skinning) ||
                        (Q.isInstancedMesh &&
                          !0 === mt.instancingColor &&
                          null === Q.instanceColor) ||
                        (Q.isInstancedMesh &&
                          !1 === mt.instancingColor &&
                          null !== Q.instanceColor) ||
                        mt.envMap !== Ye ||
                        (!0 === B.fog && mt.fog !== De) ||
                        (void 0 !== mt.numClippingPlanes &&
                          (mt.numClippingPlanes !== Ne.numPlanes ||
                            mt.numIntersection !== Ne.numIntersection)) ||
                        mt.vertexAlphas !== pt ||
                        mt.vertexTangents !== je ||
                        mt.morphTargets !== lt ||
                        mt.morphNormals !== on ||
                        mt.morphColors !== hn ||
                        mt.toneMapping !== tr ||
                        (!0 === he.isWebGL2 && mt.morphTargetsCount !== bn)) &&
                      (Mn = !0)
                    : ((Mn = !0), (mt.__version = B.version));
                  let la = mt.currentProgram;
                  !0 === Mn && (la = _m(B, H, Q));
                  let QN = !1,
                    fd = !1,
                    iM = !1;
                  const oi = la.getUniforms(),
                    ca = mt.uniforms;
                  if (
                    (ae.useProgram(la.program) &&
                      ((QN = !0), (fd = !0), (iM = !0)),
                    B.id !== P && ((P = B.id), (fd = !0)),
                    QN || M !== T)
                  ) {
                    if (
                      (oi.setValue(R, "projectionMatrix", T.projectionMatrix),
                      he.logarithmicDepthBuffer &&
                        oi.setValue(
                          R,
                          "logDepthBufFC",
                          2 / (Math.log(T.far + 1) / Math.LN2),
                        ),
                      M !== T && ((M = T), (fd = !0), (iM = !0)),
                      B.isShaderMaterial ||
                        B.isMeshPhongMaterial ||
                        B.isMeshToonMaterial ||
                        B.isMeshStandardMaterial ||
                        B.envMap)
                    ) {
                      const ki = oi.map.cameraPosition;
                      void 0 !== ki &&
                        ki.setValue(R, Je.setFromMatrixPosition(T.matrixWorld));
                    }
                    (B.isMeshPhongMaterial ||
                      B.isMeshToonMaterial ||
                      B.isMeshLambertMaterial ||
                      B.isMeshBasicMaterial ||
                      B.isMeshStandardMaterial ||
                      B.isShaderMaterial) &&
                      oi.setValue(
                        R,
                        "isOrthographic",
                        !0 === T.isOrthographicCamera,
                      ),
                      (B.isMeshPhongMaterial ||
                        B.isMeshToonMaterial ||
                        B.isMeshLambertMaterial ||
                        B.isMeshBasicMaterial ||
                        B.isMeshStandardMaterial ||
                        B.isShaderMaterial ||
                        B.isShadowMaterial ||
                        Q.isSkinnedMesh) &&
                        oi.setValue(R, "viewMatrix", T.matrixWorldInverse);
                  }
                  if (Q.isSkinnedMesh) {
                    oi.setOptional(R, Q, "bindMatrix"),
                      oi.setOptional(R, Q, "bindMatrixInverse");
                    const ki = Q.skeleton;
                    ki &&
                      (he.floatVertexTextures
                        ? (null === ki.boneTexture && ki.computeBoneTexture(),
                          oi.setValue(R, "boneTexture", ki.boneTexture, Ae),
                          oi.setValue(R, "boneTextureSize", ki.boneTextureSize))
                        : console.warn(
                            "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.",
                          ));
                  }
                  const rM = J.morphAttributes;
                  if (
                    ((void 0 !== rM.position ||
                      void 0 !== rM.normal ||
                      (void 0 !== rM.color && !0 === he.isWebGL2)) &&
                      He.update(Q, J, la),
                    (fd || mt.receiveShadow !== Q.receiveShadow) &&
                      ((mt.receiveShadow = Q.receiveShadow),
                      oi.setValue(R, "receiveShadow", Q.receiveShadow)),
                    B.isMeshGouraudMaterial &&
                      null !== B.envMap &&
                      ((ca.envMap.value = Ye),
                      (ca.flipEnvMap.value =
                        Ye.isCubeTexture && !1 === Ye.isRenderTargetTexture
                          ? -1
                          : 1)),
                    fd &&
                      (oi.setValue(
                        R,
                        "toneMappingExposure",
                        v.toneMappingExposure,
                      ),
                      mt.needsLights &&
                        (function pte(T, H) {
                          (T.ambientLightColor.needsUpdate = H),
                            (T.lightProbe.needsUpdate = H),
                            (T.directionalLights.needsUpdate = H),
                            (T.directionalLightShadows.needsUpdate = H),
                            (T.pointLights.needsUpdate = H),
                            (T.pointLightShadows.needsUpdate = H),
                            (T.spotLights.needsUpdate = H),
                            (T.spotLightShadows.needsUpdate = H),
                            (T.rectAreaLights.needsUpdate = H),
                            (T.hemisphereLights.needsUpdate = H);
                        })(ca, iM),
                      De && !0 === B.fog && ue.refreshFogUniforms(ca, De),
                      ue.refreshMaterialUniforms(ca, B, N, F, Le),
                      sp.upload(R, mt.uniformsList, ca, Ae)),
                    B.isShaderMaterial &&
                      !0 === B.uniformsNeedUpdate &&
                      (sp.upload(R, mt.uniformsList, ca, Ae),
                      (B.uniformsNeedUpdate = !1)),
                    B.isSpriteMaterial && oi.setValue(R, "center", Q.center),
                    oi.setValue(R, "modelViewMatrix", Q.modelViewMatrix),
                    oi.setValue(R, "normalMatrix", Q.normalMatrix),
                    oi.setValue(R, "modelMatrix", Q.matrixWorld),
                    B.isShaderMaterial || B.isRawShaderMaterial)
                  ) {
                    const ki = B.uniformsGroups;
                    for (let sM = 0, gte = ki.length; sM < gte; sM++)
                      if (he.isWebGL2) {
                        const JN = ki[sM];
                        ft.update(JN, la), ft.bind(JN, la);
                      } else
                        console.warn(
                          "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.",
                        );
                  }
                  return la;
                })(T, H, J, B, Q);
              ae.setMaterial(B, ze);
              let Ye = J.index,
                pt = 1;
              if (!0 === B.wireframe) {
                if (((Ye = I.getWireframeAttribute(J)), void 0 === Ye)) return;
                pt = 2;
              }
              const je = J.drawRange,
                lt = J.attributes.position;
              let on = je.start * pt,
                hn = (je.start + je.count) * pt;
              null !== De &&
                ((on = Math.max(on, De.start * pt)),
                (hn = Math.min(hn, (De.start + De.count) * pt))),
                null !== Ye
                  ? ((on = Math.max(on, 0)), (hn = Math.min(hn, Ye.count)))
                  : null != lt &&
                    ((on = Math.max(on, 0)), (hn = Math.min(hn, lt.count)));
              const tr = hn - on;
              if (tr < 0 || tr === 1 / 0) return;
              Oe.setup(Q, B, Xe, J, Ye);
              let Ms,
                bn = ke;
              if (
                (null !== Ye && ((Ms = sn.get(Ye)), (bn = Ve), bn.setIndex(Ms)),
                Q.isMesh)
              )
                !0 === B.wireframe
                  ? (ae.setLineWidth(B.wireframeLinewidth * Be()),
                    bn.setMode(R.LINES))
                  : bn.setMode(R.TRIANGLES);
              else if (Q.isLine) {
                let mt = B.linewidth;
                void 0 === mt && (mt = 1),
                  ae.setLineWidth(mt * Be()),
                  bn.setMode(
                    Q.isLineSegments
                      ? R.LINES
                      : Q.isLineLoop
                      ? R.LINE_LOOP
                      : R.LINE_STRIP,
                  );
              } else
                Q.isPoints
                  ? bn.setMode(R.POINTS)
                  : Q.isSprite && bn.setMode(R.TRIANGLES);
              if (Q.isInstancedMesh) bn.renderInstances(on, tr, Q.count);
              else if (J.isInstancedBufferGeometry) {
                const nM = Math.min(
                  J.instanceCount,
                  void 0 !== J._maxInstanceCount ? J._maxInstanceCount : 1 / 0,
                );
                bn.renderInstances(on, tr, nM);
              } else bn.render(on, tr);
            }),
            (this.compile = function (T, H) {
              function J(B, Q, De) {
                !0 === B.transparent && 2 === B.side && !1 === B.forceSinglePass
                  ? ((B.side = 1),
                    (B.needsUpdate = !0),
                    _m(B, Q, De),
                    (B.side = 0),
                    (B.needsUpdate = !0),
                    _m(B, Q, De),
                    (B.side = 2))
                  : _m(B, Q, De);
              }
              (g = de.get(T)),
                g.init(),
                y.push(g),
                T.traverseVisible(function (B) {
                  B.isLight &&
                    B.layers.test(H.layers) &&
                    (g.pushLight(B), B.castShadow && g.pushShadow(B));
                }),
                g.setupLights(v._useLegacyLights),
                T.traverse(function (B) {
                  const Q = B.material;
                  if (Q)
                    if (Array.isArray(Q))
                      for (let De = 0; De < Q.length; De++) J(Q[De], T, B);
                    else J(Q, T, B);
                }),
                y.pop(),
                (g = null);
            });
          let yn = null;
          function Xt() {
            si.stop();
          }
          function Vr() {
            si.start();
          }
          const si = new IR();
          function XN(T, H, J, B) {
            if (!1 === T.visible) return;
            if (T.layers.test(H.layers))
              if (T.isGroup) J = T.renderOrder;
              else if (T.isLOD) !0 === T.autoUpdate && T.update(H);
              else if (T.isLight)
                g.pushLight(T), T.castShadow && g.pushShadow(T);
              else if (T.isSprite) {
                if (!T.frustumCulled || fe.intersectsSprite(T)) {
                  B && Je.setFromMatrixPosition(T.matrixWorld).applyMatrix4(Me);
                  const ze = w.update(T),
                    Xe = T.material;
                  Xe.visible && _.push(T, ze, Xe, J, Je.z, null);
                }
              } else if (
                (T.isMesh || T.isLine || T.isPoints) &&
                (!T.frustumCulled || fe.intersectsObject(T))
              ) {
                const ze = w.update(T),
                  Xe = T.material;
                if (
                  (B &&
                    (void 0 !== T.boundingSphere
                      ? (null === T.boundingSphere && T.computeBoundingSphere(),
                        Je.copy(T.boundingSphere.center))
                      : (null === ze.boundingSphere &&
                          ze.computeBoundingSphere(),
                        Je.copy(ze.boundingSphere.center)),
                    Je.applyMatrix4(T.matrixWorld).applyMatrix4(Me)),
                  Array.isArray(Xe))
                ) {
                  const Ye = ze.groups;
                  for (let pt = 0, je = Ye.length; pt < je; pt++) {
                    const lt = Ye[pt],
                      on = Xe[lt.materialIndex];
                    on && on.visible && _.push(T, ze, on, J, Je.z, lt);
                  }
                } else Xe.visible && _.push(T, ze, Xe, J, Je.z, null);
              }
            const De = T.children;
            for (let ze = 0, Xe = De.length; ze < Xe; ze++) XN(De[ze], H, J, B);
          }
          function YN(T, H, J, B) {
            const Q = T.opaque,
              De = T.transmissive,
              ze = T.transparent;
            g.setupLightsView(J),
              !0 === le && Ne.setGlobalState(v.clippingPlanes, J),
              De.length > 0 &&
                (function hte(T, H, J, B) {
                  const Q = he.isWebGL2;
                  null === Le &&
                    (Le = new Uo(1, 1, {
                      generateMipmaps: !0,
                      type: te.has("EXT_color_buffer_half_float") ? Cu : Vs,
                      minFilter: Ro,
                      samples: Q ? 4 : 0,
                    })),
                    v.getDrawingBufferSize(Re),
                    Q ? Le.setSize(Re.x, Re.y) : Le.setSize(Lf(Re.x), Lf(Re.y));
                  const De = v.getRenderTarget();
                  v.setRenderTarget(Le),
                    v.getClearColor(V),
                    (z = v.getClearAlpha()),
                    z < 1 && v.setClearColor(16777215, 0.5),
                    v.clear();
                  const ze = v.toneMapping;
                  (v.toneMapping = Us),
                    gm(T, J, B),
                    Ae.updateMultisampleRenderTarget(Le),
                    Ae.updateRenderTargetMipmap(Le);
                  let Xe = !1;
                  for (let Ye = 0, pt = H.length; Ye < pt; Ye++) {
                    const je = H[Ye],
                      lt = je.object,
                      on = je.geometry,
                      hn = je.material,
                      tr = je.group;
                    if (2 === hn.side && lt.layers.test(B.layers)) {
                      const Ms = hn.side;
                      (hn.side = 1),
                        (hn.needsUpdate = !0),
                        ZN(lt, J, B, on, hn, tr),
                        (hn.side = Ms),
                        (hn.needsUpdate = !0),
                        (Xe = !0);
                    }
                  }
                  !0 === Xe &&
                    (Ae.updateMultisampleRenderTarget(Le),
                    Ae.updateRenderTargetMipmap(Le)),
                    v.setRenderTarget(De),
                    v.setClearColor(V, z),
                    (v.toneMapping = ze);
                })(Q, De, H, J),
              B && ae.viewport(C.copy(B)),
              Q.length > 0 && gm(Q, H, J),
              De.length > 0 && gm(De, H, J),
              ze.length > 0 && gm(ze, H, J),
              ae.buffers.depth.setTest(!0),
              ae.buffers.depth.setMask(!0),
              ae.buffers.color.setMask(!0),
              ae.setPolygonOffset(!1);
          }
          function gm(T, H, J) {
            const B = !0 === H.isScene ? H.overrideMaterial : null;
            for (let Q = 0, De = T.length; Q < De; Q++) {
              const ze = T[Q],
                Xe = ze.object,
                Ye = ze.geometry,
                pt = null === B ? ze.material : B,
                je = ze.group;
              Xe.layers.test(J.layers) && ZN(Xe, H, J, Ye, pt, je);
            }
          }
          function ZN(T, H, J, B, Q, De) {
            T.onBeforeRender(v, H, J, B, Q, De),
              T.modelViewMatrix.multiplyMatrices(
                J.matrixWorldInverse,
                T.matrixWorld,
              ),
              T.normalMatrix.getNormalMatrix(T.modelViewMatrix),
              Q.onBeforeRender(v, H, J, B, T, De),
              !0 === Q.transparent && 2 === Q.side && !1 === Q.forceSinglePass
                ? ((Q.side = 1),
                  (Q.needsUpdate = !0),
                  v.renderBufferDirect(J, H, B, Q, T, De),
                  (Q.side = 0),
                  (Q.needsUpdate = !0),
                  v.renderBufferDirect(J, H, B, Q, T, De),
                  (Q.side = 2))
                : v.renderBufferDirect(J, H, B, Q, T, De),
              T.onAfterRender(v, H, J, B, Q, De);
          }
          function _m(T, H, J) {
            !0 !== H.isScene && (H = Ft);
            const B = xe.get(T),
              Q = g.state.lights,
              ze = Q.state.version,
              Xe = G.getParameters(T, Q.state, g.state.shadowsArray, H, J),
              Ye = G.getProgramCacheKey(Xe);
            let pt = B.programs;
            (B.environment = T.isMeshStandardMaterial ? H.environment : null),
              (B.fog = H.fog),
              (B.envMap = (T.isMeshStandardMaterial ? _t : et).get(
                T.envMap || B.environment,
              )),
              void 0 === pt &&
                (T.addEventListener("dispose", Se),
                (pt = new Map()),
                (B.programs = pt));
            let je = pt.get(Ye);
            if (void 0 !== je) {
              if (B.currentProgram === je && B.lightsStateVersion === ze)
                return KN(T, Xe), je;
            } else
              (Xe.uniforms = G.getUniforms(T)),
                T.onBuild(J, Xe, v),
                T.onBeforeCompile(Xe, v),
                (je = G.acquireProgram(Xe, Ye)),
                pt.set(Ye, je),
                (B.uniforms = Xe.uniforms);
            const lt = B.uniforms;
            ((!T.isShaderMaterial && !T.isRawShaderMaterial) ||
              !0 === T.clipping) &&
              (lt.clippingPlanes = Ne.uniform),
              KN(T, Xe),
              (B.needsLights = (function mte(T) {
                return (
                  T.isMeshLambertMaterial ||
                  T.isMeshToonMaterial ||
                  T.isMeshPhongMaterial ||
                  T.isMeshStandardMaterial ||
                  T.isShadowMaterial ||
                  (T.isShaderMaterial && !0 === T.lights)
                );
              })(T)),
              (B.lightsStateVersion = ze),
              B.needsLights &&
                ((lt.ambientLightColor.value = Q.state.ambient),
                (lt.lightProbe.value = Q.state.probe),
                (lt.directionalLights.value = Q.state.directional),
                (lt.directionalLightShadows.value = Q.state.directionalShadow),
                (lt.spotLights.value = Q.state.spot),
                (lt.spotLightShadows.value = Q.state.spotShadow),
                (lt.rectAreaLights.value = Q.state.rectArea),
                (lt.ltc_1.value = Q.state.rectAreaLTC1),
                (lt.ltc_2.value = Q.state.rectAreaLTC2),
                (lt.pointLights.value = Q.state.point),
                (lt.pointLightShadows.value = Q.state.pointShadow),
                (lt.hemisphereLights.value = Q.state.hemi),
                (lt.directionalShadowMap.value = Q.state.directionalShadowMap),
                (lt.directionalShadowMatrix.value =
                  Q.state.directionalShadowMatrix),
                (lt.spotShadowMap.value = Q.state.spotShadowMap),
                (lt.spotLightMatrix.value = Q.state.spotLightMatrix),
                (lt.spotLightMap.value = Q.state.spotLightMap),
                (lt.pointShadowMap.value = Q.state.pointShadowMap),
                (lt.pointShadowMatrix.value = Q.state.pointShadowMatrix));
            const on = je.getUniforms(),
              hn = sp.seqWithValue(on.seq, lt);
            return (B.currentProgram = je), (B.uniformsList = hn), je;
          }
          function KN(T, H) {
            const J = xe.get(T);
            (J.outputColorSpace = H.outputColorSpace),
              (J.instancing = H.instancing),
              (J.instancingColor = H.instancingColor),
              (J.skinning = H.skinning),
              (J.morphTargets = H.morphTargets),
              (J.morphNormals = H.morphNormals),
              (J.morphColors = H.morphColors),
              (J.morphTargetsCount = H.morphTargetsCount),
              (J.numClippingPlanes = H.numClippingPlanes),
              (J.numIntersection = H.numClipIntersection),
              (J.vertexAlphas = H.vertexAlphas),
              (J.vertexTangents = H.vertexTangents),
              (J.toneMapping = H.toneMapping);
          }
          si.setAnimationLoop(function io(T) {
            yn && yn(T);
          }),
            typeof self < "u" && si.setContext(self),
            (this.setAnimationLoop = function (T) {
              (yn = T),
                O.setAnimationLoop(T),
                null === T ? si.stop() : si.start();
            }),
            O.addEventListener("sessionstart", Xt),
            O.addEventListener("sessionend", Vr),
            (this.render = function (T, H) {
              if (void 0 === H || !0 === H.isCamera) {
                if (!0 !== b) {
                  if (
                    (!0 === T.matrixWorldAutoUpdate && T.updateMatrixWorld(),
                    null === H.parent &&
                      !0 === H.matrixWorldAutoUpdate &&
                      H.updateMatrixWorld(),
                    !0 === O.enabled &&
                      !0 === O.isPresenting &&
                      (!0 === O.cameraAutoUpdate && O.updateCamera(H),
                      (H = O.getCamera())),
                    !0 === T.isScene && T.onBeforeRender(v, T, H, x),
                    (g = de.get(T, y.length)),
                    g.init(),
                    y.push(g),
                    Me.multiplyMatrices(
                      H.projectionMatrix,
                      H.matrixWorldInverse,
                    ),
                    fe.setFromProjectionMatrix(Me),
                    (be = this.localClippingEnabled),
                    (le = Ne.init(this.clippingPlanes, be)),
                    (_ = ce.get(T, m.length)),
                    _.init(),
                    m.push(_),
                    XN(T, H, 0, v.sortObjects),
                    _.finish(),
                    !0 === v.sortObjects && _.sort(k, q),
                    this.info.render.frame++,
                    !0 === le && Ne.beginShadows(),
                    pe.render(g.state.shadowsArray, T, H),
                    !0 === le && Ne.endShadows(),
                    !0 === this.info.autoReset && this.info.reset(),
                    j.render(_, T),
                    g.setupLights(v._useLegacyLights),
                    H.isArrayCamera)
                  ) {
                    const B = H.cameras;
                    for (let Q = 0, De = B.length; Q < De; Q++) {
                      const ze = B[Q];
                      YN(_, T, ze, ze.viewport);
                    }
                  } else YN(_, T, H);
                  null !== x &&
                    (Ae.updateMultisampleRenderTarget(x),
                    Ae.updateRenderTargetMipmap(x)),
                    !0 === T.isScene && T.onAfterRender(v, T, H),
                    Oe.resetDefaultState(),
                    (P = -1),
                    (M = null),
                    y.pop(),
                    (g = y.length > 0 ? y[y.length - 1] : null),
                    m.pop(),
                    (_ = m.length > 0 ? m[m.length - 1] : null);
                }
              } else
                console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
                );
            }),
            (this.getActiveCubeFace = function () {
              return S;
            }),
            (this.getActiveMipmapLevel = function () {
              return E;
            }),
            (this.getRenderTarget = function () {
              return x;
            }),
            (this.setRenderTargetTextures = function (T, H, J) {
              (xe.get(T.texture).__webglTexture = H),
                (xe.get(T.depthTexture).__webglTexture = J);
              const B = xe.get(T);
              (B.__hasExternalTextures = !0),
                B.__hasExternalTextures &&
                  ((B.__autoAllocateDepthBuffer = void 0 === J),
                  B.__autoAllocateDepthBuffer ||
                    (!0 === te.has("WEBGL_multisampled_render_to_texture") &&
                      (console.warn(
                        "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided",
                      ),
                      (B.__useRenderToTexture = !1))));
            }),
            (this.setRenderTargetFramebuffer = function (T, H) {
              const J = xe.get(T);
              (J.__webglFramebuffer = H),
                (J.__useDefaultFramebuffer = void 0 === H);
            }),
            (this.setRenderTarget = function (T, H = 0, J = 0) {
              (x = T), (S = H), (E = J);
              let B = !0,
                Q = null,
                De = !1,
                ze = !1;
              if (T) {
                const Ye = xe.get(T);
                void 0 !== Ye.__useDefaultFramebuffer
                  ? (ae.bindFramebuffer(R.FRAMEBUFFER, null), (B = !1))
                  : void 0 === Ye.__webglFramebuffer
                  ? Ae.setupRenderTarget(T)
                  : Ye.__hasExternalTextures &&
                    Ae.rebindTextures(
                      T,
                      xe.get(T.texture).__webglTexture,
                      xe.get(T.depthTexture).__webglTexture,
                    );
                const pt = T.texture;
                (pt.isData3DTexture ||
                  pt.isDataArrayTexture ||
                  pt.isCompressedArrayTexture) &&
                  (ze = !0);
                const je = xe.get(T).__webglFramebuffer;
                T.isWebGLCubeRenderTarget
                  ? ((Q = Array.isArray(je[H]) ? je[H][J] : je[H]), (De = !0))
                  : (Q =
                      he.isWebGL2 &&
                      T.samples > 0 &&
                      !1 === Ae.useMultisampledRTT(T)
                        ? xe.get(T).__webglMultisampledFramebuffer
                        : Array.isArray(je)
                        ? je[J]
                        : je),
                  C.copy(T.viewport),
                  $.copy(T.scissor),
                  (ie = T.scissorTest);
              } else
                C.copy(ee).multiplyScalar(N).floor(),
                  $.copy(U).multiplyScalar(N).floor(),
                  (ie = K);
              if (
                (ae.bindFramebuffer(R.FRAMEBUFFER, Q) &&
                  he.drawBuffers &&
                  B &&
                  ae.drawBuffers(T, Q),
                ae.viewport(C),
                ae.scissor($),
                ae.setScissorTest(ie),
                De)
              ) {
                const Ye = xe.get(T.texture);
                R.framebufferTexture2D(
                  R.FRAMEBUFFER,
                  R.COLOR_ATTACHMENT0,
                  R.TEXTURE_CUBE_MAP_POSITIVE_X + H,
                  Ye.__webglTexture,
                  J,
                );
              } else if (ze) {
                const Ye = xe.get(T.texture);
                R.framebufferTextureLayer(
                  R.FRAMEBUFFER,
                  R.COLOR_ATTACHMENT0,
                  Ye.__webglTexture,
                  J || 0,
                  H || 0,
                );
              }
              P = -1;
            }),
            (this.readRenderTargetPixels = function (T, H, J, B, Q, De, ze) {
              if (!T || !T.isWebGLRenderTarget)
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
                );
              let Xe = xe.get(T).__webglFramebuffer;
              if (
                (T.isWebGLCubeRenderTarget && void 0 !== ze && (Xe = Xe[ze]),
                Xe)
              ) {
                ae.bindFramebuffer(R.FRAMEBUFFER, Xe);
                try {
                  const Ye = T.texture,
                    pt = Ye.format,
                    je = Ye.type;
                  if (
                    pt !== Ki &&
                    Pe.convert(pt) !==
                      R.getParameter(R.IMPLEMENTATION_COLOR_READ_FORMAT)
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
                    );
                  const lt =
                    je === Cu &&
                    (te.has("EXT_color_buffer_half_float") ||
                      (he.isWebGL2 && te.has("EXT_color_buffer_float")));
                  if (
                    !(
                      je === Vs ||
                      Pe.convert(je) ===
                        R.getParameter(R.IMPLEMENTATION_COLOR_READ_TYPE) ||
                      (je === as &&
                        (he.isWebGL2 ||
                          te.has("OES_texture_float") ||
                          te.has("WEBGL_color_buffer_float"))) ||
                      lt
                    )
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
                    );
                  H >= 0 &&
                    H <= T.width - B &&
                    J >= 0 &&
                    J <= T.height - Q &&
                    R.readPixels(
                      H,
                      J,
                      B,
                      Q,
                      Pe.convert(pt),
                      Pe.convert(je),
                      De,
                    );
                } finally {
                  const Ye = null !== x ? xe.get(x).__webglFramebuffer : null;
                  ae.bindFramebuffer(R.FRAMEBUFFER, Ye);
                }
              }
            }),
            (this.copyFramebufferToTexture = function (T, H, J = 0) {
              const B = Math.pow(2, -J),
                Q = Math.floor(H.image.width * B),
                De = Math.floor(H.image.height * B);
              Ae.setTexture2D(H, 0),
                R.copyTexSubImage2D(R.TEXTURE_2D, J, 0, 0, T.x, T.y, Q, De),
                ae.unbindTexture();
            }),
            (this.copyTextureToTexture = function (T, H, J, B = 0) {
              const Q = H.image.width,
                De = H.image.height,
                ze = Pe.convert(J.format),
                Xe = Pe.convert(J.type);
              Ae.setTexture2D(J, 0),
                R.pixelStorei(R.UNPACK_FLIP_Y_WEBGL, J.flipY),
                R.pixelStorei(
                  R.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  J.premultiplyAlpha,
                ),
                R.pixelStorei(R.UNPACK_ALIGNMENT, J.unpackAlignment),
                H.isDataTexture
                  ? R.texSubImage2D(
                      R.TEXTURE_2D,
                      B,
                      T.x,
                      T.y,
                      Q,
                      De,
                      ze,
                      Xe,
                      H.image.data,
                    )
                  : H.isCompressedTexture
                  ? R.compressedTexSubImage2D(
                      R.TEXTURE_2D,
                      B,
                      T.x,
                      T.y,
                      H.mipmaps[0].width,
                      H.mipmaps[0].height,
                      ze,
                      H.mipmaps[0].data,
                    )
                  : R.texSubImage2D(R.TEXTURE_2D, B, T.x, T.y, ze, Xe, H.image),
                0 === B && J.generateMipmaps && R.generateMipmap(R.TEXTURE_2D),
                ae.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (T, H, J, B, Q = 0) {
              if (v.isWebGL1Renderer)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.",
                );
              const De = T.max.x - T.min.x + 1,
                ze = T.max.y - T.min.y + 1,
                Xe = T.max.z - T.min.z + 1,
                Ye = Pe.convert(B.format),
                pt = Pe.convert(B.type);
              let je;
              if (B.isData3DTexture) Ae.setTexture3D(B, 0), (je = R.TEXTURE_3D);
              else {
                if (!B.isDataArrayTexture)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.",
                  );
                Ae.setTexture2DArray(B, 0), (je = R.TEXTURE_2D_ARRAY);
              }
              R.pixelStorei(R.UNPACK_FLIP_Y_WEBGL, B.flipY),
                R.pixelStorei(
                  R.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  B.premultiplyAlpha,
                ),
                R.pixelStorei(R.UNPACK_ALIGNMENT, B.unpackAlignment);
              const lt = R.getParameter(R.UNPACK_ROW_LENGTH),
                on = R.getParameter(R.UNPACK_IMAGE_HEIGHT),
                hn = R.getParameter(R.UNPACK_SKIP_PIXELS),
                tr = R.getParameter(R.UNPACK_SKIP_ROWS),
                Ms = R.getParameter(R.UNPACK_SKIP_IMAGES),
                bn = J.isCompressedTexture ? J.mipmaps[0] : J.image;
              R.pixelStorei(R.UNPACK_ROW_LENGTH, bn.width),
                R.pixelStorei(R.UNPACK_IMAGE_HEIGHT, bn.height),
                R.pixelStorei(R.UNPACK_SKIP_PIXELS, T.min.x),
                R.pixelStorei(R.UNPACK_SKIP_ROWS, T.min.y),
                R.pixelStorei(R.UNPACK_SKIP_IMAGES, T.min.z),
                J.isDataTexture || J.isData3DTexture
                  ? R.texSubImage3D(
                      je,
                      Q,
                      H.x,
                      H.y,
                      H.z,
                      De,
                      ze,
                      Xe,
                      Ye,
                      pt,
                      bn.data,
                    )
                  : J.isCompressedArrayTexture
                  ? (console.warn(
                      "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.",
                    ),
                    R.compressedTexSubImage3D(
                      je,
                      Q,
                      H.x,
                      H.y,
                      H.z,
                      De,
                      ze,
                      Xe,
                      Ye,
                      bn.data,
                    ))
                  : R.texSubImage3D(
                      je,
                      Q,
                      H.x,
                      H.y,
                      H.z,
                      De,
                      ze,
                      Xe,
                      Ye,
                      pt,
                      bn,
                    ),
                R.pixelStorei(R.UNPACK_ROW_LENGTH, lt),
                R.pixelStorei(R.UNPACK_IMAGE_HEIGHT, on),
                R.pixelStorei(R.UNPACK_SKIP_PIXELS, hn),
                R.pixelStorei(R.UNPACK_SKIP_ROWS, tr),
                R.pixelStorei(R.UNPACK_SKIP_IMAGES, Ms),
                0 === Q && B.generateMipmaps && R.generateMipmap(je),
                ae.unbindTexture();
            }),
            (this.initTexture = function (T) {
              T.isCubeTexture
                ? Ae.setTextureCube(T, 0)
                : T.isData3DTexture
                ? Ae.setTexture3D(T, 0)
                : T.isDataArrayTexture || T.isCompressedArrayTexture
                ? Ae.setTexture2DArray(T, 0)
                : Ae.setTexture2D(T, 0),
                ae.unbindTexture();
            }),
            (this.resetState = function () {
              (S = 0), (E = 0), (x = null), ae.reset(), Oe.reset();
            }),
            typeof __THREE_DEVTOOLS__ < "u" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this }),
              );
        }
        get coordinateSystem() {
          return ls;
        }
        get physicallyCorrectLights() {
          return (
            console.warn(
              "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.",
            ),
            !this.useLegacyLights
          );
        }
        set physicallyCorrectLights(e) {
          console.warn(
            "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.",
          ),
            (this.useLegacyLights = !e);
        }
        get outputEncoding() {
          return (
            console.warn(
              "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.",
            ),
            this.outputColorSpace === rt ? No : 3e3
          );
        }
        set outputEncoding(e) {
          console.warn(
            "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.",
          ),
            (this.outputColorSpace = e === No ? rt : Nr);
        }
        get useLegacyLights() {
          return (
            console.warn(
              "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.",
            ),
            this._useLegacyLights
          );
        }
        set useLegacyLights(e) {
          console.warn(
            "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.",
          ),
            (this._useLegacyLights = e);
        }
      }
      (class uX extends sP {}).prototype.isWebGL1Renderer = !0;
      class oP extends Ii {
        constructor() {
          super(),
            (this.isScene = !0),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.overrideMaterial = null),
            typeof __THREE_DEVTOOLS__ < "u" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this }),
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.environment &&
              (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            (this.backgroundBlurriness = e.backgroundBlurriness),
            (this.backgroundIntensity = e.backgroundIntensity),
            null !== e.overrideMaterial &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 &&
              (t.object.backgroundBlurriness = this.backgroundBlurriness),
            1 !== this.backgroundIntensity &&
              (t.object.backgroundIntensity = this.backgroundIntensity),
            t
          );
        }
      }
      class xp extends ht {
        constructor(e = 1, t = 0.4, i = 12, r = 48, s = 2 * Math.PI) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: e,
              tube: t,
              radialSegments: i,
              tubularSegments: r,
              arc: s,
            }),
            (i = Math.floor(i)),
            (r = Math.floor(r));
          const o = [],
            a = [],
            l = [],
            c = [],
            u = new D(),
            d = new D(),
            h = new D();
          for (let f = 0; f <= i; f++)
            for (let p = 0; p <= r; p++) {
              const _ = (p / r) * s,
                g = (f / i) * Math.PI * 2;
              (d.x = (e + t * Math.cos(g)) * Math.cos(_)),
                (d.y = (e + t * Math.cos(g)) * Math.sin(_)),
                (d.z = t * Math.sin(g)),
                a.push(d.x, d.y, d.z),
                (u.x = e * Math.cos(_)),
                (u.y = e * Math.sin(_)),
                h.subVectors(d, u).normalize(),
                l.push(h.x, h.y, h.z),
                c.push(p / r),
                c.push(f / i);
            }
          for (let f = 1; f <= i; f++)
            for (let p = 1; p <= r; p++) {
              const g = (r + 1) * (f - 1) + p - 1,
                m = (r + 1) * (f - 1) + p,
                y = (r + 1) * f + p;
              o.push((r + 1) * f + p - 1, g, y), o.push(g, m, y);
            }
          this.setIndex(o),
            this.setAttribute("position", new Ie(a, 3)),
            this.setAttribute("normal", new Ie(l, 3)),
            this.setAttribute("uv", new Ie(c, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new xp(
            e.radius,
            e.tube,
            e.radialSegments,
            e.tubularSegments,
            e.arc,
          );
        }
      }
      function Ji(n, e, t) {
        return V0(n)
          ? new n.constructor(n.subarray(e, void 0 !== t ? t : n.length))
          : n.slice(e, t);
      }
      function Yo(n, e, t) {
        return !n || (!t && n.constructor === e)
          ? n
          : "number" == typeof e.BYTES_PER_ELEMENT
          ? new e(n)
          : Array.prototype.slice.call(n);
      }
      function V0(n) {
        return ArrayBuffer.isView(n) && !(n instanceof DataView);
      }
      class Tp {
        constructor(e, t, i, r) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== r ? r : new t.constructor(i)),
            (this.sampleValues = t),
            (this.valueSize = i),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let i = this._cachedIndex,
            r = t[i],
            s = t[i - 1];
          e: {
            t: {
              let o;
              n: {
                i: if (!(e < r)) {
                  for (let a = i + 2; ; ) {
                    if (void 0 === r) {
                      if (e < s) break i;
                      return (
                        (i = t.length),
                        (this._cachedIndex = i),
                        this.copySampleValue_(i - 1)
                      );
                    }
                    if (i === a) break;
                    if (((s = r), (r = t[++i]), e < r)) break t;
                  }
                  o = t.length;
                  break n;
                }
                if (e >= s) break e;
                {
                  const a = t[1];
                  e < a && ((i = 2), (s = a));
                  for (let l = i - 2; ; ) {
                    if (void 0 === s)
                      return (this._cachedIndex = 0), this.copySampleValue_(0);
                    if (i === l) break;
                    if (((r = s), (s = t[--i - 1]), e >= s)) break t;
                  }
                  (o = i), (i = 0);
                }
              }
              for (; i < o; ) {
                const a = (i + o) >>> 1;
                e < t[a] ? (o = a) : (i = a + 1);
              }
              if (((r = t[i]), (s = t[i - 1]), void 0 === s))
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (void 0 === r)
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
            }
            (this._cachedIndex = i), this.intervalChanged_(i, s, r);
          }
          return this.interpolate_(i, s, e, r);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            i = this.sampleValues,
            r = this.valueSize,
            s = e * r;
          for (let o = 0; o !== r; ++o) t[o] = i[s + o];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      class fY extends Tp {
        constructor(e, t, i, r) {
          super(e, t, i, r),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
        }
        intervalChanged_(e, t, i) {
          const r = this.parameterPositions;
          let s = e - 2,
            o = e + 1,
            a = r[s],
            l = r[o];
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case 2401:
                (s = e), (a = 2 * t - i);
                break;
              case 2402:
                (s = r.length - 2), (a = t + r[s] - r[s + 1]);
                break;
              default:
                (s = e), (a = i);
            }
          if (void 0 === l)
            switch (this.getSettings_().endingEnd) {
              case 2401:
                (o = e), (l = 2 * i - t);
                break;
              case 2402:
                (o = 1), (l = i + r[1] - r[0]);
                break;
              default:
                (o = e - 1), (l = t);
            }
          const c = 0.5 * (i - t),
            u = this.valueSize;
          (this._weightPrev = c / (t - a)),
            (this._weightNext = c / (l - i)),
            (this._offsetPrev = s * u),
            (this._offsetNext = o * u);
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = this._offsetPrev,
            d = this._offsetNext,
            h = this._weightPrev,
            f = this._weightNext,
            p = (i - t) / (r - t),
            _ = p * p,
            g = _ * p,
            m = -h * g + 2 * h * _ - h * p,
            y = (1 + h) * g + (-1.5 - 2 * h) * _ + (-0.5 + h) * p + 1,
            v = (-1 - f) * g + (1.5 + f) * _ + 0.5 * p,
            b = f * g - f * _;
          for (let S = 0; S !== a; ++S)
            s[S] = m * o[u + S] + y * o[c + S] + v * o[l + S] + b * o[d + S];
          return s;
        }
      }
      class $P extends Tp {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = (i - t) / (r - t),
            d = 1 - u;
          for (let h = 0; h !== a; ++h) s[h] = o[c + h] * d + o[l + h] * u;
          return s;
        }
      }
      class pY extends Tp {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class Ur {
        constructor(e, t, i, r) {
          if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === t || 0 === t.length)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e,
            );
          (this.name = e),
            (this.times = Yo(t, this.TimeBufferType)),
            (this.values = Yo(i, this.ValueBufferType)),
            this.setInterpolation(r || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let i;
          if (t.toJSON !== this.toJSON) i = t.toJSON(e);
          else {
            i = {
              name: e.name,
              times: Yo(e.times, Array),
              values: Yo(e.values, Array),
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r);
          }
          return (i.type = e.ValueTypeName), i;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new pY(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new $P(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new fY(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case 2300:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case 2301:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case 2302:
              t = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === t) {
            const i =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (e === this.DefaultInterpolation) throw new Error(i);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", i), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return 2300;
            case this.InterpolantFactoryMethodLinear:
              return 2301;
            case this.InterpolantFactoryMethodSmooth:
              return 2302;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (0 !== e) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
          }
          return this;
        }
        scale(e) {
          if (1 !== e) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
          }
          return this;
        }
        trim(e, t) {
          const i = this.times,
            r = i.length;
          let s = 0,
            o = r - 1;
          for (; s !== r && i[s] < e; ) ++s;
          for (; -1 !== o && i[o] > t; ) --o;
          if ((++o, 0 !== s || o !== r)) {
            s >= o && ((o = Math.max(o, 1)), (s = o - 1));
            const a = this.getValueSize();
            (this.times = Ji(i, s, o)),
              (this.values = Ji(this.values, s * a, o * a));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this,
            ),
            (e = !1));
          const i = this.times,
            r = this.values,
            s = i.length;
          0 === s &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let o = null;
          for (let a = 0; a !== s; a++) {
            const l = i[a];
            if ("number" == typeof l && isNaN(l)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                a,
                l,
              ),
                (e = !1);
              break;
            }
            if (null !== o && o > l) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                a,
                l,
                o,
              ),
                (e = !1);
              break;
            }
            o = l;
          }
          if (void 0 !== r && V0(r))
            for (let a = 0, l = r.length; a !== l; ++a) {
              const c = r[a];
              if (isNaN(c)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  a,
                  c,
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = Ji(this.times),
            t = Ji(this.values),
            i = this.getValueSize(),
            r = 2302 === this.getInterpolation(),
            s = e.length - 1;
          let o = 1;
          for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a];
            if (c !== e[a + 1] && (1 !== a || c !== e[0]))
              if (r) l = !0;
              else {
                const d = a * i,
                  h = d - i,
                  f = d + i;
                for (let p = 0; p !== i; ++p) {
                  const _ = t[d + p];
                  if (_ !== t[h + p] || _ !== t[f + p]) {
                    l = !0;
                    break;
                  }
                }
              }
            if (l) {
              if (a !== o) {
                e[o] = e[a];
                const d = a * i,
                  h = o * i;
                for (let f = 0; f !== i; ++f) t[h + f] = t[d + f];
              }
              ++o;
            }
          }
          if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, l = o * i, c = 0; c !== i; ++c)
              t[l + c] = t[a + c];
            ++o;
          }
          return (
            o !== e.length
              ? ((this.times = Ji(e, 0, o)), (this.values = Ji(t, 0, o * i)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = Ji(this.times, 0),
            t = Ji(this.values, 0),
            r = new (0, this.constructor)(this.name, e, t);
          return (r.createInterpolant = this.createInterpolant), r;
        }
      }
      (Ur.prototype.TimeBufferType = Float32Array),
        (Ur.prototype.ValueBufferType = Float32Array),
        (Ur.prototype.DefaultInterpolation = 2301);
      class Kl extends Ur {}
      (Kl.prototype.ValueTypeName = "bool"),
        (Kl.prototype.ValueBufferType = Array),
        (Kl.prototype.DefaultInterpolation = 2300),
        (Kl.prototype.InterpolantFactoryMethodLinear = void 0),
        (Kl.prototype.InterpolantFactoryMethodSmooth = void 0);
      (class jP extends Ur {}).prototype.ValueTypeName = "color";
      (class Dp extends Ur {}).prototype.ValueTypeName = "number";
      class mY extends Tp {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (i - t) / (r - t);
          let c = e * a;
          for (let u = c + a; c !== u; c += 4)
            Di.slerpFlat(s, 0, o, c - a, o, c, l);
          return s;
        }
      }
      class Ku extends Ur {
        InterpolantFactoryMethodLinear(e) {
          return new mY(this.times, this.values, this.getValueSize(), e);
        }
      }
      (Ku.prototype.ValueTypeName = "quaternion"),
        (Ku.prototype.DefaultInterpolation = 2301),
        (Ku.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Ql extends Ur {}
      (Ql.prototype.ValueTypeName = "string"),
        (Ql.prototype.ValueBufferType = Array),
        (Ql.prototype.DefaultInterpolation = 2300),
        (Ql.prototype.InterpolantFactoryMethodLinear = void 0),
        (Ql.prototype.InterpolantFactoryMethodSmooth = void 0);
      (class Ap extends Ur {}).prototype.ValueTypeName = "vector";
      const Jl = {
        enabled: !1,
        files: {},
        add: function (n, e) {
          !1 !== this.enabled && (this.files[n] = e);
        },
        get: function (n) {
          if (!1 !== this.enabled) return this.files[n];
        },
        remove: function (n) {
          delete this.files[n];
        },
        clear: function () {
          this.files = {};
        },
      };
      class qP {
        constructor(e, t, i) {
          const r = this;
          let l,
            s = !1,
            o = 0,
            a = 0;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = i),
            (this.itemStart = function (u) {
              a++,
                !1 === s && void 0 !== r.onStart && r.onStart(u, o, a),
                (s = !0);
            }),
            (this.itemEnd = function (u) {
              o++,
                void 0 !== r.onProgress && r.onProgress(u, o, a),
                o === a && ((s = !1), void 0 !== r.onLoad && r.onLoad());
            }),
            (this.itemError = function (u) {
              void 0 !== r.onError && r.onError(u);
            }),
            (this.resolveURL = function (u) {
              return l ? l(u) : u;
            }),
            (this.setURLModifier = function (u) {
              return (l = u), this;
            }),
            (this.addHandler = function (u, d) {
              return c.push(u, d), this;
            }),
            (this.removeHandler = function (u) {
              const d = c.indexOf(u);
              return -1 !== d && c.splice(d, 2), this;
            }),
            (this.getHandler = function (u) {
              for (let d = 0, h = c.length; d < h; d += 2) {
                const f = c[d],
                  p = c[d + 1];
                if ((f.global && (f.lastIndex = 0), f.test(u))) return p;
              }
              return null;
            });
        }
      }
      const vY = new qP();
      let XP = (() => {
        class n {
          constructor(t) {
            (this.manager = void 0 !== t ? t : vY),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() {}
          loadAsync(t, i) {
            const r = this;
            return new Promise(function (s, o) {
              r.load(t, s, i, o);
            });
          }
          parse() {}
          setCrossOrigin(t) {
            return (this.crossOrigin = t), this;
          }
          setWithCredentials(t) {
            return (this.withCredentials = t), this;
          }
          setPath(t) {
            return (this.path = t), this;
          }
          setResourcePath(t) {
            return (this.resourcePath = t), this;
          }
          setRequestHeader(t) {
            return (this.requestHeader = t), this;
          }
        }
        return (n.DEFAULT_MATERIAL_NAME = "__DEFAULT"), n;
      })();
      class Rp extends XP {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const s = this,
            o = Jl.get(e);
          if (void 0 !== o)
            return (
              s.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), s.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = Tu("img");
          function l() {
            u(), Jl.add(e, this), t && t(this), s.manager.itemEnd(e);
          }
          function c(d) {
            u(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e);
          }
          function u() {
            a.removeEventListener("load", l, !1),
              a.removeEventListener("error", c, !1);
          }
          return (
            a.addEventListener("load", l, !1),
            a.addEventListener("error", c, !1),
            "data:" !== e.slice(0, 5) &&
              void 0 !== this.crossOrigin &&
              (a.crossOrigin = this.crossOrigin),
            s.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class bY extends XP {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          const s = new zs(),
            o = new Rp(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              e,
              function (a) {
                (s.image = a), (s.needsUpdate = !0), void 0 !== t && t(s);
              },
              i,
              r,
            ),
            s
          );
        }
      }
      class YP extends Ii {
        constructor(e, t = 1) {
          super(),
            (this.isLight = !0),
            (this.type = "Light"),
            (this.color = new Ce(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e, t) {
          return (
            super.copy(e, t),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
          );
        }
      }
      const G0 = new it(),
        ZP = new D(),
        KP = new D();
      class SY {
        constructor(e) {
          (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new oe(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new it()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new n0()),
            (this._frameExtents = new oe(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new Ut(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            i = this.matrix;
          ZP.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(ZP),
            KP.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(KP),
            t.updateMatrixWorld(),
            G0.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(G0),
            i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            i.multiply(G0);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            0 !== this.bias && (e.bias = this.bias),
            0 !== this.normalBias && (e.normalBias = this.normalBias),
            1 !== this.radius && (e.radius = this.radius),
            (512 !== this.mapSize.x || 512 !== this.mapSize.y) &&
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      const QP = new it(),
        Qu = new D(),
        W0 = new D();
      class CY extends SY {
        constructor() {
          super(new kn(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new oe(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new Ut(2, 1, 1, 1),
              new Ut(0, 1, 1, 1),
              new Ut(3, 1, 1, 1),
              new Ut(1, 1, 1, 1),
              new Ut(3, 0, 1, 1),
              new Ut(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new D(1, 0, 0),
              new D(-1, 0, 0),
              new D(0, 0, 1),
              new D(0, 0, -1),
              new D(0, 1, 0),
              new D(0, -1, 0),
            ]),
            (this._cubeUps = [
              new D(0, 1, 0),
              new D(0, 1, 0),
              new D(0, 1, 0),
              new D(0, 1, 0),
              new D(0, 0, 1),
              new D(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const i = this.camera,
            r = this.matrix,
            s = e.distance || i.far;
          s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
            Qu.setFromMatrixPosition(e.matrixWorld),
            i.position.copy(Qu),
            W0.copy(i.position),
            W0.add(this._cubeDirections[t]),
            i.up.copy(this._cubeUps[t]),
            i.lookAt(W0),
            i.updateMatrixWorld(),
            r.makeTranslation(-Qu.x, -Qu.y, -Qu.z),
            QP.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(QP);
        }
      }
      class $0 extends YP {
        constructor(e, t, i = 0, r = 2) {
          super(e, t),
            (this.isPointLight = !0),
            (this.type = "PointLight"),
            (this.distance = i),
            (this.decay = r),
            (this.shadow = new CY());
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      class JP extends YP {
        constructor(e, t) {
          super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
        }
      }
      class a1 {
        constructor(e = !0) {
          (this.autoStart = e),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = l1()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = l1();
            (e = (t - this.oldTime) / 1e3),
              (this.oldTime = t),
              (this.elapsedTime += e);
          }
          return e;
        }
      }
      function l1() {
        return (typeof performance > "u" ? Date : performance).now();
      }
      const q0 = "\\[\\]\\.:\\/",
        kY = new RegExp("[" + q0 + "]", "g"),
        X0 = "[^" + q0 + "]",
        UY = "[^" + q0.replace("\\.", "") + "]",
        GY = new RegExp(
          "^" +
            /((?:WC+[\/:])*)/.source.replace("WC", X0) +
            /(WCOD+)?/.source.replace("WCOD", UY) +
            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", X0) +
            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", X0) +
            "$",
        ),
        WY = ["material", "materials", "bones", "map"];
      class $Y {
        constructor(e, t, i) {
          const r = i || qt.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
        }
        getValue(e, t) {
          this.bind();
          const r = this._bindings[this._targetGroup.nCachedObjects_];
          void 0 !== r && r.getValue(e, t);
        }
        setValue(e, t) {
          const i = this._bindings;
          for (
            let r = this._targetGroup.nCachedObjects_, s = i.length;
            r !== s;
            ++r
          )
            i[r].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, i = e.length;
            t !== i;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, i = e.length;
            t !== i;
            ++t
          )
            e[t].unbind();
        }
      }
      let qt = (() => {
        class n {
          constructor(t, i, r) {
            (this.path = i),
              (this.parsedPath = r || n.parseTrackName(i)),
              (this.node = n.findNode(t, this.parsedPath.nodeName)),
              (this.rootNode = t),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(t, i, r) {
            return t && t.isAnimationObjectGroup
              ? new n.Composite(t, i, r)
              : new n(t, i, r);
          }
          static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(kY, "");
          }
          static parseTrackName(t) {
            const i = GY.exec(t);
            if (null === i)
              throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const r = {
                nodeName: i[2],
                objectName: i[3],
                objectIndex: i[4],
                propertyName: i[5],
                propertyIndex: i[6],
              },
              s = r.nodeName && r.nodeName.lastIndexOf(".");
            if (void 0 !== s && -1 !== s) {
              const o = r.nodeName.substring(s + 1);
              -1 !== WY.indexOf(o) &&
                ((r.nodeName = r.nodeName.substring(0, s)), (r.objectName = o));
            }
            if (null === r.propertyName || 0 === r.propertyName.length)
              throw new Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  t,
              );
            return r;
          }
          static findNode(t, i) {
            if (
              void 0 === i ||
              "" === i ||
              "." === i ||
              -1 === i ||
              i === t.name ||
              i === t.uuid
            )
              return t;
            if (t.skeleton) {
              const r = t.skeleton.getBoneByName(i);
              if (void 0 !== r) return r;
            }
            if (t.children) {
              const r = function (o) {
                  for (let a = 0; a < o.length; a++) {
                    const l = o[a];
                    if (l.name === i || l.uuid === i) return l;
                    const c = r(l.children);
                    if (c) return c;
                  }
                  return null;
                },
                s = r(t.children);
              if (s) return s;
            }
            return null;
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(t, i) {
            t[i] = this.targetObject[this.propertyName];
          }
          _getValue_array(t, i) {
            const r = this.resolvedProperty;
            for (let s = 0, o = r.length; s !== o; ++s) t[i++] = r[s];
          }
          _getValue_arrayElement(t, i) {
            t[i] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(t, i) {
            this.resolvedProperty.toArray(t, i);
          }
          _setValue_direct(t, i) {
            this.targetObject[this.propertyName] = t[i];
          }
          _setValue_direct_setNeedsUpdate(t, i) {
            (this.targetObject[this.propertyName] = t[i]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(t, i) {
            (this.targetObject[this.propertyName] = t[i]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(t, i) {
            const r = this.resolvedProperty;
            for (let s = 0, o = r.length; s !== o; ++s) r[s] = t[i++];
          }
          _setValue_array_setNeedsUpdate(t, i) {
            const r = this.resolvedProperty;
            for (let s = 0, o = r.length; s !== o; ++s) r[s] = t[i++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(t, i) {
            const r = this.resolvedProperty;
            for (let s = 0, o = r.length; s !== o; ++s) r[s] = t[i++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(t, i) {
            this.resolvedProperty[this.propertyIndex] = t[i];
          }
          _setValue_arrayElement_setNeedsUpdate(t, i) {
            (this.resolvedProperty[this.propertyIndex] = t[i]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, i) {
            (this.resolvedProperty[this.propertyIndex] = t[i]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(t, i) {
            this.resolvedProperty.fromArray(t, i);
          }
          _setValue_fromArray_setNeedsUpdate(t, i) {
            this.resolvedProperty.fromArray(t, i),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(t, i) {
            this.resolvedProperty.fromArray(t, i),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(t, i) {
            this.bind(), this.getValue(t, i);
          }
          _setValue_unbound(t, i) {
            this.bind(), this.setValue(t, i);
          }
          bind() {
            let t = this.node;
            const i = this.parsedPath,
              r = i.objectName,
              s = i.propertyName;
            let o = i.propertyIndex;
            if (
              (t ||
                ((t = n.findNode(this.rootNode, i.nodeName)), (this.node = t)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !t)
            )
              return void console.warn(
                "THREE.PropertyBinding: No target node found for track: " +
                  this.path +
                  ".",
              );
            if (r) {
              let u = i.objectIndex;
              switch (r) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this,
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this,
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this,
                    );
                  t = t.skeleton.bones;
                  for (let d = 0; d < t.length; d++)
                    if (t[d].name === u) {
                      u = d;
                      break;
                    }
                  break;
                case "map":
                  if ("map" in t) {
                    t = t.map;
                    break;
                  }
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this,
                    );
                  if (!t.material.map)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                      this,
                    );
                  t = t.material.map;
                  break;
                default:
                  if (void 0 === t[r])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this,
                    );
                  t = t[r];
              }
              if (void 0 !== u) {
                if (void 0 === t[u])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t,
                  );
                t = t[u];
              }
            }
            const a = t[s];
            if (void 0 === a)
              return void console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  i.nodeName +
                  "." +
                  s +
                  " but it wasn't found.",
                t,
              );
            let l = this.Versioning.None;
            (this.targetObject = t),
              void 0 !== t.needsUpdate
                ? (l = this.Versioning.NeedsUpdate)
                : void 0 !== t.matrixWorldNeedsUpdate &&
                  (l = this.Versioning.MatrixWorldNeedsUpdate);
            let c = this.BindingType.Direct;
            if (void 0 !== o) {
              if ("morphTargetInfluences" === s) {
                if (!t.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this,
                  );
                if (!t.geometry.morphAttributes)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this,
                  );
                void 0 !== t.morphTargetDictionary[o] &&
                  (o = t.morphTargetDictionary[o]);
              }
              (c = this.BindingType.ArrayElement),
                (this.resolvedProperty = a),
                (this.propertyIndex = o);
            } else
              void 0 !== a.fromArray && void 0 !== a.toArray
                ? ((c = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = a))
                : Array.isArray(a)
                ? ((c = this.BindingType.EntireArray),
                  (this.resolvedProperty = a))
                : (this.propertyName = s);
            (this.getValue = this.GetterByBindingType[c]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[c][l]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        }
        return (n.Composite = $Y), n;
      })();
      (qt.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      }),
        (qt.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (qt.prototype.GetterByBindingType = [
          qt.prototype._getValue_direct,
          qt.prototype._getValue_array,
          qt.prototype._getValue_arrayElement,
          qt.prototype._getValue_toArray,
        ]),
        (qt.prototype.SetterByBindingTypeAndVersioning = [
          [
            qt.prototype._setValue_direct,
            qt.prototype._setValue_direct_setNeedsUpdate,
            qt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            qt.prototype._setValue_array,
            qt.prototype._setValue_array_setNeedsUpdate,
            qt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            qt.prototype._setValue_arrayElement,
            qt.prototype._setValue_arrayElement_setNeedsUpdate,
            qt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            qt.prototype._setValue_fromArray,
            qt.prototype._setValue_fromArray_setNeedsUpdate,
            qt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]),
        new Float32Array(1),
        typeof __THREE_DEVTOOLS__ < "u" &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("register", { detail: { revision: "155" } }),
          ),
        typeof window < "u" &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported.",
              )
            : (window.__THREE__ = "155"));
      let ZY = (() => {
        class n {
          ngOnInit() {
            this.createThreeJsBox();
          }
          createThreeJsBox() {
            const t = document.getElementById("logo-box"),
              r = new oP();
            var s = new bY().load(
                "./assets/img/photo_5873190219493260807_c.jpg",
              ),
              o = new qs({ map: s });
            const a = new JP(16777215, 0.1);
            r.add(a);
            const l = new $0(16777215, 10);
            (l.position.x = 2), (l.position.y = 2), (l.position.z = 2);
            const c = new $0(16777215, 100);
            (c.position.x = 10),
              (c.position.y = 10),
              (c.position.z = 10),
              r.add(c);
            const u = new ti(new zo(13, 13, 13), o),
              d = new ti(new xp(5, 1.5, 16, 100), o);
            r.add(u);
            const h = {
                width: window.innerWidth,
                height: 0.8 * window.innerHeight,
              },
              f = new kn(75, h.width / h.height, 0.001, 1e3);
            if (((f.position.z = 30), r.add(f), !t))
              return void console.warn("missing canvas object");
            const p = new sP({ canvas: t });
            p.setClearColor(3358535, 1),
              p.setSize(h.width, 0.8 * window.innerHeight),
              window.addEventListener("resize", function () {
                var m = window.innerWidth,
                  y = 0.8 * window.innerHeight;
                p.setSize(m, y), (f.aspect = m / y), f.updateProjectionMatrix();
              });
            const _ = new a1(),
              g = () => {
                const m = _.getElapsedTime();
                (u.rotation.x = m),
                  (u.rotation.y = m),
                  (u.rotation.z = m),
                  (d.rotation.x = -m),
                  (d.rotation.y = -m),
                  (d.rotation.z = -m),
                  p.render(r, f),
                  window.requestAnimationFrame(g);
              };
            g();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = Hi({
            type: n,
            selectors: [["app-logo-box"]],
            decls: 1,
            vars: 0,
            consts: [["id", "logo-box"]],
            template: function (t, i) {
              1 & t && xt(0, "canvas", 0);
            },
          })),
          n
        );
      })();
      function Ju(n) {
        return (Ju =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function (e) {
                return typeof e;
              }
            : function (e) {
                return e &&
                  "function" == typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? "symbol"
                  : typeof e;
              })(n);
      }
      function L(n, e, t) {
        return (
          (e = (function QY(n) {
            var e = (function KY(n, e) {
              if ("object" !== Ju(n) || null === n) return n;
              var t = n[Symbol.toPrimitive];
              if (void 0 !== t) {
                var i = t.call(n, e || "default");
                if ("object" !== Ju(i)) return i;
                throw new TypeError(
                  "@@toPrimitive must return a primitive value.",
                );
              }
              return ("string" === e ? String : Number)(n);
            })(n, "string");
            return "symbol" === Ju(e) ? e : String(e);
          })(e)) in n
            ? Object.defineProperty(n, e, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (n[e] = t),
          n
        );
      }
      const JY = ["addListener", "removeListener"],
        eZ = ["addEventListener", "removeEventListener"],
        tZ = ["on", "off"];
      function Ks(n, e, t, i) {
        if ((gt(t) && ((i = t), (t = void 0)), i))
          return Ks(n, e, t).pipe(jv(i));
        const [r, s] = (function rZ(n) {
          return gt(n.addEventListener) && gt(n.removeEventListener);
        })(n)
          ? eZ.map((o) => (a) => n[o](e, a, t))
          : (function nZ(n) {
              return gt(n.addListener) && gt(n.removeListener);
            })(n)
          ? JY.map(S1(n, e))
          : (function iZ(n) {
              return gt(n.on) && gt(n.off);
            })(n)
          ? tZ.map(S1(n, e))
          : [];
        if (!r && Dm(n)) return An((o) => Ks(o, e, t))(qn(n));
        if (!r) throw new TypeError("Invalid event target");
        return new Yt((o) => {
          const a = (...l) => o.next(1 < l.length ? l : l[0]);
          return r(a), () => s(a);
        });
      }
      function S1(n, e) {
        return (t) => (i) => n[t](e, i);
      }
      let sZ = (() => {
          class n {
            constructor(t, i) {
              L(this, "_elementRef", void 0),
                L(this, "_renderer", void 0),
                L(this, "collapseClass", !0),
                L(this, "collapseShow", new Rt()),
                L(this, "collapseShown", new Rt()),
                L(this, "collapseHide", new Rt()),
                L(this, "collapseHidden", new Rt()),
                L(this, "_collapsed", !0),
                L(this, "_isTransitioning", !1),
                (this._elementRef = t),
                (this._renderer = i);
            }
            set collapsed(t) {
              t !== this._collapsed &&
                (t ? this.hide() : this.show(), (this._collapsed = t));
            }
            get collapsed() {
              return this._collapsed;
            }
            get host() {
              return this._elementRef.nativeElement;
            }
            show() {
              if (this._isTransitioning || !this.collapsed) return;
              this.collapseShow.emit(this),
                this._renderer.removeClass(this.host, "collapse"),
                this._renderer.addClass(this.host, "collapsing"),
                this._renderer.setStyle(this.host, "height", "0px"),
                (this._isTransitioning = !0);
              const t = this.host.scrollHeight;
              Ks(this.host, "transitionend")
                .pipe(xi(1))
                .subscribe(() => {
                  (this._isTransitioning = !1),
                    (this.collapsed = !1),
                    this._renderer.removeClass(this.host, "collapsing"),
                    this._renderer.addClass(this.host, "collapse"),
                    this._renderer.addClass(this.host, "show"),
                    this._renderer.removeStyle(this.host, "height"),
                    this.collapseShown.emit(this);
                }),
                this._emulateTransitionEnd(this.host, 350),
                this._renderer.setStyle(this.host, "height", `${t}px`);
            }
            hide() {
              if (this._isTransitioning || this.collapsed) return;
              this.collapseHide.emit(this);
              const t = this.host.getBoundingClientRect().height;
              this._renderer.setStyle(this.host, "height", `${t}px`),
                this._reflow(this.host),
                this._renderer.addClass(this.host, "collapsing"),
                this._renderer.removeClass(this.host, "collapse"),
                this._renderer.removeClass(this.host, "show"),
                (this._isTransitioning = !0),
                Ks(this.host, "transitionend")
                  .pipe(xi(1))
                  .subscribe(() => {
                    this._renderer.removeClass(this.host, "collapsing"),
                      this._renderer.addClass(this.host, "collapse"),
                      (this._isTransitioning = !1),
                      (this.collapsed = !0),
                      this.collapseHidden.emit(this);
                  }),
                this._renderer.removeStyle(this.host, "height"),
                this._emulateTransitionEnd(this.host, 350);
            }
            toggle() {
              this._isTransitioning ||
                ((this.collapsed = !this.collapsed),
                this.collapsed ? this.hide() : this.show());
            }
            _reflow(t) {
              return t.offsetHeight;
            }
            _emulateTransitionEnd(t, i) {
              let r = !1;
              const o = i + 5;
              Ks(t, "transitionend")
                .pipe(xi(1))
                .subscribe(() => {
                  r = !0;
                }),
                setTimeout(() => {
                  r || t.dispatchEvent(new Event("transitionend"));
                }, o);
            }
          }
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)(re(Rn), re(or));
            }),
            L(
              n,
              "\u0275dir",
              Ue({
                type: n,
                selectors: [["", "mdbCollapse", ""]],
                hostVars: 2,
                hostBindings: function (t, i) {
                  2 & t && Za("collapse", i.collapseClass);
                },
                inputs: { collapsed: "collapsed" },
                outputs: {
                  collapseShow: "collapseShow",
                  collapseShown: "collapseShown",
                  collapseHide: "collapseHide",
                  collapseHidden: "collapseHidden",
                },
                exportAs: ["mdbCollapse"],
              }),
            ),
            n
          );
        })(),
        E1 = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({})),
            n
          );
        })(),
        Q0 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Hi({
              type: n,
              selectors: [["app-header"]],
              decls: 24,
              vars: 0,
              consts: [
                [1, "navbar", "navbar-expand-lg", "navbar-light", "bg-light"],
                [1, "container"],
                ["href", "home", 1, "navbar-brand", "me-2"],
                [
                  "src",
                  "../../../assets/img/photo_5873190219493260807_c.jpg",
                  "height",
                  "46",
                  "alt",
                  "",
                  "loading",
                  "lazy",
                  2,
                  "margin-top",
                  "-1px",
                ],
                [2, "color", "rgb(255, 174, 0)"],
                [
                  "type",
                  "button",
                  "aria-expanded",
                  "false",
                  "aria-label",
                  "Toggle navigation",
                  1,
                  "navbar-toggler",
                  3,
                  "click",
                ],
                [1, "fas", "fa-bars"],
                [
                  "id",
                  "navbarButtonsExample",
                  "mdbCollapse",
                  "",
                  1,
                  "collapse",
                  "navbar-collapse",
                ],
                ["buttonsNav", "mdbCollapse"],
                [1, "navbar-nav", "me-auto", "mb-2", "mb-lg-0"],
                [1, "nav-item"],
                ["href", "home", 1, "nav-link"],
                ["href", "team", 1, "nav-link"],
                ["href", "projects", 1, "nav-link"],
                [1, "d-flex", "align-items-center"],
                ["type", "button", 1, "btn", "btn-primary", "me-3"],
              ],
              template: function (t, i) {
                if (1 & t) {
                  const r = (function SC() {
                    return ne();
                  })();
                  tt(0, "nav", 0)(1, "div", 1)(2, "a", 2),
                    xt(3, "img", 3),
                    Nt(4, " INGE"),
                    tt(5, "span", 4),
                    Nt(6, "GNO"),
                    ot()(),
                    tt(7, "button", 5),
                    Fn("click", function () {
                      return (
                        (function ES(n) {
                          return (Ge.lFrame.contextLView = n), n[an];
                        })(r),
                        (function CS(n) {
                          return (Ge.lFrame.contextLView = null), n;
                        })(
                          (function vC(n) {
                            return (function ya(n, e) {
                              return n[e];
                            })(
                              (function uk() {
                                return Ge.lFrame.contextLView;
                              })(),
                              dt + n,
                            );
                          })(10).toggle(),
                        )
                      );
                    }),
                    xt(8, "i", 6),
                    ot(),
                    tt(9, "div", 7, 8)(11, "ul", 9)(12, "li", 10)(13, "a", 11),
                    Nt(14, "Home"),
                    ot()(),
                    tt(15, "li", 10)(16, "a", 12),
                    Nt(17, "Team"),
                    ot()(),
                    tt(18, "li", 10)(19, "a", 13),
                    Nt(20, "Projects"),
                    ot()()(),
                    tt(21, "div", 14)(22, "button", 15),
                    Nt(23, " Login "),
                    ot()()()()();
                }
              },
              dependencies: [sZ],
            })),
            n
          );
        })(),
        C1 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Hi({
              type: n,
              selectors: [["app-footer"]],
              decls: 56,
              vars: 0,
              consts: [
                [1, "text-center", "text-lg-start", "bg-light", "text-muted"],
                [
                  1,
                  "d-flex",
                  "justify-content-center",
                  "justify-content-lg-between",
                  "p-4",
                  "border-bottom",
                ],
                [1, "me-5", "d-none", "d-lg-block"],
                ["href", "", "role", "button", 1, "me-4", "text-reset"],
                [1, "fab", "fa-twitter", 2, "color", "#55acee"],
                [1, "fab", "fa-instagram", 2, "color", "#ac2bac"],
                [1, "fab", "fa-linkedin-in", 2, "color", "#0082ca"],
                [1, "fab", "fa-github", 2, "color", "#333333"],
                [1, "fab", "fa-google", 2, "color", "#dd4b39"],
                [1, ""],
                [1, "container", "text-center", "text-md-start", "mt-5"],
                [1, "row", "mt-3"],
                [1, "col-md-3", "col-lg-4", "col-xl-3", "mx-auto", "mb-4"],
                [1, "text-uppercase", "fw-bold", "mb-4"],
                [1, "fas", "fa-terminal", "me-3"],
                [1, "fas", "fa-minus"],
                [1, "col-md-2", "col-lg-2", "col-xl-2", "mx-auto", "mb-4"],
                [1, "fas", "fa-link", "me-3"],
                ["href", "#!", 1, "text-reset"],
                [
                  1,
                  "col-md-4",
                  "col-lg-3",
                  "col-xl-3",
                  "mx-auto",
                  "mb-md-0",
                  "mb-4",
                ],
                [1, "fas", "fa-location-dot", "me-3"],
                [1, "fas", "fa-envelope", "me-3"],
                [
                  1,
                  "text-center",
                  "p-4",
                  2,
                  "background-color",
                  "rgba(0, 0, 0, 0.05)",
                ],
                [
                  "href",
                  "https://mdbootstrap.com/",
                  1,
                  "text-reset",
                  "fw-bold",
                ],
              ],
              template: function (t, i) {
                1 & t &&
                  (tt(0, "footer", 0)(1, "section", 1)(2, "div", 2)(3, "span"),
                  Nt(4, "Get connected with us on social networks:"),
                  ot()(),
                  tt(5, "div")(6, "a", 3),
                  xt(7, "i", 4),
                  ot(),
                  tt(8, "a", 3),
                  xt(9, "i", 5),
                  ot(),
                  tt(10, "a", 3),
                  xt(11, "i", 6),
                  ot(),
                  tt(12, "a", 3),
                  xt(13, "i", 7),
                  ot(),
                  tt(14, "a", 3),
                  xt(15, "i", 8),
                  ot()()(),
                  tt(16, "section", 9)(17, "div", 10)(18, "div", 11)(
                    19,
                    "div",
                    12,
                  )(20, "h6", 13),
                  xt(21, "i", 14),
                  Nt(22, "Team "),
                  ot(),
                  tt(23, "p"),
                  Nt(24, " Avigo Federico "),
                  xt(25, "i", 15),
                  Nt(26, " Dobrianskiy Sergio "),
                  xt(27, "i", 15),
                  Nt(28, " Giacobbo Nicola "),
                  xt(29, "i", 15),
                  Nt(30, " Montresor Riccarto "),
                  xt(31, "i", 15),
                  Nt(32, " Taccinelli Francesco "),
                  ot()(),
                  tt(33, "div", 16)(34, "h6", 13),
                  xt(35, "i", 17),
                  Nt(36, " Links "),
                  ot(),
                  tt(37, "p")(38, "a", 18),
                  Nt(39, " C. S. Galileo"),
                  ot()(),
                  tt(40, "p")(41, "a", 18),
                  Nt(42, " Aria"),
                  ot()()(),
                  tt(43, "div", 19)(44, "h6", 13),
                  Nt(45, " Contact "),
                  ot(),
                  tt(46, "p"),
                  xt(47, "i", 20),
                  Nt(48, " Via della segheria 5, Montorio, VR, IT"),
                  ot(),
                  tt(49, "p"),
                  xt(50, "i", 21),
                  Nt(51, " ingegno@csgalileo.net "),
                  ot()()()()(),
                  tt(52, "div", 22),
                  Nt(53, " \xa9 2023 Copyright: "),
                  tt(54, "a", 23),
                  Nt(55, "Ingegno.com"),
                  ot()()());
              },
            })),
            n
          );
        })(),
        x1 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Hi({
              type: n,
              selectors: [["app-home"]],
              decls: 3,
              vars: 0,
              template: function (t, i) {
                1 & t &&
                  xt(0, "app-header")(1, "app-logo-box")(2, "app-footer");
              },
              dependencies: [ZY, Q0, C1],
            })),
            n
          );
        })(),
        T1 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Hi({
              type: n,
              selectors: [["app-page-not-found"]],
              decls: 11,
              vars: 0,
              consts: [
                [1, "row", 2, "padding-top", "5%"],
                [1, "card", "mx-auto", "text-center", 2, "width", "80%"],
                [1, "card-header"],
                [
                  "src",
                  "./assets/img/404.jpg",
                  "alt",
                  "Stony Beach",
                  1,
                  "card-img",
                ],
                [1, "card-body"],
                [1, "card-text"],
                ["href", "#", 1, "btn", "btn-secondary"],
              ],
              template: function (t, i) {
                1 & t &&
                  (xt(0, "app-header"),
                  tt(1, "div", 0)(2, "div", 1)(3, "h1", 2),
                  Nt(4, "Error"),
                  ot(),
                  xt(5, "img", 3),
                  tt(6, "div", 4)(7, "h3", 5),
                  Nt(
                    8,
                    "It looks like the page does not exist. Check the url and try again",
                  ),
                  ot(),
                  tt(9, "a", 6),
                  Nt(10, "Back to home"),
                  ot()()()());
              },
              dependencies: [Q0],
            })),
            n
          );
        })(),
        oZ = (() => {
          class n {
            ngOnInit() {
              console.log(this.mate);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Hi({
              type: n,
              selectors: [["app-profile"]],
              inputs: { mate: "mate" },
              decls: 18,
              vars: 4,
              consts: [
                [1, "card", "profile-card"],
                [1, "background-block"],
                ["alt", "profile-sample1", 1, "background", 3, "src"],
                [1, "profile-thumb-block"],
                ["alt", "profile-image", 1, "profile", 3, "src"],
                [1, "card-content"],
                [1, "icon-block"],
                ["href", "#"],
                [1, "fab", "fa-facebook"],
                [1, "fab", "fa-twitter"],
                [1, "fab", "fa-google-plus"],
              ],
              template: function (t, i) {
                1 & t &&
                  (tt(0, "div", 0)(1, "div", 1),
                  xt(2, "img", 2),
                  ot(),
                  tt(3, "div", 3),
                  xt(4, "img", 4),
                  ot(),
                  tt(5, "div", 5)(6, "h2"),
                  Nt(7),
                  ot(),
                  tt(8, "h3")(9, "small"),
                  Nt(10),
                  ot()(),
                  tt(11, "div", 6)(12, "a", 7),
                  xt(13, "i", 8),
                  ot(),
                  tt(14, "a", 7),
                  xt(15, "i", 9),
                  ot(),
                  tt(16, "a", 7),
                  xt(17, "i", 10),
                  ot()()()()),
                  2 & t &&
                    (Wi(2),
                    Ah("src", i.mate.bkg, ch),
                    Wi(2),
                    Ah("src", i.mate.img, ch),
                    Wi(3),
                    Ka(i.mate.name),
                    Wi(3),
                    Ka(i.mate.role));
              },
              styles: [
                '.profile-card[_ngcontent-%COMP%]{font-family:Open Sans,Arial,sans-serif;position:relative;float:left;overflow:hidden;width:100%;text-align:center;height:368px;border:none}.profile-card[_ngcontent-%COMP%]   .background-block[_ngcontent-%COMP%]{float:left;width:100%;height:200px;overflow:hidden}.profile-card[_ngcontent-%COMP%]   .background-block[_ngcontent-%COMP%]   .background[_ngcontent-%COMP%]{width:100%;vertical-align:top;opacity:.9;filter:blur(.5px);transform:scale(2.8)}.profile-card[_ngcontent-%COMP%]   .card-content[_ngcontent-%COMP%]{width:100%;padding:15px 25px;color:#232323;float:left;background:#efefef;height:50%;border-radius:0 0 5px 5px;position:relative;z-index:9999}.profile-card[_ngcontent-%COMP%]   .card-content[_ngcontent-%COMP%]:before{content:"";background:#efefef;width:120%;height:100%;left:11px;bottom:51px;position:absolute;z-index:-1;transform:rotate(-13deg)}.profile-card[_ngcontent-%COMP%]   .profile[_ngcontent-%COMP%]{border-radius:50%;position:absolute;bottom:50%;left:50%;max-width:100px;opacity:1;box-shadow:3px 3px 20px #00000080;border:2px solid rgb(255,255,255);transform:translate(-50%);z-index:99999}.profile-card[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{margin:0 0 5px;font-weight:600;font-size:25px}.profile-card[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]   small[_ngcontent-%COMP%]{display:block;font-size:15px;margin-top:10px}.profile-card[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{display:inline-block;font-size:16px;color:#232323;text-align:center;border:1px solid #232323;width:30px;height:30px;line-height:30px;border-radius:50%;margin:0 5px}.profile-card[_ngcontent-%COMP%]   .icon-block[_ngcontent-%COMP%]{float:left;width:100%;margin-top:15px}.profile-card[_ngcontent-%COMP%]   .icon-block[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none}.profile-card[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]:hover{background-color:#232323;color:#fff;text-decoration:none}',
              ],
            })),
            n
          );
        })();
      function aZ(n, e) {
        if (
          (1 & n && (tt(0, "div", 2), xt(1, "app-profile", 3), ot()), 2 & n)
        ) {
          const t = e.$implicit;
          Wi(1), yo("mate", t);
        }
      }
      const lZ = [
        { path: "", component: x1 },
        { path: "home", component: x1 },
        { path: "projects", component: T1 },
        {
          path: "team",
          component: (() => {
            class n {
              constructor() {
                this.teamMates = [
                  {
                    name: "Federico",
                    role: "Software Engineer",
                    img: "./assets/img/fa.png",
                    bkg: "https://images.pexels.com/photos/459225/pexels-photo-459225.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",
                  },
                  {
                    name: "Sergio",
                    role: "Frontend Developer",
                    img: "./assets/img/sd.png",
                    bkg: "https://images.pexels.com/photos/459225/pexels-photo-459225.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",
                  },
                  {
                    name: "Nicola",
                    role: "Backend Developer",
                    img: "./assets/img/ng.png",
                    bkg: "https://images.pexels.com/photos/459225/pexels-photo-459225.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",
                  },
                  {
                    name: "Riccardo",
                    role: "Full-stack Developer",
                    img: "./assets/img/rm.png",
                    bkg: "https://images.pexels.com/photos/459225/pexels-photo-459225.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",
                  },
                  {
                    name: "Francesco",
                    role: "Machine Learning Specialist",
                    img: "./assets/img/ft.png",
                    bkg: "https://images.pexels.com/photos/459225/pexels-photo-459225.jpeg?auto=compress&cs=tinysrgb&h=650&w=940",
                  },
                ];
              }
            }
            return (
              (n.ɵfac = function (t) {
                return new (t || n)();
              }),
              (n.ɵcmp = Hi({
                type: n,
                selectors: [["app-team"]],
                decls: 4,
                vars: 1,
                consts: [
                  [
                    1,
                    "row",
                    "row-cols-1",
                    "row-cols-md-3",
                    "g-4",
                    2,
                    "padding",
                    "5%",
                  ],
                  ["class", "col", 4, "ngFor", "ngForOf"],
                  [1, "col"],
                  [3, "mate"],
                ],
                template: function (t, i) {
                  1 & t &&
                    (xt(0, "app-header"),
                    tt(1, "div", 0),
                    y_(2, aZ, 2, 1, "div", 1),
                    ot(),
                    xt(3, "app-footer")),
                    2 & t && (Wi(2), yo("ngForOf", i.teamMates));
                },
                dependencies: [PD, Q0, C1, oZ],
                styles: [
                  '.profile-card-3[_ngcontent-%COMP%]{font-family:Open Sans,Arial,sans-serif;position:relative;float:left;overflow:hidden;width:100%;text-align:center;height:368px;border:none}.profile-card-3[_ngcontent-%COMP%]   .background-block[_ngcontent-%COMP%]{float:left;width:100%;height:200px;overflow:hidden}.profile-card-3[_ngcontent-%COMP%]   .background-block[_ngcontent-%COMP%]   .background[_ngcontent-%COMP%]{width:100%;vertical-align:top;opacity:.9;filter:blur(.5px);transform:scale(2.8)}.profile-card-3[_ngcontent-%COMP%]   .card-content[_ngcontent-%COMP%]{width:100%;padding:15px 25px;color:#232323;float:left;background:#efefef;height:50%;border-radius:0 0 5px 5px;position:relative;z-index:9999}.profile-card-3[_ngcontent-%COMP%]   .card-content[_ngcontent-%COMP%]:before{content:"";background:#efefef;width:120%;height:100%;left:11px;bottom:51px;position:absolute;z-index:-1;transform:rotate(-13deg)}.profile-card-3[_ngcontent-%COMP%]   .profile[_ngcontent-%COMP%]{border-radius:50%;position:absolute;bottom:50%;left:50%;max-width:100px;opacity:1;box-shadow:3px 3px 20px #00000080;border:2px solid rgb(255,255,255);transform:translate(-50%);z-index:99999}.profile-card-3[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{margin:0 0 5px;font-weight:600;font-size:25px}.profile-card-3[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]   small[_ngcontent-%COMP%]{display:block;font-size:15px;margin-top:10px}.profile-card-3[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{display:inline-block;font-size:16px;color:#232323;text-align:center;border:1px solid #232323;width:30px;height:30px;line-height:30px;border-radius:50%;margin:0 5px}.profile-card-3[_ngcontent-%COMP%]   .icon-block[_ngcontent-%COMP%]{float:left;width:100%;margin-top:15px}.profile-card-3[_ngcontent-%COMP%]   .icon-block[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none}.profile-card-3[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]:hover{background-color:#232323;color:#fff;text-decoration:none}',
                ],
              })),
              n
            );
          })(),
        },
        { path: "**", component: T1 },
      ];
      let cZ = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = Et({ type: n })),
          (n.ɵinj = bt({ imports: [pI.forRoot(lZ), pI] })),
          n
        );
      })();
      new ve("MdbAccordionItemBodyDirective"),
        new ve("MdbAccordionItemHeaderDirective");
      let hZ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci, E1] })),
            n
          );
        })(),
        mZ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci] })),
            n
          );
        })();
      function ed(n) {
        return null != n && "false" != `${n}`;
      }
      function D1(n) {
        return Array.isArray(n) ? n : [n];
      }
      function vn(n) {
        return null == n ? "" : "string" == typeof n ? n : `${n}px`;
      }
      const Ni = new ve("NgValueAccessor"),
        tc = new ve("CallSetDisabledState", {
          providedIn: "root",
          factory: () => Wp,
        }),
        Wp = "always";
      let mO = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({})),
            n
          );
        })(),
        mK = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({ imports: [mO] })),
            n
          );
        })(),
        Yp = (() => {
          class n {
            static withConfig(t) {
              return {
                ngModule: n,
                providers: [
                  { provide: tc, useValue: t.callSetDisabledState ?? Wp },
                ],
              };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({ imports: [mK] })),
            n
          );
        })();
      const _K = { provide: Ni, useExisting: Ot(() => yK), multi: !0 };
      class vK {
        constructor() {
          L(this, "element", void 0), L(this, "checked", void 0);
        }
      }
      let yK = (() => {
          class n {
            get checked() {
              return this._checked;
            }
            set checked(t) {
              this._checked = ed(t);
            }
            get value() {
              return this._value;
            }
            set value(t) {
              this._value = t;
            }
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              this._disabled = ed(t);
            }
            get isDisabled() {
              return this._disabled;
            }
            get isChecked() {
              return this._checked;
            }
            onCheckboxClick() {
              this.toggle();
            }
            onBlur() {
              this.onTouched();
            }
            constructor() {
              L(this, "_checked", !1),
                L(this, "_value", null),
                L(this, "_disabled", !1),
                L(this, "checkboxChange", new Rt()),
                L(this, "onChange", (t) => {}),
                L(this, "onTouched", () => {});
            }
            get changeEvent() {
              const t = new vK();
              return (t.element = this), (t.checked = this.checked), t;
            }
            toggle() {
              this.disabled ||
                ((this._checked = !this._checked),
                this.onChange(this.checked),
                this.onCheckboxChange());
            }
            onCheckboxChange() {
              this.checkboxChange.emit(this.changeEvent);
            }
            writeValue(t) {
              (this.value = t), (this.checked = !!t);
            }
            registerOnChange(t) {
              this.onChange = t;
            }
            registerOnTouched(t) {
              this.onTouched = t;
            }
            setDisabledState(t) {
              this.disabled = t;
            }
          }
          return (
            L(n, "ngAcceptInputType_checked", void 0),
            L(n, "ngAcceptInputType_disabled", void 0),
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(
              n,
              "\u0275dir",
              Ue({
                type: n,
                selectors: [["", "mdbCheckbox", ""]],
                hostVars: 2,
                hostBindings: function (t, i) {
                  1 & t &&
                    Fn("click", function () {
                      return i.onCheckboxClick();
                    })("blur", function () {
                      return i.onBlur();
                    }),
                    2 & t &&
                      Ph("disabled", i.isDisabled)("checked", i.isChecked);
                },
                inputs: {
                  checked: "checked",
                  value: "value",
                  disabled: "disabled",
                },
                outputs: { checkboxChange: "checkboxChange" },
                features: [Ht([_K])],
              }),
            ),
            n
          );
        })(),
        bK = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci, Yp] })),
            n
          );
        })();
      class MK extends Un {
        constructor(e, t) {
          super();
        }
        schedule(e, t = 0) {
          return this;
        }
      }
      const Zp = {
        setInterval(n, e, ...t) {
          const { delegate: i } = Zp;
          return i?.setInterval
            ? i.setInterval(n, e, ...t)
            : setInterval(n, e, ...t);
        },
        clearInterval(n) {
          const { delegate: e } = Zp;
          return (e?.clearInterval || clearInterval)(n);
        },
        delegate: void 0,
      };
      class yb extends MK {
        constructor(e, t) {
          super(e, t),
            (this.scheduler = e),
            (this.work = t),
            (this.pending = !1);
        }
        schedule(e, t = 0) {
          var i;
          if (this.closed) return this;
          this.state = e;
          const r = this.id,
            s = this.scheduler;
          return (
            null != r && (this.id = this.recycleAsyncId(s, r, t)),
            (this.pending = !0),
            (this.delay = t),
            (this.id =
              null !== (i = this.id) && void 0 !== i
                ? i
                : this.requestAsyncId(s, this.id, t)),
            this
          );
        }
        requestAsyncId(e, t, i = 0) {
          return Zp.setInterval(e.flush.bind(e, this), i);
        }
        recycleAsyncId(e, t, i = 0) {
          if (null != i && this.delay === i && !1 === this.pending) return t;
          null != t && Zp.clearInterval(t);
        }
        execute(e, t) {
          if (this.closed) return new Error("executing a cancelled action");
          this.pending = !1;
          const i = this._execute(e, t);
          if (i) return i;
          !1 === this.pending &&
            null != this.id &&
            (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }
        _execute(e, t) {
          let r,
            i = !1;
          try {
            this.work(e);
          } catch (s) {
            (i = !0),
              (r = s || new Error("Scheduled action threw falsy error"));
          }
          if (i) return this.unsubscribe(), r;
        }
        unsubscribe() {
          if (!this.closed) {
            const { id: e, scheduler: t } = this,
              { actions: i } = t;
            (this.work = this.state = this.scheduler = null),
              (this.pending = !1),
              ua(i, this),
              null != e && (this.id = this.recycleAsyncId(t, e, null)),
              (this.delay = null),
              super.unsubscribe();
          }
        }
      }
      const sd = {
          schedule(n) {
            let e = requestAnimationFrame,
              t = cancelAnimationFrame;
            const { delegate: i } = sd;
            i && ((e = i.requestAnimationFrame), (t = i.cancelAnimationFrame));
            const r = e((s) => {
              (t = void 0), n(s);
            });
            return new Un(() => t?.(r));
          },
          requestAnimationFrame(...n) {
            const { delegate: e } = sd;
            return (e?.requestAnimationFrame || requestAnimationFrame)(...n);
          },
          cancelAnimationFrame(...n) {
            const { delegate: e } = sd;
            return (e?.cancelAnimationFrame || cancelAnimationFrame)(...n);
          },
          delegate: void 0,
        },
        OO = { now: () => (OO.delegate || Date).now(), delegate: void 0 };
      class od {
        constructor(e, t = od.now) {
          (this.schedulerActionCtor = e), (this.now = t);
        }
        schedule(e, t = 0, i) {
          return new this.schedulerActionCtor(this, e).schedule(i, t);
        }
      }
      od.now = OO.now;
      class bb extends od {
        constructor(e, t = od.now) {
          super(e, t), (this.actions = []), (this._active = !1);
        }
        flush(e) {
          const { actions: t } = this;
          if (this._active) return void t.push(e);
          let i;
          this._active = !0;
          do {
            if ((i = e.execute(e.state, e.delay))) break;
          } while ((e = t.shift()));
          if (((this._active = !1), i)) {
            for (; (e = t.shift()); ) e.unsubscribe();
            throw i;
          }
        }
      }
      new (class wK extends bb {
        flush(e) {
          this._active = !0;
          const t = this._scheduled;
          this._scheduled = void 0;
          const { actions: i } = this;
          let r;
          e = e || i.shift();
          do {
            if ((r = e.execute(e.state, e.delay))) break;
          } while ((e = i[0]) && e.id === t && i.shift());
          if (((this._active = !1), r)) {
            for (; (e = i[0]) && e.id === t && i.shift(); ) e.unsubscribe();
            throw r;
          }
        }
      })(
        class SK extends yb {
          constructor(e, t) {
            super(e, t), (this.scheduler = e), (this.work = t);
          }
          requestAsyncId(e, t, i = 0) {
            return null !== i && i > 0
              ? super.requestAsyncId(e, t, i)
              : (e.actions.push(this),
                e._scheduled ||
                  (e._scheduled = sd.requestAnimationFrame(() =>
                    e.flush(void 0),
                  )));
          }
          recycleAsyncId(e, t, i = 0) {
            var r;
            if (null != i ? i > 0 : this.delay > 0)
              return super.recycleAsyncId(e, t, i);
            const { actions: s } = e;
            null != t &&
              (null === (r = s[s.length - 1]) || void 0 === r
                ? void 0
                : r.id) !== t &&
              (sd.cancelAnimationFrame(t), (e._scheduled = void 0));
          }
        },
      );
      let Mb,
        CK = 1;
      const Kp = {};
      function NO(n) {
        return n in Kp && (delete Kp[n], !0);
      }
      const xK = {
          setImmediate(n) {
            const e = CK++;
            return (
              (Kp[e] = !0),
              Mb || (Mb = Promise.resolve()),
              Mb.then(() => NO(e) && n()),
              e
            );
          },
          clearImmediate(n) {
            NO(n);
          },
        },
        { setImmediate: TK, clearImmediate: DK } = xK,
        Qp = {
          setImmediate(...n) {
            const { delegate: e } = Qp;
            return (e?.setImmediate || TK)(...n);
          },
          clearImmediate(n) {
            const { delegate: e } = Qp;
            return (e?.clearImmediate || DK)(n);
          },
          delegate: void 0,
        },
        LO =
          (new (class IK extends bb {
            flush(e) {
              this._active = !0;
              const t = this._scheduled;
              this._scheduled = void 0;
              const { actions: i } = this;
              let r;
              e = e || i.shift();
              do {
                if ((r = e.execute(e.state, e.delay))) break;
              } while ((e = i[0]) && e.id === t && i.shift());
              if (((this._active = !1), r)) {
                for (; (e = i[0]) && e.id === t && i.shift(); ) e.unsubscribe();
                throw r;
              }
            }
          })(
            class AK extends yb {
              constructor(e, t) {
                super(e, t), (this.scheduler = e), (this.work = t);
              }
              requestAsyncId(e, t, i = 0) {
                return null !== i && i > 0
                  ? super.requestAsyncId(e, t, i)
                  : (e.actions.push(this),
                    e._scheduled ||
                      (e._scheduled = Qp.setImmediate(
                        e.flush.bind(e, void 0),
                      )));
              }
              recycleAsyncId(e, t, i = 0) {
                var r;
                if (null != i ? i > 0 : this.delay > 0)
                  return super.recycleAsyncId(e, t, i);
                const { actions: s } = e;
                null != t &&
                  (null === (r = s[s.length - 1]) || void 0 === r
                    ? void 0
                    : r.id) !== t &&
                  (Qp.clearImmediate(t),
                  e._scheduled === t && (e._scheduled = void 0));
              }
            },
          ),
          new bb(yb)),
        PK = LO;
      function FO(n, e = LO) {
        return (function OK(n) {
          return fn((e, t) => {
            let i = !1,
              r = null,
              s = null,
              o = !1;
            const a = () => {
                if ((s?.unsubscribe(), (s = null), i)) {
                  i = !1;
                  const c = r;
                  (r = null), t.next(c);
                }
                o && t.complete();
              },
              l = () => {
                (s = null), o && t.complete();
              };
            e.subscribe(
              tn(
                t,
                (c) => {
                  (i = !0), (r = c), s || qn(n(c)).subscribe((s = tn(t, a, l)));
                },
                () => {
                  (o = !0), (!i || !s || s.closed) && t.complete();
                },
              ),
            );
          });
        })(() =>
          (function LK(n = 0, e, t = PK) {
            let i = -1;
            return (
              null != e && (TM(e) ? (t = e) : (i = e)),
              new Yt((r) => {
                let s = (function NK(n) {
                  return n instanceof Date && !isNaN(n);
                })(n)
                  ? +n - t.now()
                  : n;
                s < 0 && (s = 0);
                let o = 0;
                return t.schedule(function () {
                  r.closed ||
                    (r.next(o++),
                    0 <= i ? this.schedule(void 0, i) : r.complete());
                }, s);
              })
            );
          })(n, e),
        );
      }
      let Sb;
      try {
        Sb = typeof Intl < "u" && Intl.v8BreakIterator;
      } catch {
        Sb = !1;
      }
      let ia,
        nc = (() => {
          class n {
            constructor(t) {
              (this._platformId = t),
                (this.isBrowser = this._platformId
                  ? (function q4(n) {
                      return n === UD;
                    })(this._platformId)
                  : "object" == typeof document && !!document),
                (this.EDGE =
                  this.isBrowser && /(edge)/i.test(navigator.userAgent)),
                (this.TRIDENT =
                  this.isBrowser &&
                  /(msie|trident)/i.test(navigator.userAgent)),
                (this.BLINK =
                  this.isBrowser &&
                  !(!window.chrome && !Sb) &&
                  typeof CSS < "u" &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.WEBKIT =
                  this.isBrowser &&
                  /AppleWebKit/i.test(navigator.userAgent) &&
                  !this.BLINK &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.IOS =
                  this.isBrowser &&
                  /iPad|iPhone|iPod/.test(navigator.userAgent) &&
                  !("MSStream" in window)),
                (this.FIREFOX =
                  this.isBrowser &&
                  /(firefox|minefield)/i.test(navigator.userAgent)),
                (this.ANDROID =
                  this.isBrowser &&
                  /android/i.test(navigator.userAgent) &&
                  !this.TRIDENT),
                (this.SAFARI =
                  this.isBrowser &&
                  /safari/i.test(navigator.userAgent) &&
                  this.WEBKIT);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(mo));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      function kK() {
        if (null == ia) {
          if (
            "object" != typeof document ||
            !document ||
            "function" != typeof Element ||
            !Element
          )
            return (ia = !1), ia;
          if ("scrollBehavior" in document.documentElement.style) ia = !0;
          else {
            const n = Element.prototype.scrollTo;
            ia = !!n && !/\{\s*\[native code\]\s*\}/.test(n.toString());
          }
        }
        return ia;
      }
      function BO(n) {
        return n.composedPath ? n.composedPath()[0] : n.target;
      }
      function VO() {
        return (
          (typeof __karma__ < "u" && !!__karma__) ||
          (typeof jasmine < "u" && !!jasmine) ||
          (typeof jest < "u" && !!jest) ||
          (typeof Mocha < "u" && !!Mocha)
        );
      }
      const BK = new ve("cdk-dir-doc", {
          providedIn: "root",
          factory: function VK() {
            return Te(kt);
          },
        }),
        HK =
          /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
      let GK = (() => {
          class n {
            constructor(t) {
              (this.value = "ltr"),
                (this.change = new Rt()),
                t &&
                  (this.value = (function zK(n) {
                    const e = n?.toLowerCase() || "";
                    return "auto" === e &&
                      typeof navigator < "u" &&
                      navigator?.language
                      ? HK.test(navigator.language)
                        ? "rtl"
                        : "ltr"
                      : "rtl" === e
                      ? "rtl"
                      : "ltr";
                  })(
                    (t.body ? t.body.dir : null) ||
                      (t.documentElement ? t.documentElement.dir : null) ||
                      "ltr",
                  ));
            }
            ngOnDestroy() {
              this.change.complete();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(BK, 8));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        Eb = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({})),
            n
          );
        })(),
        $K = (() => {
          class n {
            constructor(t, i, r) {
              (this._ngZone = t),
                (this._platform = i),
                (this._scrolled = new en()),
                (this._globalSubscription = null),
                (this._scrolledCount = 0),
                (this.scrollContainers = new Map()),
                (this._document = r);
            }
            register(t) {
              this.scrollContainers.has(t) ||
                this.scrollContainers.set(
                  t,
                  t.elementScrolled().subscribe(() => this._scrolled.next(t)),
                );
            }
            deregister(t) {
              const i = this.scrollContainers.get(t);
              i && (i.unsubscribe(), this.scrollContainers.delete(t));
            }
            scrolled(t = 20) {
              return this._platform.isBrowser
                ? new Yt((i) => {
                    this._globalSubscription || this._addGlobalListener();
                    const r =
                      t > 0
                        ? this._scrolled.pipe(FO(t)).subscribe(i)
                        : this._scrolled.subscribe(i);
                    return (
                      this._scrolledCount++,
                      () => {
                        r.unsubscribe(),
                          this._scrolledCount--,
                          this._scrolledCount || this._removeGlobalListener();
                      }
                    );
                  })
                : We();
            }
            ngOnDestroy() {
              this._removeGlobalListener(),
                this.scrollContainers.forEach((t, i) => this.deregister(i)),
                this._scrolled.complete();
            }
            ancestorScrolled(t, i) {
              const r = this.getAncestorScrollContainers(t);
              return this.scrolled(i).pipe(Yi((s) => !s || r.indexOf(s) > -1));
            }
            getAncestorScrollContainers(t) {
              const i = [];
              return (
                this.scrollContainers.forEach((r, s) => {
                  this._scrollableContainsElement(s, t) && i.push(s);
                }),
                i
              );
            }
            _getWindow() {
              return this._document.defaultView || window;
            }
            _scrollableContainsElement(t, i) {
              let r = (function _Z(n) {
                  return n instanceof Rn ? n.nativeElement : n;
                })(i),
                s = t.getElementRef().nativeElement;
              do {
                if (r == s) return !0;
              } while ((r = r.parentElement));
              return !1;
            }
            _addGlobalListener() {
              this._globalSubscription = this._ngZone.runOutsideAngular(() =>
                Ks(this._getWindow().document, "scroll").subscribe(() =>
                  this._scrolled.next(),
                ),
              );
            }
            _removeGlobalListener() {
              this._globalSubscription &&
                (this._globalSubscription.unsubscribe(),
                (this._globalSubscription = null));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(yt), se(nc), se(kt, 8));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        HO = (() => {
          class n {
            constructor(t, i, r) {
              (this._platform = t),
                (this._change = new en()),
                (this._changeListener = (s) => {
                  this._change.next(s);
                }),
                (this._document = r),
                i.runOutsideAngular(() => {
                  if (t.isBrowser) {
                    const s = this._getWindow();
                    s.addEventListener("resize", this._changeListener),
                      s.addEventListener(
                        "orientationchange",
                        this._changeListener,
                      );
                  }
                  this.change().subscribe(() => (this._viewportSize = null));
                });
            }
            ngOnDestroy() {
              if (this._platform.isBrowser) {
                const t = this._getWindow();
                t.removeEventListener("resize", this._changeListener),
                  t.removeEventListener(
                    "orientationchange",
                    this._changeListener,
                  );
              }
              this._change.complete();
            }
            getViewportSize() {
              this._viewportSize || this._updateViewportSize();
              const t = {
                width: this._viewportSize.width,
                height: this._viewportSize.height,
              };
              return this._platform.isBrowser || (this._viewportSize = null), t;
            }
            getViewportRect() {
              const t = this.getViewportScrollPosition(),
                { width: i, height: r } = this.getViewportSize();
              return {
                top: t.top,
                left: t.left,
                bottom: t.top + r,
                right: t.left + i,
                height: r,
                width: i,
              };
            }
            getViewportScrollPosition() {
              if (!this._platform.isBrowser) return { top: 0, left: 0 };
              const t = this._document,
                i = this._getWindow(),
                r = t.documentElement,
                s = r.getBoundingClientRect();
              return {
                top:
                  -s.top || t.body.scrollTop || i.scrollY || r.scrollTop || 0,
                left:
                  -s.left ||
                  t.body.scrollLeft ||
                  i.scrollX ||
                  r.scrollLeft ||
                  0,
              };
            }
            change(t = 20) {
              return t > 0 ? this._change.pipe(FO(t)) : this._change;
            }
            _getWindow() {
              return this._document.defaultView || window;
            }
            _updateViewportSize() {
              const t = this._getWindow();
              this._viewportSize = this._platform.isBrowser
                ? { width: t.innerWidth, height: t.innerHeight }
                : { width: 0, height: 0 };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(nc), se(yt), se(kt, 8));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        zO = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({})),
            n
          );
        })(),
        GO = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({ imports: [Eb, zO, Eb, zO] })),
            n
          );
        })();
      function Cb(n) {
        return fn((e, t) => {
          qn(n).subscribe(tn(t, () => t.complete(), vm)),
            !t.closed && e.subscribe(t);
        });
      }
      class xb {
        attach(e) {
          return (this._attachedHost = e), e.attach(this);
        }
        detach() {
          let e = this._attachedHost;
          null != e && ((this._attachedHost = null), e.detach());
        }
        get isAttached() {
          return null != this._attachedHost;
        }
        setAttachedHost(e) {
          this._attachedHost = e;
        }
      }
      class Tb extends xb {
        constructor(e, t, i, r, s) {
          super(),
            (this.component = e),
            (this.viewContainerRef = t),
            (this.injector = i),
            (this.componentFactoryResolver = r),
            (this.projectableNodes = s);
        }
      }
      class WO extends xb {
        constructor(e, t, i, r) {
          super(),
            (this.templateRef = e),
            (this.viewContainerRef = t),
            (this.context = i),
            (this.injector = r);
        }
        get origin() {
          return this.templateRef.elementRef;
        }
        attach(e, t = this.context) {
          return (this.context = t), super.attach(e);
        }
        detach() {
          return (this.context = void 0), super.detach();
        }
      }
      class qK extends xb {
        constructor(e) {
          super(), (this.element = e instanceof Rn ? e.nativeElement : e);
        }
      }
      class $O {
        constructor() {
          (this._isDisposed = !1), (this.attachDomPortal = null);
        }
        hasAttached() {
          return !!this._attachedPortal;
        }
        attach(e) {
          return e instanceof Tb
            ? ((this._attachedPortal = e), this.attachComponentPortal(e))
            : e instanceof WO
            ? ((this._attachedPortal = e), this.attachTemplatePortal(e))
            : this.attachDomPortal && e instanceof qK
            ? ((this._attachedPortal = e), this.attachDomPortal(e))
            : void 0;
        }
        detach() {
          this._attachedPortal &&
            (this._attachedPortal.setAttachedHost(null),
            (this._attachedPortal = null)),
            this._invokeDisposeFn();
        }
        dispose() {
          this.hasAttached() && this.detach(),
            this._invokeDisposeFn(),
            (this._isDisposed = !0);
        }
        setDisposeFn(e) {
          this._disposeFn = e;
        }
        _invokeDisposeFn() {
          this._disposeFn && (this._disposeFn(), (this._disposeFn = null));
        }
      }
      class XK extends $O {
        constructor(e, t, i, r, s) {
          super(),
            (this.outletElement = e),
            (this._componentFactoryResolver = t),
            (this._appRef = i),
            (this._defaultInjector = r),
            (this.attachDomPortal = (o) => {
              const a = o.element,
                l = this._document.createComment("dom-portal");
              a.parentNode.insertBefore(l, a),
                this.outletElement.appendChild(a),
                (this._attachedPortal = o),
                super.setDisposeFn(() => {
                  l.parentNode && l.parentNode.replaceChild(a, l);
                });
            }),
            (this._document = s);
        }
        attachComponentPortal(e) {
          const i = (
            e.componentFactoryResolver || this._componentFactoryResolver
          ).resolveComponentFactory(e.component);
          let r;
          return (
            e.viewContainerRef
              ? ((r = e.viewContainerRef.createComponent(
                  i,
                  e.viewContainerRef.length,
                  e.injector || e.viewContainerRef.injector,
                  e.projectableNodes || void 0,
                )),
                this.setDisposeFn(() => r.destroy()))
              : ((r = i.create(e.injector || this._defaultInjector || fi.NULL)),
                this._appRef.attachView(r.hostView),
                this.setDisposeFn(() => {
                  this._appRef.viewCount > 0 &&
                    this._appRef.detachView(r.hostView),
                    r.destroy();
                })),
            this.outletElement.appendChild(this._getComponentRootNode(r)),
            (this._attachedPortal = e),
            r
          );
        }
        attachTemplatePortal(e) {
          let t = e.viewContainerRef,
            i = t.createEmbeddedView(e.templateRef, e.context, {
              injector: e.injector,
            });
          return (
            i.rootNodes.forEach((r) => this.outletElement.appendChild(r)),
            i.detectChanges(),
            this.setDisposeFn(() => {
              let r = t.indexOf(i);
              -1 !== r && t.remove(r);
            }),
            (this._attachedPortal = e),
            i
          );
        }
        dispose() {
          super.dispose(), this.outletElement.remove();
        }
        _getComponentRootNode(e) {
          return e.hostView.rootNodes[0];
        }
      }
      let jO = (() => {
          class n extends $O {
            constructor(t, i, r) {
              super(),
                (this._componentFactoryResolver = t),
                (this._viewContainerRef = i),
                (this._isInitialized = !1),
                (this.attached = new Rt()),
                (this.attachDomPortal = (s) => {
                  const o = s.element,
                    a = this._document.createComment("dom-portal");
                  s.setAttachedHost(this),
                    o.parentNode.insertBefore(a, o),
                    this._getRootNode().appendChild(o),
                    (this._attachedPortal = s),
                    super.setDisposeFn(() => {
                      a.parentNode && a.parentNode.replaceChild(o, a);
                    });
                }),
                (this._document = r);
            }
            get portal() {
              return this._attachedPortal;
            }
            set portal(t) {
              (this.hasAttached() && !t && !this._isInitialized) ||
                (this.hasAttached() && super.detach(),
                t && super.attach(t),
                (this._attachedPortal = t || null));
            }
            get attachedRef() {
              return this._attachedRef;
            }
            ngOnInit() {
              this._isInitialized = !0;
            }
            ngOnDestroy() {
              super.dispose(),
                (this._attachedRef = this._attachedPortal = null);
            }
            attachComponentPortal(t) {
              t.setAttachedHost(this);
              const i =
                  null != t.viewContainerRef
                    ? t.viewContainerRef
                    : this._viewContainerRef,
                s = (
                  t.componentFactoryResolver || this._componentFactoryResolver
                ).resolveComponentFactory(t.component),
                o = i.createComponent(
                  s,
                  i.length,
                  t.injector || i.injector,
                  t.projectableNodes || void 0,
                );
              return (
                i !== this._viewContainerRef &&
                  this._getRootNode().appendChild(o.hostView.rootNodes[0]),
                super.setDisposeFn(() => o.destroy()),
                (this._attachedPortal = t),
                (this._attachedRef = o),
                this.attached.emit(o),
                o
              );
            }
            attachTemplatePortal(t) {
              t.setAttachedHost(this);
              const i = this._viewContainerRef.createEmbeddedView(
                t.templateRef,
                t.context,
                { injector: t.injector },
              );
              return (
                super.setDisposeFn(() => this._viewContainerRef.clear()),
                (this._attachedPortal = t),
                (this._attachedRef = i),
                this.attached.emit(i),
                i
              );
            }
            _getRootNode() {
              const t = this._viewContainerRef.element.nativeElement;
              return t.nodeType === t.ELEMENT_NODE ? t : t.parentNode;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(go), re(ji), re(kt));
            }),
            (n.ɵdir = Ue({
              type: n,
              selectors: [["", "cdkPortalOutlet", ""]],
              inputs: { portal: ["cdkPortalOutlet", "portal"] },
              outputs: { attached: "attached" },
              exportAs: ["cdkPortalOutlet"],
              features: [It],
            })),
            n
          );
        })(),
        Db = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({})),
            n
          );
        })();
      const qO = kK();
      class YK {
        constructor(e, t) {
          (this._viewportRuler = e),
            (this._previousHTMLStyles = { top: "", left: "" }),
            (this._isEnabled = !1),
            (this._document = t);
        }
        attach() {}
        enable() {
          if (this._canBeEnabled()) {
            const e = this._document.documentElement;
            (this._previousScrollPosition =
              this._viewportRuler.getViewportScrollPosition()),
              (this._previousHTMLStyles.left = e.style.left || ""),
              (this._previousHTMLStyles.top = e.style.top || ""),
              (e.style.left = vn(-this._previousScrollPosition.left)),
              (e.style.top = vn(-this._previousScrollPosition.top)),
              e.classList.add("cdk-global-scrollblock"),
              (this._isEnabled = !0);
          }
        }
        disable() {
          if (this._isEnabled) {
            const e = this._document.documentElement,
              i = e.style,
              r = this._document.body.style,
              s = i.scrollBehavior || "",
              o = r.scrollBehavior || "";
            (this._isEnabled = !1),
              (i.left = this._previousHTMLStyles.left),
              (i.top = this._previousHTMLStyles.top),
              e.classList.remove("cdk-global-scrollblock"),
              qO && (i.scrollBehavior = r.scrollBehavior = "auto"),
              window.scroll(
                this._previousScrollPosition.left,
                this._previousScrollPosition.top,
              ),
              qO && ((i.scrollBehavior = s), (r.scrollBehavior = o));
          }
        }
        _canBeEnabled() {
          if (
            this._document.documentElement.classList.contains(
              "cdk-global-scrollblock",
            ) ||
            this._isEnabled
          )
            return !1;
          const t = this._document.body,
            i = this._viewportRuler.getViewportSize();
          return t.scrollHeight > i.height || t.scrollWidth > i.width;
        }
      }
      class ZK {
        constructor(e, t, i, r) {
          (this._scrollDispatcher = e),
            (this._ngZone = t),
            (this._viewportRuler = i),
            (this._config = r),
            (this._scrollSubscription = null),
            (this._detach = () => {
              this.disable(),
                this._overlayRef.hasAttached() &&
                  this._ngZone.run(() => this._overlayRef.detach());
            });
        }
        attach(e) {
          this._overlayRef = e;
        }
        enable() {
          if (this._scrollSubscription) return;
          const e = this._scrollDispatcher
            .scrolled(0)
            .pipe(
              Yi(
                (t) =>
                  !t ||
                  !this._overlayRef.overlayElement.contains(
                    t.getElementRef().nativeElement,
                  ),
              ),
            );
          this._config && this._config.threshold && this._config.threshold > 1
            ? ((this._initialScrollPosition =
                this._viewportRuler.getViewportScrollPosition().top),
              (this._scrollSubscription = e.subscribe(() => {
                const t = this._viewportRuler.getViewportScrollPosition().top;
                Math.abs(t - this._initialScrollPosition) >
                this._config.threshold
                  ? this._detach()
                  : this._overlayRef.updatePosition();
              })))
            : (this._scrollSubscription = e.subscribe(this._detach));
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null));
        }
        detach() {
          this.disable(), (this._overlayRef = null);
        }
      }
      class XO {
        enable() {}
        disable() {}
        attach() {}
      }
      function Ab(n, e) {
        return e.some(
          (t) =>
            n.bottom < t.top ||
            n.top > t.bottom ||
            n.right < t.left ||
            n.left > t.right,
        );
      }
      function YO(n, e) {
        return e.some(
          (t) =>
            n.top < t.top ||
            n.bottom > t.bottom ||
            n.left < t.left ||
            n.right > t.right,
        );
      }
      class KK {
        constructor(e, t, i, r) {
          (this._scrollDispatcher = e),
            (this._viewportRuler = t),
            (this._ngZone = i),
            (this._config = r),
            (this._scrollSubscription = null);
        }
        attach(e) {
          this._overlayRef = e;
        }
        enable() {
          this._scrollSubscription ||
            (this._scrollSubscription = this._scrollDispatcher
              .scrolled(this._config ? this._config.scrollThrottle : 0)
              .subscribe(() => {
                if (
                  (this._overlayRef.updatePosition(),
                  this._config && this._config.autoClose)
                ) {
                  const t =
                      this._overlayRef.overlayElement.getBoundingClientRect(),
                    { width: i, height: r } =
                      this._viewportRuler.getViewportSize();
                  Ab(t, [
                    {
                      width: i,
                      height: r,
                      bottom: r,
                      right: i,
                      top: 0,
                      left: 0,
                    },
                  ]) &&
                    (this.disable(),
                    this._ngZone.run(() => this._overlayRef.detach()));
                }
              }));
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null));
        }
        detach() {
          this.disable(), (this._overlayRef = null);
        }
      }
      let QK = (() => {
        class n {
          constructor(t, i, r, s) {
            (this._scrollDispatcher = t),
              (this._viewportRuler = i),
              (this._ngZone = r),
              (this.noop = () => new XO()),
              (this.close = (o) =>
                new ZK(
                  this._scrollDispatcher,
                  this._ngZone,
                  this._viewportRuler,
                  o,
                )),
              (this.block = () => new YK(this._viewportRuler, this._document)),
              (this.reposition = (o) =>
                new KK(
                  this._scrollDispatcher,
                  this._viewportRuler,
                  this._ngZone,
                  o,
                )),
              (this._document = s);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se($K), se(HO), se(yt), se(kt));
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      class ZO {
        constructor(e) {
          if (
            ((this.scrollStrategy = new XO()),
            (this.panelClass = ""),
            (this.hasBackdrop = !1),
            (this.backdropClass = "cdk-overlay-dark-backdrop"),
            (this.disposeOnNavigation = !1),
            e)
          ) {
            const t = Object.keys(e);
            for (const i of t) void 0 !== e[i] && (this[i] = e[i]);
          }
        }
      }
      class JK {
        constructor(e, t) {
          (this.connectionPair = e), (this.scrollableViewProperties = t);
        }
      }
      let KO = (() => {
          class n {
            constructor(t) {
              (this._attachedOverlays = []), (this._document = t);
            }
            ngOnDestroy() {
              this.detach();
            }
            add(t) {
              this.remove(t), this._attachedOverlays.push(t);
            }
            remove(t) {
              const i = this._attachedOverlays.indexOf(t);
              i > -1 && this._attachedOverlays.splice(i, 1),
                0 === this._attachedOverlays.length && this.detach();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(kt));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        eQ = (() => {
          class n extends KO {
            constructor(t, i) {
              super(t),
                (this._ngZone = i),
                (this._keydownListener = (r) => {
                  const s = this._attachedOverlays;
                  for (let o = s.length - 1; o > -1; o--)
                    if (s[o]._keydownEvents.observers.length > 0) {
                      const a = s[o]._keydownEvents;
                      this._ngZone
                        ? this._ngZone.run(() => a.next(r))
                        : a.next(r);
                      break;
                    }
                });
            }
            add(t) {
              super.add(t),
                this._isAttached ||
                  (this._ngZone
                    ? this._ngZone.runOutsideAngular(() =>
                        this._document.body.addEventListener(
                          "keydown",
                          this._keydownListener,
                        ),
                      )
                    : this._document.body.addEventListener(
                        "keydown",
                        this._keydownListener,
                      ),
                  (this._isAttached = !0));
            }
            detach() {
              this._isAttached &&
                (this._document.body.removeEventListener(
                  "keydown",
                  this._keydownListener,
                ),
                (this._isAttached = !1));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(kt), se(yt, 8));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        tQ = (() => {
          class n extends KO {
            constructor(t, i, r) {
              super(t),
                (this._platform = i),
                (this._ngZone = r),
                (this._cursorStyleIsSet = !1),
                (this._pointerDownListener = (s) => {
                  this._pointerDownEventTarget = BO(s);
                }),
                (this._clickListener = (s) => {
                  const o = BO(s),
                    a =
                      "click" === s.type && this._pointerDownEventTarget
                        ? this._pointerDownEventTarget
                        : o;
                  this._pointerDownEventTarget = null;
                  const l = this._attachedOverlays.slice();
                  for (let c = l.length - 1; c > -1; c--) {
                    const u = l[c];
                    if (
                      u._outsidePointerEvents.observers.length < 1 ||
                      !u.hasAttached()
                    )
                      continue;
                    if (
                      u.overlayElement.contains(o) ||
                      u.overlayElement.contains(a)
                    )
                      break;
                    const d = u._outsidePointerEvents;
                    this._ngZone
                      ? this._ngZone.run(() => d.next(s))
                      : d.next(s);
                  }
                });
            }
            add(t) {
              if ((super.add(t), !this._isAttached)) {
                const i = this._document.body;
                this._ngZone
                  ? this._ngZone.runOutsideAngular(() =>
                      this._addEventListeners(i),
                    )
                  : this._addEventListeners(i),
                  this._platform.IOS &&
                    !this._cursorStyleIsSet &&
                    ((this._cursorOriginalValue = i.style.cursor),
                    (i.style.cursor = "pointer"),
                    (this._cursorStyleIsSet = !0)),
                  (this._isAttached = !0);
              }
            }
            detach() {
              if (this._isAttached) {
                const t = this._document.body;
                t.removeEventListener(
                  "pointerdown",
                  this._pointerDownListener,
                  !0,
                ),
                  t.removeEventListener("click", this._clickListener, !0),
                  t.removeEventListener("auxclick", this._clickListener, !0),
                  t.removeEventListener("contextmenu", this._clickListener, !0),
                  this._platform.IOS &&
                    this._cursorStyleIsSet &&
                    ((t.style.cursor = this._cursorOriginalValue),
                    (this._cursorStyleIsSet = !1)),
                  (this._isAttached = !1);
              }
            }
            _addEventListeners(t) {
              t.addEventListener("pointerdown", this._pointerDownListener, !0),
                t.addEventListener("click", this._clickListener, !0),
                t.addEventListener("auxclick", this._clickListener, !0),
                t.addEventListener("contextmenu", this._clickListener, !0);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(kt), se(nc), se(yt, 8));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        QO = (() => {
          class n {
            constructor(t, i) {
              (this._platform = i), (this._document = t);
            }
            ngOnDestroy() {
              this._containerElement?.remove();
            }
            getContainerElement() {
              return (
                this._containerElement || this._createContainer(),
                this._containerElement
              );
            }
            _createContainer() {
              const t = "cdk-overlay-container";
              if (this._platform.isBrowser || VO()) {
                const r = this._document.querySelectorAll(
                  `.${t}[platform="server"], .${t}[platform="test"]`,
                );
                for (let s = 0; s < r.length; s++) r[s].remove();
              }
              const i = this._document.createElement("div");
              i.classList.add(t),
                VO()
                  ? i.setAttribute("platform", "test")
                  : this._platform.isBrowser ||
                    i.setAttribute("platform", "server"),
                this._document.body.appendChild(i),
                (this._containerElement = i);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(kt), se(nc));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      class nQ {
        constructor(e, t, i, r, s, o, a, l, c, u = !1) {
          (this._portalOutlet = e),
            (this._host = t),
            (this._pane = i),
            (this._config = r),
            (this._ngZone = s),
            (this._keyboardDispatcher = o),
            (this._document = a),
            (this._location = l),
            (this._outsideClickDispatcher = c),
            (this._animationsDisabled = u),
            (this._backdropElement = null),
            (this._backdropClick = new en()),
            (this._attachments = new en()),
            (this._detachments = new en()),
            (this._locationChanges = Un.EMPTY),
            (this._backdropClickHandler = (d) => this._backdropClick.next(d)),
            (this._backdropTransitionendHandler = (d) => {
              this._disposeBackdrop(d.target);
            }),
            (this._keydownEvents = new en()),
            (this._outsidePointerEvents = new en()),
            r.scrollStrategy &&
              ((this._scrollStrategy = r.scrollStrategy),
              this._scrollStrategy.attach(this)),
            (this._positionStrategy = r.positionStrategy);
        }
        get overlayElement() {
          return this._pane;
        }
        get backdropElement() {
          return this._backdropElement;
        }
        get hostElement() {
          return this._host;
        }
        attach(e) {
          !this._host.parentElement &&
            this._previousHostParent &&
            this._previousHostParent.appendChild(this._host);
          const t = this._portalOutlet.attach(e);
          return (
            this._positionStrategy && this._positionStrategy.attach(this),
            this._updateStackingOrder(),
            this._updateElementSize(),
            this._updateElementDirection(),
            this._scrollStrategy && this._scrollStrategy.enable(),
            this._ngZone.onStable.pipe(xi(1)).subscribe(() => {
              this.hasAttached() && this.updatePosition();
            }),
            this._togglePointerEvents(!0),
            this._config.hasBackdrop && this._attachBackdrop(),
            this._config.panelClass &&
              this._toggleClasses(this._pane, this._config.panelClass, !0),
            this._attachments.next(),
            this._keyboardDispatcher.add(this),
            this._config.disposeOnNavigation &&
              (this._locationChanges = this._location.subscribe(() =>
                this.dispose(),
              )),
            this._outsideClickDispatcher.add(this),
            "function" == typeof t?.onDestroy &&
              t.onDestroy(() => {
                this.hasAttached() &&
                  this._ngZone.runOutsideAngular(() =>
                    Promise.resolve().then(() => this.detach()),
                  );
              }),
            t
          );
        }
        detach() {
          if (!this.hasAttached()) return;
          this.detachBackdrop(),
            this._togglePointerEvents(!1),
            this._positionStrategy &&
              this._positionStrategy.detach &&
              this._positionStrategy.detach(),
            this._scrollStrategy && this._scrollStrategy.disable();
          const e = this._portalOutlet.detach();
          return (
            this._detachments.next(),
            this._keyboardDispatcher.remove(this),
            this._detachContentWhenStable(),
            this._locationChanges.unsubscribe(),
            this._outsideClickDispatcher.remove(this),
            e
          );
        }
        dispose() {
          const e = this.hasAttached();
          this._positionStrategy && this._positionStrategy.dispose(),
            this._disposeScrollStrategy(),
            this._disposeBackdrop(this._backdropElement),
            this._locationChanges.unsubscribe(),
            this._keyboardDispatcher.remove(this),
            this._portalOutlet.dispose(),
            this._attachments.complete(),
            this._backdropClick.complete(),
            this._keydownEvents.complete(),
            this._outsidePointerEvents.complete(),
            this._outsideClickDispatcher.remove(this),
            this._host?.remove(),
            (this._previousHostParent = this._pane = this._host = null),
            e && this._detachments.next(),
            this._detachments.complete();
        }
        hasAttached() {
          return this._portalOutlet.hasAttached();
        }
        backdropClick() {
          return this._backdropClick;
        }
        attachments() {
          return this._attachments;
        }
        detachments() {
          return this._detachments;
        }
        keydownEvents() {
          return this._keydownEvents;
        }
        outsidePointerEvents() {
          return this._outsidePointerEvents;
        }
        getConfig() {
          return this._config;
        }
        updatePosition() {
          this._positionStrategy && this._positionStrategy.apply();
        }
        updatePositionStrategy(e) {
          e !== this._positionStrategy &&
            (this._positionStrategy && this._positionStrategy.dispose(),
            (this._positionStrategy = e),
            this.hasAttached() && (e.attach(this), this.updatePosition()));
        }
        updateSize(e) {
          (this._config = { ...this._config, ...e }), this._updateElementSize();
        }
        setDirection(e) {
          (this._config = { ...this._config, direction: e }),
            this._updateElementDirection();
        }
        addPanelClass(e) {
          this._pane && this._toggleClasses(this._pane, e, !0);
        }
        removePanelClass(e) {
          this._pane && this._toggleClasses(this._pane, e, !1);
        }
        getDirection() {
          const e = this._config.direction;
          return e ? ("string" == typeof e ? e : e.value) : "ltr";
        }
        updateScrollStrategy(e) {
          e !== this._scrollStrategy &&
            (this._disposeScrollStrategy(),
            (this._scrollStrategy = e),
            this.hasAttached() && (e.attach(this), e.enable()));
        }
        _updateElementDirection() {
          this._host.setAttribute("dir", this.getDirection());
        }
        _updateElementSize() {
          if (!this._pane) return;
          const e = this._pane.style;
          (e.width = vn(this._config.width)),
            (e.height = vn(this._config.height)),
            (e.minWidth = vn(this._config.minWidth)),
            (e.minHeight = vn(this._config.minHeight)),
            (e.maxWidth = vn(this._config.maxWidth)),
            (e.maxHeight = vn(this._config.maxHeight));
        }
        _togglePointerEvents(e) {
          this._pane.style.pointerEvents = e ? "" : "none";
        }
        _attachBackdrop() {
          const e = "cdk-overlay-backdrop-showing";
          (this._backdropElement = this._document.createElement("div")),
            this._backdropElement.classList.add("cdk-overlay-backdrop"),
            this._animationsDisabled &&
              this._backdropElement.classList.add(
                "cdk-overlay-backdrop-noop-animation",
              ),
            this._config.backdropClass &&
              this._toggleClasses(
                this._backdropElement,
                this._config.backdropClass,
                !0,
              ),
            this._host.parentElement.insertBefore(
              this._backdropElement,
              this._host,
            ),
            this._backdropElement.addEventListener(
              "click",
              this._backdropClickHandler,
            ),
            !this._animationsDisabled && typeof requestAnimationFrame < "u"
              ? this._ngZone.runOutsideAngular(() => {
                  requestAnimationFrame(() => {
                    this._backdropElement &&
                      this._backdropElement.classList.add(e);
                  });
                })
              : this._backdropElement.classList.add(e);
        }
        _updateStackingOrder() {
          this._host.nextSibling &&
            this._host.parentNode.appendChild(this._host);
        }
        detachBackdrop() {
          const e = this._backdropElement;
          if (e) {
            if (this._animationsDisabled) return void this._disposeBackdrop(e);
            e.classList.remove("cdk-overlay-backdrop-showing"),
              this._ngZone.runOutsideAngular(() => {
                e.addEventListener(
                  "transitionend",
                  this._backdropTransitionendHandler,
                );
              }),
              (e.style.pointerEvents = "none"),
              (this._backdropTimeout = this._ngZone.runOutsideAngular(() =>
                setTimeout(() => {
                  this._disposeBackdrop(e);
                }, 500),
              ));
          }
        }
        _toggleClasses(e, t, i) {
          const r = D1(t || []).filter((s) => !!s);
          r.length && (i ? e.classList.add(...r) : e.classList.remove(...r));
        }
        _detachContentWhenStable() {
          this._ngZone.runOutsideAngular(() => {
            const e = this._ngZone.onStable
              .pipe(Cb(PM(this._attachments, this._detachments)))
              .subscribe(() => {
                (!this._pane ||
                  !this._host ||
                  0 === this._pane.children.length) &&
                  (this._pane &&
                    this._config.panelClass &&
                    this._toggleClasses(
                      this._pane,
                      this._config.panelClass,
                      !1,
                    ),
                  this._host &&
                    this._host.parentElement &&
                    ((this._previousHostParent = this._host.parentElement),
                    this._host.remove()),
                  e.unsubscribe());
              });
          });
        }
        _disposeScrollStrategy() {
          const e = this._scrollStrategy;
          e && (e.disable(), e.detach && e.detach());
        }
        _disposeBackdrop(e) {
          e &&
            (e.removeEventListener("click", this._backdropClickHandler),
            e.removeEventListener(
              "transitionend",
              this._backdropTransitionendHandler,
            ),
            e.remove(),
            this._backdropElement === e && (this._backdropElement = null)),
            this._backdropTimeout &&
              (clearTimeout(this._backdropTimeout),
              (this._backdropTimeout = void 0));
        }
      }
      const JO = "cdk-overlay-connected-position-bounding-box",
        iQ = /([A-Za-z%]+)$/;
      class rQ {
        get positions() {
          return this._preferredPositions;
        }
        constructor(e, t, i, r, s) {
          (this._viewportRuler = t),
            (this._document = i),
            (this._platform = r),
            (this._overlayContainer = s),
            (this._lastBoundingBoxSize = { width: 0, height: 0 }),
            (this._isPushed = !1),
            (this._canPush = !0),
            (this._growAfterOpen = !1),
            (this._hasFlexibleDimensions = !0),
            (this._positionLocked = !1),
            (this._viewportMargin = 0),
            (this._scrollables = []),
            (this._preferredPositions = []),
            (this._positionChanges = new en()),
            (this._resizeSubscription = Un.EMPTY),
            (this._offsetX = 0),
            (this._offsetY = 0),
            (this._appliedPanelClasses = []),
            (this.positionChanges = this._positionChanges),
            this.setOrigin(e);
        }
        attach(e) {
          this._validatePositions(),
            e.hostElement.classList.add(JO),
            (this._overlayRef = e),
            (this._boundingBox = e.hostElement),
            (this._pane = e.overlayElement),
            (this._isDisposed = !1),
            (this._isInitialRender = !0),
            (this._lastPosition = null),
            this._resizeSubscription.unsubscribe(),
            (this._resizeSubscription = this._viewportRuler
              .change()
              .subscribe(() => {
                (this._isInitialRender = !0), this.apply();
              }));
        }
        apply() {
          if (this._isDisposed || !this._platform.isBrowser) return;
          if (
            !this._isInitialRender &&
            this._positionLocked &&
            this._lastPosition
          )
            return void this.reapplyLastPosition();
          this._clearPanelClasses(),
            this._resetOverlayElementStyles(),
            this._resetBoundingBoxStyles(),
            (this._viewportRect = this._getNarrowedViewportRect()),
            (this._originRect = this._getOriginRect()),
            (this._overlayRect = this._pane.getBoundingClientRect()),
            (this._containerRect = this._overlayContainer
              .getContainerElement()
              .getBoundingClientRect());
          const e = this._originRect,
            t = this._overlayRect,
            i = this._viewportRect,
            r = this._containerRect,
            s = [];
          let o;
          for (let a of this._preferredPositions) {
            let l = this._getOriginPoint(e, r, a),
              c = this._getOverlayPoint(l, t, a),
              u = this._getOverlayFit(c, t, i, a);
            if (u.isCompletelyWithinViewport)
              return (this._isPushed = !1), void this._applyPosition(a, l);
            this._canFitWithFlexibleDimensions(u, c, i)
              ? s.push({
                  position: a,
                  origin: l,
                  overlayRect: t,
                  boundingBoxRect: this._calculateBoundingBoxRect(l, a),
                })
              : (!o || o.overlayFit.visibleArea < u.visibleArea) &&
                (o = {
                  overlayFit: u,
                  overlayPoint: c,
                  originPoint: l,
                  position: a,
                  overlayRect: t,
                });
          }
          if (s.length) {
            let a = null,
              l = -1;
            for (const c of s) {
              const u =
                c.boundingBoxRect.width *
                c.boundingBoxRect.height *
                (c.position.weight || 1);
              u > l && ((l = u), (a = c));
            }
            return (
              (this._isPushed = !1),
              void this._applyPosition(a.position, a.origin)
            );
          }
          if (this._canPush)
            return (
              (this._isPushed = !0),
              void this._applyPosition(o.position, o.originPoint)
            );
          this._applyPosition(o.position, o.originPoint);
        }
        detach() {
          this._clearPanelClasses(),
            (this._lastPosition = null),
            (this._previousPushAmount = null),
            this._resizeSubscription.unsubscribe();
        }
        dispose() {
          this._isDisposed ||
            (this._boundingBox &&
              ra(this._boundingBox.style, {
                top: "",
                left: "",
                right: "",
                bottom: "",
                height: "",
                width: "",
                alignItems: "",
                justifyContent: "",
              }),
            this._pane && this._resetOverlayElementStyles(),
            this._overlayRef &&
              this._overlayRef.hostElement.classList.remove(JO),
            this.detach(),
            this._positionChanges.complete(),
            (this._overlayRef = this._boundingBox = null),
            (this._isDisposed = !0));
        }
        reapplyLastPosition() {
          if (this._isDisposed || !this._platform.isBrowser) return;
          const e = this._lastPosition;
          if (e) {
            (this._originRect = this._getOriginRect()),
              (this._overlayRect = this._pane.getBoundingClientRect()),
              (this._viewportRect = this._getNarrowedViewportRect()),
              (this._containerRect = this._overlayContainer
                .getContainerElement()
                .getBoundingClientRect());
            const t = this._getOriginPoint(
              this._originRect,
              this._containerRect,
              e,
            );
            this._applyPosition(e, t);
          } else this.apply();
        }
        withScrollableContainers(e) {
          return (this._scrollables = e), this;
        }
        withPositions(e) {
          return (
            (this._preferredPositions = e),
            -1 === e.indexOf(this._lastPosition) && (this._lastPosition = null),
            this._validatePositions(),
            this
          );
        }
        withViewportMargin(e) {
          return (this._viewportMargin = e), this;
        }
        withFlexibleDimensions(e = !0) {
          return (this._hasFlexibleDimensions = e), this;
        }
        withGrowAfterOpen(e = !0) {
          return (this._growAfterOpen = e), this;
        }
        withPush(e = !0) {
          return (this._canPush = e), this;
        }
        withLockedPosition(e = !0) {
          return (this._positionLocked = e), this;
        }
        setOrigin(e) {
          return (this._origin = e), this;
        }
        withDefaultOffsetX(e) {
          return (this._offsetX = e), this;
        }
        withDefaultOffsetY(e) {
          return (this._offsetY = e), this;
        }
        withTransformOriginOn(e) {
          return (this._transformOriginSelector = e), this;
        }
        _getOriginPoint(e, t, i) {
          let r, s;
          if ("center" == i.originX) r = e.left + e.width / 2;
          else {
            const o = this._isRtl() ? e.right : e.left,
              a = this._isRtl() ? e.left : e.right;
            r = "start" == i.originX ? o : a;
          }
          return (
            t.left < 0 && (r -= t.left),
            (s =
              "center" == i.originY
                ? e.top + e.height / 2
                : "top" == i.originY
                ? e.top
                : e.bottom),
            t.top < 0 && (s -= t.top),
            { x: r, y: s }
          );
        }
        _getOverlayPoint(e, t, i) {
          let r, s;
          return (
            (r =
              "center" == i.overlayX
                ? -t.width / 2
                : "start" === i.overlayX
                ? this._isRtl()
                  ? -t.width
                  : 0
                : this._isRtl()
                ? 0
                : -t.width),
            (s =
              "center" == i.overlayY
                ? -t.height / 2
                : "top" == i.overlayY
                ? 0
                : -t.height),
            { x: e.x + r, y: e.y + s }
          );
        }
        _getOverlayFit(e, t, i, r) {
          const s = tN(t);
          let { x: o, y: a } = e,
            l = this._getOffset(r, "x"),
            c = this._getOffset(r, "y");
          l && (o += l), c && (a += c);
          let h = 0 - a,
            f = a + s.height - i.height,
            p = this._subtractOverflows(s.width, 0 - o, o + s.width - i.width),
            _ = this._subtractOverflows(s.height, h, f),
            g = p * _;
          return {
            visibleArea: g,
            isCompletelyWithinViewport: s.width * s.height === g,
            fitsInViewportVertically: _ === s.height,
            fitsInViewportHorizontally: p == s.width,
          };
        }
        _canFitWithFlexibleDimensions(e, t, i) {
          if (this._hasFlexibleDimensions) {
            const r = i.bottom - t.y,
              s = i.right - t.x,
              o = eN(this._overlayRef.getConfig().minHeight),
              a = eN(this._overlayRef.getConfig().minWidth);
            return (
              (e.fitsInViewportVertically || (null != o && o <= r)) &&
              (e.fitsInViewportHorizontally || (null != a && a <= s))
            );
          }
          return !1;
        }
        _pushOverlayOnScreen(e, t, i) {
          if (this._previousPushAmount && this._positionLocked)
            return {
              x: e.x + this._previousPushAmount.x,
              y: e.y + this._previousPushAmount.y,
            };
          const r = tN(t),
            s = this._viewportRect,
            o = Math.max(e.x + r.width - s.width, 0),
            a = Math.max(e.y + r.height - s.height, 0),
            l = Math.max(s.top - i.top - e.y, 0),
            c = Math.max(s.left - i.left - e.x, 0);
          let u = 0,
            d = 0;
          return (
            (u =
              r.width <= s.width
                ? c || -o
                : e.x < this._viewportMargin
                ? s.left - i.left - e.x
                : 0),
            (d =
              r.height <= s.height
                ? l || -a
                : e.y < this._viewportMargin
                ? s.top - i.top - e.y
                : 0),
            (this._previousPushAmount = { x: u, y: d }),
            { x: e.x + u, y: e.y + d }
          );
        }
        _applyPosition(e, t) {
          if (
            (this._setTransformOrigin(e),
            this._setOverlayElementStyles(t, e),
            this._setBoundingBoxStyles(t, e),
            e.panelClass && this._addPanelClasses(e.panelClass),
            (this._lastPosition = e),
            this._positionChanges.observers.length)
          ) {
            const i = this._getScrollVisibility(),
              r = new JK(e, i);
            this._positionChanges.next(r);
          }
          this._isInitialRender = !1;
        }
        _setTransformOrigin(e) {
          if (!this._transformOriginSelector) return;
          const t = this._boundingBox.querySelectorAll(
            this._transformOriginSelector,
          );
          let i,
            r = e.overlayY;
          i =
            "center" === e.overlayX
              ? "center"
              : this._isRtl()
              ? "start" === e.overlayX
                ? "right"
                : "left"
              : "start" === e.overlayX
              ? "left"
              : "right";
          for (let s = 0; s < t.length; s++)
            t[s].style.transformOrigin = `${i} ${r}`;
        }
        _calculateBoundingBoxRect(e, t) {
          const i = this._viewportRect,
            r = this._isRtl();
          let s, o, a, u, d, h;
          if ("top" === t.overlayY)
            (o = e.y), (s = i.height - o + this._viewportMargin);
          else if ("bottom" === t.overlayY)
            (a = i.height - e.y + 2 * this._viewportMargin),
              (s = i.height - a + this._viewportMargin);
          else {
            const f = Math.min(i.bottom - e.y + i.top, e.y),
              p = this._lastBoundingBoxSize.height;
            (s = 2 * f),
              (o = e.y - f),
              s > p &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (o = e.y - p / 2);
          }
          if (("end" === t.overlayX && !r) || ("start" === t.overlayX && r))
            (h = i.width - e.x + this._viewportMargin),
              (u = e.x - this._viewportMargin);
          else if (
            ("start" === t.overlayX && !r) ||
            ("end" === t.overlayX && r)
          )
            (d = e.x), (u = i.right - e.x);
          else {
            const f = Math.min(i.right - e.x + i.left, e.x),
              p = this._lastBoundingBoxSize.width;
            (u = 2 * f),
              (d = e.x - f),
              u > p &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (d = e.x - p / 2);
          }
          return { top: o, left: d, bottom: a, right: h, width: u, height: s };
        }
        _setBoundingBoxStyles(e, t) {
          const i = this._calculateBoundingBoxRect(e, t);
          !this._isInitialRender &&
            !this._growAfterOpen &&
            ((i.height = Math.min(i.height, this._lastBoundingBoxSize.height)),
            (i.width = Math.min(i.width, this._lastBoundingBoxSize.width)));
          const r = {};
          if (this._hasExactPosition())
            (r.top = r.left = "0"),
              (r.bottom = r.right = r.maxHeight = r.maxWidth = ""),
              (r.width = r.height = "100%");
          else {
            const s = this._overlayRef.getConfig().maxHeight,
              o = this._overlayRef.getConfig().maxWidth;
            (r.height = vn(i.height)),
              (r.top = vn(i.top)),
              (r.bottom = vn(i.bottom)),
              (r.width = vn(i.width)),
              (r.left = vn(i.left)),
              (r.right = vn(i.right)),
              (r.alignItems =
                "center" === t.overlayX
                  ? "center"
                  : "end" === t.overlayX
                  ? "flex-end"
                  : "flex-start"),
              (r.justifyContent =
                "center" === t.overlayY
                  ? "center"
                  : "bottom" === t.overlayY
                  ? "flex-end"
                  : "flex-start"),
              s && (r.maxHeight = vn(s)),
              o && (r.maxWidth = vn(o));
          }
          (this._lastBoundingBoxSize = i), ra(this._boundingBox.style, r);
        }
        _resetBoundingBoxStyles() {
          ra(this._boundingBox.style, {
            top: "0",
            left: "0",
            right: "0",
            bottom: "0",
            height: "",
            width: "",
            alignItems: "",
            justifyContent: "",
          });
        }
        _resetOverlayElementStyles() {
          ra(this._pane.style, {
            top: "",
            left: "",
            bottom: "",
            right: "",
            position: "",
            transform: "",
          });
        }
        _setOverlayElementStyles(e, t) {
          const i = {},
            r = this._hasExactPosition(),
            s = this._hasFlexibleDimensions,
            o = this._overlayRef.getConfig();
          if (r) {
            const u = this._viewportRuler.getViewportScrollPosition();
            ra(i, this._getExactOverlayY(t, e, u)),
              ra(i, this._getExactOverlayX(t, e, u));
          } else i.position = "static";
          let a = "",
            l = this._getOffset(t, "x"),
            c = this._getOffset(t, "y");
          l && (a += `translateX(${l}px) `),
            c && (a += `translateY(${c}px)`),
            (i.transform = a.trim()),
            o.maxHeight &&
              (r ? (i.maxHeight = vn(o.maxHeight)) : s && (i.maxHeight = "")),
            o.maxWidth &&
              (r ? (i.maxWidth = vn(o.maxWidth)) : s && (i.maxWidth = "")),
            ra(this._pane.style, i);
        }
        _getExactOverlayY(e, t, i) {
          let r = { top: "", bottom: "" },
            s = this._getOverlayPoint(t, this._overlayRect, e);
          return (
            this._isPushed &&
              (s = this._pushOverlayOnScreen(s, this._overlayRect, i)),
            "bottom" === e.overlayY
              ? (r.bottom =
                  this._document.documentElement.clientHeight -
                  (s.y + this._overlayRect.height) +
                  "px")
              : (r.top = vn(s.y)),
            r
          );
        }
        _getExactOverlayX(e, t, i) {
          let o,
            r = { left: "", right: "" },
            s = this._getOverlayPoint(t, this._overlayRect, e);
          return (
            this._isPushed &&
              (s = this._pushOverlayOnScreen(s, this._overlayRect, i)),
            (o = this._isRtl()
              ? "end" === e.overlayX
                ? "left"
                : "right"
              : "end" === e.overlayX
              ? "right"
              : "left"),
            "right" === o
              ? (r.right =
                  this._document.documentElement.clientWidth -
                  (s.x + this._overlayRect.width) +
                  "px")
              : (r.left = vn(s.x)),
            r
          );
        }
        _getScrollVisibility() {
          const e = this._getOriginRect(),
            t = this._pane.getBoundingClientRect(),
            i = this._scrollables.map((r) =>
              r.getElementRef().nativeElement.getBoundingClientRect(),
            );
          return {
            isOriginClipped: YO(e, i),
            isOriginOutsideView: Ab(e, i),
            isOverlayClipped: YO(t, i),
            isOverlayOutsideView: Ab(t, i),
          };
        }
        _subtractOverflows(e, ...t) {
          return t.reduce((i, r) => i - Math.max(r, 0), e);
        }
        _getNarrowedViewportRect() {
          const e = this._document.documentElement.clientWidth,
            t = this._document.documentElement.clientHeight,
            i = this._viewportRuler.getViewportScrollPosition();
          return {
            top: i.top + this._viewportMargin,
            left: i.left + this._viewportMargin,
            right: i.left + e - this._viewportMargin,
            bottom: i.top + t - this._viewportMargin,
            width: e - 2 * this._viewportMargin,
            height: t - 2 * this._viewportMargin,
          };
        }
        _isRtl() {
          return "rtl" === this._overlayRef.getDirection();
        }
        _hasExactPosition() {
          return !this._hasFlexibleDimensions || this._isPushed;
        }
        _getOffset(e, t) {
          return "x" === t
            ? null == e.offsetX
              ? this._offsetX
              : e.offsetX
            : null == e.offsetY
            ? this._offsetY
            : e.offsetY;
        }
        _validatePositions() {}
        _addPanelClasses(e) {
          this._pane &&
            D1(e).forEach((t) => {
              "" !== t &&
                -1 === this._appliedPanelClasses.indexOf(t) &&
                (this._appliedPanelClasses.push(t),
                this._pane.classList.add(t));
            });
        }
        _clearPanelClasses() {
          this._pane &&
            (this._appliedPanelClasses.forEach((e) => {
              this._pane.classList.remove(e);
            }),
            (this._appliedPanelClasses = []));
        }
        _getOriginRect() {
          const e = this._origin;
          if (e instanceof Rn) return e.nativeElement.getBoundingClientRect();
          if (e instanceof Element) return e.getBoundingClientRect();
          const t = e.width || 0,
            i = e.height || 0;
          return {
            top: e.y,
            bottom: e.y + i,
            left: e.x,
            right: e.x + t,
            height: i,
            width: t,
          };
        }
      }
      function ra(n, e) {
        for (let t in e) e.hasOwnProperty(t) && (n[t] = e[t]);
        return n;
      }
      function eN(n) {
        if ("number" != typeof n && null != n) {
          const [e, t] = n.split(iQ);
          return t && "px" !== t ? null : parseFloat(e);
        }
        return n || null;
      }
      function tN(n) {
        return {
          top: Math.floor(n.top),
          right: Math.floor(n.right),
          bottom: Math.floor(n.bottom),
          left: Math.floor(n.left),
          width: Math.floor(n.width),
          height: Math.floor(n.height),
        };
      }
      const nN = "cdk-global-overlay-wrapper";
      class sQ {
        constructor() {
          (this._cssPosition = "static"),
            (this._topOffset = ""),
            (this._bottomOffset = ""),
            (this._alignItems = ""),
            (this._xPosition = ""),
            (this._xOffset = ""),
            (this._width = ""),
            (this._height = ""),
            (this._isDisposed = !1);
        }
        attach(e) {
          const t = e.getConfig();
          (this._overlayRef = e),
            this._width && !t.width && e.updateSize({ width: this._width }),
            this._height && !t.height && e.updateSize({ height: this._height }),
            e.hostElement.classList.add(nN),
            (this._isDisposed = !1);
        }
        top(e = "") {
          return (
            (this._bottomOffset = ""),
            (this._topOffset = e),
            (this._alignItems = "flex-start"),
            this
          );
        }
        left(e = "") {
          return (this._xOffset = e), (this._xPosition = "left"), this;
        }
        bottom(e = "") {
          return (
            (this._topOffset = ""),
            (this._bottomOffset = e),
            (this._alignItems = "flex-end"),
            this
          );
        }
        right(e = "") {
          return (this._xOffset = e), (this._xPosition = "right"), this;
        }
        start(e = "") {
          return (this._xOffset = e), (this._xPosition = "start"), this;
        }
        end(e = "") {
          return (this._xOffset = e), (this._xPosition = "end"), this;
        }
        width(e = "") {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ width: e })
              : (this._width = e),
            this
          );
        }
        height(e = "") {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ height: e })
              : (this._height = e),
            this
          );
        }
        centerHorizontally(e = "") {
          return this.left(e), (this._xPosition = "center"), this;
        }
        centerVertically(e = "") {
          return this.top(e), (this._alignItems = "center"), this;
        }
        apply() {
          if (!this._overlayRef || !this._overlayRef.hasAttached()) return;
          const e = this._overlayRef.overlayElement.style,
            t = this._overlayRef.hostElement.style,
            i = this._overlayRef.getConfig(),
            { width: r, height: s, maxWidth: o, maxHeight: a } = i,
            l = !(
              ("100%" !== r && "100vw" !== r) ||
              (o && "100%" !== o && "100vw" !== o)
            ),
            c = !(
              ("100%" !== s && "100vh" !== s) ||
              (a && "100%" !== a && "100vh" !== a)
            ),
            u = this._xPosition,
            d = this._xOffset,
            h = "rtl" === this._overlayRef.getConfig().direction;
          let f = "",
            p = "",
            _ = "";
          l
            ? (_ = "flex-start")
            : "center" === u
            ? ((_ = "center"), h ? (p = d) : (f = d))
            : h
            ? "left" === u || "end" === u
              ? ((_ = "flex-end"), (f = d))
              : ("right" === u || "start" === u) &&
                ((_ = "flex-start"), (p = d))
            : "left" === u || "start" === u
            ? ((_ = "flex-start"), (f = d))
            : ("right" === u || "end" === u) && ((_ = "flex-end"), (p = d)),
            (e.position = this._cssPosition),
            (e.marginLeft = l ? "0" : f),
            (e.marginTop = c ? "0" : this._topOffset),
            (e.marginBottom = this._bottomOffset),
            (e.marginRight = l ? "0" : p),
            (t.justifyContent = _),
            (t.alignItems = c ? "flex-start" : this._alignItems);
        }
        dispose() {
          if (this._isDisposed || !this._overlayRef) return;
          const e = this._overlayRef.overlayElement.style,
            t = this._overlayRef.hostElement,
            i = t.style;
          t.classList.remove(nN),
            (i.justifyContent =
              i.alignItems =
              e.marginTop =
              e.marginBottom =
              e.marginLeft =
              e.marginRight =
              e.position =
                ""),
            (this._overlayRef = null),
            (this._isDisposed = !0);
        }
      }
      let oQ = (() => {
          class n {
            constructor(t, i, r, s) {
              (this._viewportRuler = t),
                (this._document = i),
                (this._platform = r),
                (this._overlayContainer = s);
            }
            global() {
              return new sQ();
            }
            flexibleConnectedTo(t) {
              return new rQ(
                t,
                this._viewportRuler,
                this._document,
                this._platform,
                this._overlayContainer,
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(HO), se(kt), se(nc), se(QO));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        aQ = 0,
        Ib = (() => {
          class n {
            constructor(t, i, r, s, o, a, l, c, u, d, h, f) {
              (this.scrollStrategies = t),
                (this._overlayContainer = i),
                (this._componentFactoryResolver = r),
                (this._positionBuilder = s),
                (this._keyboardDispatcher = o),
                (this._injector = a),
                (this._ngZone = l),
                (this._document = c),
                (this._directionality = u),
                (this._location = d),
                (this._outsideClickDispatcher = h),
                (this._animationsModuleType = f);
            }
            create(t) {
              const i = this._createHostElement(),
                r = this._createPaneElement(i),
                s = this._createPortalOutlet(r),
                o = new ZO(t);
              return (
                (o.direction = o.direction || this._directionality.value),
                new nQ(
                  s,
                  i,
                  r,
                  o,
                  this._ngZone,
                  this._keyboardDispatcher,
                  this._document,
                  this._location,
                  this._outsideClickDispatcher,
                  "NoopAnimations" === this._animationsModuleType,
                )
              );
            }
            position() {
              return this._positionBuilder;
            }
            _createPaneElement(t) {
              const i = this._document.createElement("div");
              return (
                (i.id = "cdk-overlay-" + aQ++),
                i.classList.add("cdk-overlay-pane"),
                t.appendChild(i),
                i
              );
            }
            _createHostElement() {
              const t = this._document.createElement("div");
              return (
                this._overlayContainer.getContainerElement().appendChild(t), t
              );
            }
            _createPortalOutlet(t) {
              return (
                this._appRef || (this._appRef = this._injector.get(Ps)),
                new XK(
                  t,
                  this._componentFactoryResolver,
                  this._appRef,
                  this._injector,
                  this._document,
                )
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                se(QK),
                se(QO),
                se(go),
                se(oQ),
                se(eQ),
                se(fi),
                se(yt),
                se(kt),
                se(GK),
                se($h),
                se(tQ),
                se(Gg, 8),
              );
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      const uQ = {
        provide: new ve("cdk-connected-overlay-scroll-strategy"),
        deps: [Ib],
        useFactory: function cQ(n) {
          return () => n.scrollStrategies.reposition();
        },
      };
      let em = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({ providers: [Ib, uQ], imports: [Eb, Db, GO, GO] })),
            n
          );
        })(),
        dQ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci, em] })),
            n
          );
        })(),
        hQ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci, Yp] })),
            n
          );
        })(),
        bQ = (() => {
          class n {
            constructor(t) {
              this._platform = t;
            }
            isDisabled(t) {
              return t.hasAttribute("disabled");
            }
            isVisible(t) {
              return (
                (function SQ(n) {
                  return !!(
                    n.offsetWidth ||
                    n.offsetHeight ||
                    ("function" == typeof n.getClientRects &&
                      n.getClientRects().length)
                  );
                })(t) && "visible" === getComputedStyle(t).visibility
              );
            }
            isTabbable(t) {
              if (!this._platform.isBrowser) return !1;
              const i = (function MQ(n) {
                try {
                  return n.frameElement;
                } catch {
                  return null;
                }
              })(
                (function IQ(n) {
                  return (
                    (n.ownerDocument && n.ownerDocument.defaultView) || window
                  );
                })(t),
              );
              if (i && (-1 === oN(i) || !this.isVisible(i))) return !1;
              let r = t.nodeName.toLowerCase(),
                s = oN(t);
              return t.hasAttribute("contenteditable")
                ? -1 !== s
                : !(
                    "iframe" === r ||
                    "object" === r ||
                    (this._platform.WEBKIT &&
                      this._platform.IOS &&
                      !(function DQ(n) {
                        let e = n.nodeName.toLowerCase(),
                          t = "input" === e && n.type;
                        return (
                          "text" === t ||
                          "password" === t ||
                          "select" === e ||
                          "textarea" === e
                        );
                      })(t))
                  ) &&
                    ("audio" === r
                      ? !!t.hasAttribute("controls") && -1 !== s
                      : "video" === r
                      ? -1 !== s &&
                        (null !== s ||
                          this._platform.FIREFOX ||
                          t.hasAttribute("controls"))
                      : t.tabIndex >= 0);
            }
            isFocusable(t, i) {
              return (
                (function AQ(n) {
                  return (
                    !(function EQ(n) {
                      return (
                        (function xQ(n) {
                          return "input" == n.nodeName.toLowerCase();
                        })(n) && "hidden" == n.type
                      );
                    })(n) &&
                    ((function wQ(n) {
                      let e = n.nodeName.toLowerCase();
                      return (
                        "input" === e ||
                        "select" === e ||
                        "button" === e ||
                        "textarea" === e
                      );
                    })(n) ||
                      (function CQ(n) {
                        return (
                          (function TQ(n) {
                            return "a" == n.nodeName.toLowerCase();
                          })(n) && n.hasAttribute("href")
                        );
                      })(n) ||
                      n.hasAttribute("contenteditable") ||
                      sN(n))
                  );
                })(t) &&
                !this.isDisabled(t) &&
                (i?.ignoreVisibility || this.isVisible(t))
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(nc));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      function sN(n) {
        if (!n.hasAttribute("tabindex") || void 0 === n.tabIndex) return !1;
        let e = n.getAttribute("tabindex");
        return !(!e || isNaN(parseInt(e, 10)));
      }
      function oN(n) {
        if (!sN(n)) return null;
        const e = parseInt(n.getAttribute("tabindex") || "", 10);
        return isNaN(e) ? -1 : e;
      }
      class RQ {
        get enabled() {
          return this._enabled;
        }
        set enabled(e) {
          (this._enabled = e),
            this._startAnchor &&
              this._endAnchor &&
              (this._toggleAnchorTabIndex(e, this._startAnchor),
              this._toggleAnchorTabIndex(e, this._endAnchor));
        }
        constructor(e, t, i, r, s = !1) {
          (this._element = e),
            (this._checker = t),
            (this._ngZone = i),
            (this._document = r),
            (this._hasAttached = !1),
            (this.startAnchorListener = () => this.focusLastTabbableElement()),
            (this.endAnchorListener = () => this.focusFirstTabbableElement()),
            (this._enabled = !0),
            s || this.attachAnchors();
        }
        destroy() {
          const e = this._startAnchor,
            t = this._endAnchor;
          e &&
            (e.removeEventListener("focus", this.startAnchorListener),
            e.remove()),
            t &&
              (t.removeEventListener("focus", this.endAnchorListener),
              t.remove()),
            (this._startAnchor = this._endAnchor = null),
            (this._hasAttached = !1);
        }
        attachAnchors() {
          return (
            !!this._hasAttached ||
            (this._ngZone.runOutsideAngular(() => {
              this._startAnchor ||
                ((this._startAnchor = this._createAnchor()),
                this._startAnchor.addEventListener(
                  "focus",
                  this.startAnchorListener,
                )),
                this._endAnchor ||
                  ((this._endAnchor = this._createAnchor()),
                  this._endAnchor.addEventListener(
                    "focus",
                    this.endAnchorListener,
                  ));
            }),
            this._element.parentNode &&
              (this._element.parentNode.insertBefore(
                this._startAnchor,
                this._element,
              ),
              this._element.parentNode.insertBefore(
                this._endAnchor,
                this._element.nextSibling,
              ),
              (this._hasAttached = !0)),
            this._hasAttached)
          );
        }
        focusInitialElementWhenReady(e) {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusInitialElement(e)));
          });
        }
        focusFirstTabbableElementWhenReady(e) {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusFirstTabbableElement(e)));
          });
        }
        focusLastTabbableElementWhenReady(e) {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusLastTabbableElement(e)));
          });
        }
        _getRegionBoundary(e) {
          const t = this._element.querySelectorAll(
            `[cdk-focus-region-${e}], [cdkFocusRegion${e}], [cdk-focus-${e}]`,
          );
          return "start" == e
            ? t.length
              ? t[0]
              : this._getFirstTabbableElement(this._element)
            : t.length
            ? t[t.length - 1]
            : this._getLastTabbableElement(this._element);
        }
        focusInitialElement(e) {
          const t = this._element.querySelector(
            "[cdk-focus-initial], [cdkFocusInitial]",
          );
          if (t) {
            if (!this._checker.isFocusable(t)) {
              const i = this._getFirstTabbableElement(t);
              return i?.focus(e), !!i;
            }
            return t.focus(e), !0;
          }
          return this.focusFirstTabbableElement(e);
        }
        focusFirstTabbableElement(e) {
          const t = this._getRegionBoundary("start");
          return t && t.focus(e), !!t;
        }
        focusLastTabbableElement(e) {
          const t = this._getRegionBoundary("end");
          return t && t.focus(e), !!t;
        }
        hasAttached() {
          return this._hasAttached;
        }
        _getFirstTabbableElement(e) {
          if (this._checker.isFocusable(e) && this._checker.isTabbable(e))
            return e;
          const t = e.children;
          for (let i = 0; i < t.length; i++) {
            const r =
              t[i].nodeType === this._document.ELEMENT_NODE
                ? this._getFirstTabbableElement(t[i])
                : null;
            if (r) return r;
          }
          return null;
        }
        _getLastTabbableElement(e) {
          if (this._checker.isFocusable(e) && this._checker.isTabbable(e))
            return e;
          const t = e.children;
          for (let i = t.length - 1; i >= 0; i--) {
            const r =
              t[i].nodeType === this._document.ELEMENT_NODE
                ? this._getLastTabbableElement(t[i])
                : null;
            if (r) return r;
          }
          return null;
        }
        _createAnchor() {
          const e = this._document.createElement("div");
          return (
            this._toggleAnchorTabIndex(this._enabled, e),
            e.classList.add("cdk-visually-hidden"),
            e.classList.add("cdk-focus-trap-anchor"),
            e.setAttribute("aria-hidden", "true"),
            e
          );
        }
        _toggleAnchorTabIndex(e, t) {
          e ? t.setAttribute("tabindex", "0") : t.removeAttribute("tabindex");
        }
        toggleAnchors(e) {
          this._startAnchor &&
            this._endAnchor &&
            (this._toggleAnchorTabIndex(e, this._startAnchor),
            this._toggleAnchorTabIndex(e, this._endAnchor));
        }
        _executeOnStable(e) {
          this._ngZone.isStable
            ? e()
            : this._ngZone.onStable.pipe(xi(1)).subscribe(e);
        }
      }
      class PQ extends RQ {
        get enabled() {
          return this._enabled;
        }
        set enabled(e) {
          (this._enabled = e),
            this._enabled
              ? this._focusTrapManager.register(this)
              : this._focusTrapManager.deregister(this);
        }
        constructor(e, t, i, r, s, o, a) {
          super(e, t, i, r, a.defer),
            (this._focusTrapManager = s),
            (this._inertStrategy = o),
            this._focusTrapManager.register(this);
        }
        destroy() {
          this._focusTrapManager.deregister(this), super.destroy();
        }
        _enable() {
          this._inertStrategy.preventFocus(this), this.toggleAnchors(!0);
        }
        _disable() {
          this._inertStrategy.allowFocus(this), this.toggleAnchors(!1);
        }
      }
      const OQ = new ve("FOCUS_TRAP_INERT_STRATEGY");
      class NQ {
        constructor() {
          this._listener = null;
        }
        preventFocus(e) {
          this._listener &&
            e._document.removeEventListener("focus", this._listener, !0),
            (this._listener = (t) => this._trapFocus(e, t)),
            e._ngZone.runOutsideAngular(() => {
              e._document.addEventListener("focus", this._listener, !0);
            });
        }
        allowFocus(e) {
          this._listener &&
            (e._document.removeEventListener("focus", this._listener, !0),
            (this._listener = null));
        }
        _trapFocus(e, t) {
          const i = t.target,
            r = e._element;
          i &&
            !r.contains(i) &&
            !i.closest?.("div.cdk-overlay-pane") &&
            setTimeout(() => {
              e.enabled &&
                !r.contains(e._document.activeElement) &&
                e.focusFirstTabbableElement();
            });
        }
      }
      let LQ = (() => {
          class n {
            constructor() {
              this._focusTrapStack = [];
            }
            register(t) {
              this._focusTrapStack = this._focusTrapStack.filter(
                (r) => r !== t,
              );
              let i = this._focusTrapStack;
              i.length && i[i.length - 1]._disable(), i.push(t), t._enable();
            }
            deregister(t) {
              t._disable();
              const i = this._focusTrapStack,
                r = i.indexOf(t);
              -1 !== r &&
                (i.splice(r, 1), i.length && i[i.length - 1]._enable());
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        FQ = (() => {
          class n {
            constructor(t, i, r, s, o) {
              (this._checker = t),
                (this._ngZone = i),
                (this._focusTrapManager = r),
                (this._document = s),
                (this._inertStrategy = o || new NQ());
            }
            create(t, i = { defer: !1 }) {
              let r;
              return (
                (r = "boolean" == typeof i ? { defer: i } : i),
                new PQ(
                  t,
                  this._checker,
                  this._ngZone,
                  this._document,
                  this._focusTrapManager,
                  this._inertStrategy,
                  r,
                )
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(se(bQ), se(yt), se(LQ), se(kt), se(OQ, 8));
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      const UQ = ["dialog"],
        BQ = ["content"];
      function VQ(n, e) {}
      const HQ = function (n) {
        return { "rounded-0": n };
      };
      class zQ {
        constructor() {
          L(this, "animation", !0),
            L(this, "backdrop", !0),
            L(this, "ignoreBackdropClick", !1),
            L(this, "keyboard", !0),
            L(this, "modalClass", ""),
            L(this, "containerClass", ""),
            L(this, "viewContainerRef", void 0),
            L(this, "data", null),
            L(this, "nonInvasive", !1);
        }
      }
      class aN {
        constructor(e, t) {
          L(this, "_overlayRef", void 0),
            L(this, "_container", void 0),
            L(this, "component", void 0),
            L(this, "onClose$", new en()),
            L(this, "onClose", this.onClose$.asObservable()),
            (this._overlayRef = e),
            (this._container = t);
        }
        close(e) {
          this._container._close(),
            setTimeout(() => {
              this._container._config.nonInvasive &&
                this._container._onNonInvasiveModalHidden(),
                this._container._restoreScrollbar(),
                this.onClose$.next(e),
                this.onClose$.complete(),
                this._overlayRef.detach(),
                this._overlayRef.dispose();
            }, this._container.MODAL_TRANSITION);
        }
      }
      const Rb = "modal-open",
        lN = "modal-non-invasive-open",
        cN = "modal-non-invasive-show";
      let uN = (() => {
          class n {
            get hasAnimation() {
              return this._config.animation;
            }
            onWindowResize() {
              this._ngZone.runOutsideAngular(() => {
                this._config.nonInvasive && this._handleWindowResize();
              });
            }
            get host() {
              return this._elementRef.nativeElement;
            }
            constructor(t, i, r, s, o) {
              L(this, "_document", void 0),
                L(this, "_elementRef", void 0),
                L(this, "_renderer", void 0),
                L(this, "_focusTrapFactory", void 0),
                L(this, "_ngZone", void 0),
                L(this, "_portalOutlet", void 0),
                L(this, "modalDialog", void 0),
                L(this, "modalContent", void 0),
                L(this, "_destroy$", new en()),
                L(this, "backdropClick$", new en()),
                L(this, "_config", void 0),
                L(this, "BACKDROP_TRANSITION", 150),
                L(this, "MODAL_TRANSITION", 200),
                L(this, "NON_INVASIVE_TRANSITION", 450),
                L(this, "_previouslyFocusedElement", void 0),
                L(this, "_focusTrap", void 0),
                L(this, "modal", !0),
                L(this, "_isScrollable", !1),
                L(this, "_isBottomRight", !1),
                L(this, "_isBottomLeft", !1),
                L(this, "_isTopRight", !1),
                L(this, "_isTopLeft", !1),
                L(this, "_isSideTopModal", !1),
                L(this, "_isSideBottomModal", !1),
                L(this, "_isSideModal", !1),
                L(this, "_isModalBottom", !1),
                L(this, "_modalContentRect", void 0),
                L(this, "_modalContentComputedStyles", void 0),
                L(this, "_modalDialogComputedStyles", void 0),
                L(this, "_topOffset", 0),
                L(this, "_leftOffset", 0),
                L(this, "_rightOffset", 0),
                L(this, "_bottomOffset", 0),
                (this._document = t),
                (this._elementRef = i),
                (this._renderer = r),
                (this._focusTrapFactory = s),
                (this._ngZone = o);
            }
            ngOnInit() {
              this._updateContainerClass(),
                this._renderer.setStyle(this.host, "display", "block"),
                this._config.nonInvasive ||
                  ((this._focusTrap = this._focusTrapFactory.create(this.host)),
                  (this._previouslyFocusedElement =
                    this._document.activeElement)),
                this._config.animation
                  ? setTimeout(() => {
                      this._renderer.addClass(this.host, "show"),
                        setTimeout(() => {
                          this._focusTrap?.focusInitialElementWhenReady();
                        }, this.MODAL_TRANSITION);
                    }, this.BACKDROP_TRANSITION)
                  : this._focusTrap?.focusInitialElementWhenReady();
            }
            ngAfterViewInit() {
              const t = this._document.body.offsetWidth;
              this._renderer.addClass(this._document.body, Rb),
                this._config.nonInvasive &&
                  (this._renderer.addClass(this._document.body, lN),
                  setTimeout(() => {
                    this._onNonInvasiveModalShown();
                  }, this.NON_INVASIVE_TRANSITION)),
                this._config.nonInvasive ||
                  this._renderer.setStyle(
                    this._document.body,
                    "overflow",
                    "hidden",
                  ),
                this._config.nonInvasive ||
                  this._renderer.setStyle(
                    this._document.body,
                    "padding-right",
                    this._document.body.offsetWidth - t + "px",
                  ),
                !this._config.ignoreBackdropClick &&
                  !this._config.nonInvasive &&
                  Ks(this.host, "mousedown")
                    .pipe(
                      Yi((r) => {
                        const s = r.target,
                          o = this.modalDialog.nativeElement,
                          a = s !== o,
                          l = !o.contains(s);
                        return a && l;
                      }),
                      Cb(this._destroy$),
                    )
                    .subscribe((r) => {
                      this.backdropClick$.next(r);
                    });
            }
            ngOnDestroy() {
              this._previouslyFocusedElement?.focus(),
                this._focusTrap?.destroy(),
                this._destroy$.next(),
                this._destroy$.complete();
            }
            _updateContainerClass() {
              "" === this._config.containerClass ||
                (this._config.containerClass.length &&
                  0 === this._config.containerClass.length) ||
                this._config.containerClass.split(" ").forEach((i) => {
                  this._renderer.addClass(this.host, i);
                });
            }
            _onNonInvasiveModalShown() {
              (this._isScrollable = this._config.modalClass.includes(
                "modal-dialog-scrollable",
              )),
                (this._isBottomRight =
                  this._config.modalClass.includes("modal-bottom-right")),
                (this._isBottomLeft =
                  this._config.modalClass.includes("modal-bottom-left")),
                (this._isTopRight =
                  this._config.modalClass.includes("modal-top-right")),
                (this._isTopLeft =
                  this._config.modalClass.includes("modal-top-left")),
                (this._isModalBottom =
                  this._config.modalClass.includes("modal-bottom")),
                (this._isSideTopModal = this._isTopLeft || this._isTopRight),
                (this._isSideBottomModal =
                  this._isBottomLeft || this._isBottomRight),
                (this._isSideModal =
                  this._isSideTopModal || this._isSideBottomModal),
                (this._modalContentRect =
                  this.modalContent.nativeElement.getBoundingClientRect()),
                (this._modalContentComputedStyles = window.getComputedStyle(
                  this.modalContent.nativeElement,
                )),
                (this._modalDialogComputedStyles = window.getComputedStyle(
                  this.modalDialog.nativeElement,
                )),
                (this._topOffset = parseInt(
                  this._modalDialogComputedStyles.top,
                  0,
                )),
                (this._leftOffset = parseInt(
                  this._modalDialogComputedStyles.left,
                  0,
                )),
                (this._rightOffset = parseInt(
                  this._modalDialogComputedStyles.right,
                  0,
                )),
                (this._bottomOffset = parseInt(
                  this._modalDialogComputedStyles.bottom,
                  0,
                )),
                this._renderer.addClass(this.host, cN),
                this._setNonInvasiveStyles();
            }
            _setNonInvasiveStyles(t = 0, i = 0) {
              const r = window.innerWidth >= 992;
              this._renderer.setStyle(
                this.host,
                "left",
                `${this._modalContentRect.left + t}px`,
              ),
                this._renderer.setStyle(
                  this.host,
                  "width",
                  this._modalContentComputedStyles.width,
                ),
                this._isScrollable ||
                  (this._renderer.setStyle(
                    this.host,
                    "height",
                    this._modalContentComputedStyles.height,
                  ),
                  this._renderer.setStyle(this.host, "display", "")),
                r &&
                  ((this._isSideBottomModal || this._isModalBottom) &&
                    this._renderer.setStyle(
                      this.host,
                      "top",
                      `${this._modalContentRect.top + i}px`,
                    ),
                  this._isSideModal &&
                    this._renderer.setStyle(this.host, "overflowX", "auto"));
            }
            _onNonInvasiveModalHidden() {
              this._renderer.removeClass(this.host, cN),
                this._resetNonInvasiveStyles(),
                this._removeNonInvasiveClass();
            }
            _resetNonInvasiveStyles() {
              this._renderer.setStyle(this.host, "left", ""),
                this._renderer.setStyle(this.host, "top", ""),
                this._renderer.setStyle(this.host, "height", ""),
                this._renderer.setStyle(this.host, "width", ""),
                this._isScrollable ||
                  this._renderer.setStyle(this.host, "display", ""),
                this._isSideModal &&
                  this._renderer.setStyle(this.host, "overflowX", "");
            }
            _removeNonInvasiveClass() {
              this._document.body.querySelector(
                ".modal.show.modal-non-invasive-show",
              )
                ? this._renderer.addClass(this._document.body, Rb)
                : this._renderer.removeClass(this._document.body, lN);
            }
            _handleWindowResize() {
              const t = this.host.querySelector(".modal-content");
              if (
                (this._resetNonInvasiveStyles(),
                (this._modalContentRect = t.getBoundingClientRect()),
                (this._modalContentComputedStyles = window.getComputedStyle(t)),
                this._isSideTopModal || this._isSideBottomModal)
              ) {
                let i = 0,
                  r = 0;
                (this._isBottomRight || this._isBottomLeft) &&
                  (r = -this._bottomOffset),
                  (this._isBottomRight || this._isTopRight) &&
                    (i = -this._rightOffset),
                  (this._isBottomLeft || this._isTopLeft) &&
                    (i = this._leftOffset),
                  this._setNonInvasiveStyles(i, r);
              } else this._setNonInvasiveStyles();
            }
            _close() {
              this._config.animation &&
                this._renderer.removeClass(this.host, "show");
              const t = Array.from(this.host.querySelectorAll("iframe")),
                i = Array.from(this.host.querySelectorAll("video"));
              t.forEach((r) => {
                const s = r.getAttribute("src");
                this._renderer.setAttribute(r, "src", s);
              }),
                i.forEach((r) => {
                  r.pause();
                });
            }
            _restoreScrollbar() {
              this._renderer.removeClass(this._document.body, Rb),
                this._renderer.removeStyle(this._document.body, "overflow"),
                this._renderer.removeStyle(
                  this._document.body,
                  "padding-right",
                );
            }
            attachComponentPortal(t) {
              return this._portalOutlet.attachComponentPortal(t);
            }
            attachTemplatePortal(t) {
              return this._portalOutlet.attachTemplatePortal(t);
            }
          }
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)(re(kt), re(Rn), re(or), re(FQ), re(yt));
            }),
            L(
              n,
              "\u0275cmp",
              Hi({
                type: n,
                selectors: [["mdb-modal-container"]],
                viewQuery: function (t, i) {
                  if ((1 & t && (So(jO, 7), So(UQ, 7), So(BQ, 7)), 2 & t)) {
                    let r;
                    Kr((r = Qr())) && (i._portalOutlet = r.first),
                      Kr((r = Qr())) && (i.modalDialog = r.first),
                      Kr((r = Qr())) && (i.modalContent = r.first);
                  }
                },
                hostVars: 4,
                hostBindings: function (t, i) {
                  1 & t &&
                    Fn(
                      "resize",
                      function (s) {
                        return i.onWindowResize(s);
                      },
                      0,
                      gE,
                    ),
                    2 & t && Za("modal", i.modal)("fade", i.hasAnimation);
                },
                decls: 5,
                vars: 5,
                consts: [
                  ["dialog", ""],
                  [1, "modal-content", 3, "ngClass"],
                  ["content", ""],
                  ["cdkPortalOutlet", ""],
                ],
                template: function (t, i) {
                  1 & t &&
                    (tt(0, "div", null, 0)(2, "div", 1, 2),
                    y_(4, VQ, 0, 0, "ng-template", 3),
                    ot()()),
                    2 & t &&
                      (WC(
                        "modal-dialog" +
                          (i._config.modalClass
                            ? " " + i._config.modalClass
                            : ""),
                      ),
                      Wi(2),
                      yo(
                        "ngClass",
                        B_(3, HQ, i._config.modalClass.includes("modal-frame")),
                      ));
                },
                dependencies: [Iv, jO],
                encapsulation: 2,
              }),
            ),
            n
          );
        })(),
        WQ = (() => {
          class n {
            constructor(t, i, r, s) {
              L(this, "_document", void 0),
                L(this, "_overlay", void 0),
                L(this, "_injector", void 0),
                L(this, "_cfr", void 0),
                (this._document = t),
                (this._overlay = i),
                (this._injector = r),
                (this._cfr = s);
            }
            open(t, i) {
              const r = new zQ();
              i = i ? Object.assign(r, i) : r;
              const s = this._createOverlay(i),
                o = this._createContainer(s, i),
                a = this._createContent(t, o, s, i);
              return this._registerListeners(a, i, o), a;
            }
            _createOverlay(t) {
              const i = this._getOverlayConfig(t);
              return this._overlay.create(i);
            }
            _getOverlayConfig(t) {
              return new ZO({
                positionStrategy: this._overlay.position().global(),
                scrollStrategy: this._overlay.scrollStrategies.noop(),
                hasBackdrop: !t.nonInvasive && t.backdrop,
                backdropClass: "mdb-backdrop",
              });
            }
            _createContainer(t, i) {
              const r = new Tb(uN, null, this._injector, this._cfr),
                s = t.attach(r);
              return (s.instance._config = i), s.instance;
            }
            _createContent(t, i, r, s) {
              const o = new aN(r, i);
              if (t instanceof Rr)
                i.attachTemplatePortal(
                  new WO(t, null, { $implicit: s.data, modalRef: o }),
                );
              else {
                const a = this._createInjector(s, o, i),
                  l = i.attachComponentPortal(new Tb(t, s.viewContainerRef, a));
                s.data && Object.assign(l.instance, { ...s.data }),
                  (o.component = l.instance);
              }
              return o;
            }
            _createInjector(t, i, r) {
              return fi.create({
                parent:
                  (t && t.viewContainerRef && t.viewContainerRef.injector) ||
                  this._injector,
                providers: [
                  { provide: uN, useValue: r },
                  { provide: aN, useValue: i },
                ],
              });
            }
            _registerListeners(t, i, r) {
              r.backdropClick$.pipe(xi(1)).subscribe(() => {
                t.close();
              }),
                i.keyboard &&
                  Ks(r._elementRef.nativeElement, "keydown")
                    .pipe(
                      Yi((s) => "Escape" === s.key),
                      xi(1),
                    )
                    .subscribe(() => {
                      t.close();
                    });
            }
          }
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)(se(kt), se(Ib), se(fi), se(go));
            }),
            L(n, "\u0275prov", Ee({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        $Q = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ providers: [WQ], imports: [Ci, em, Db] })),
            n
          );
        })(),
        jQ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci, em] })),
            n
          );
        })(),
        qQ = (() => {
          class n {
            get name() {
              return this._name;
            }
            set name(t) {
              this._name = t;
            }
            get checked() {
              return this._checked;
            }
            set checked(t) {
              this._checked = ed(t);
            }
            get value() {
              return this._value;
            }
            set value(t) {
              this._value = t;
            }
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              this._disabled = ed(t);
            }
            get isDisabled() {
              return this._disabled;
            }
            get isChecked() {
              return this._checked;
            }
            get nameAttr() {
              return this.name;
            }
            constructor() {
              L(this, "_name", void 0),
                L(this, "_checked", !1),
                L(this, "_value", null),
                L(this, "_disabled", !1);
            }
            _updateName(t) {
              this._name = t;
            }
            _updateChecked(t) {
              this._checked = t;
            }
            _updateDisabledState(t) {
              this._disabled = t;
            }
          }
          return (
            L(n, "ngAcceptInputType_checked", void 0),
            L(n, "ngAcceptInputType_disabled", void 0),
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(
              n,
              "\u0275dir",
              Ue({
                type: n,
                selectors: [["", "mdbRadio", ""]],
                hostVars: 3,
                hostBindings: function (t, i) {
                  2 & t &&
                    (Ph("disabled", i.isDisabled)("checked", i.isChecked),
                    ar("name", i.nameAttr));
                },
                inputs: {
                  name: "name",
                  checked: "checked",
                  value: "value",
                  disabled: "disabled",
                },
              }),
            ),
            n
          );
        })();
      const XQ = { provide: Ni, useExisting: Ot(() => YQ), multi: !0 };
      let YQ = (() => {
          class n {
            constructor() {
              L(this, "radios", void 0),
                L(this, "_value", void 0),
                L(this, "_name", void 0),
                L(this, "_disabled", !1),
                L(this, "_destroy$", new en()),
                L(this, "onChange", (t) => {}),
                L(this, "onTouched", () => {});
            }
            get value() {
              return this._value;
            }
            set value(t) {
              (this._value = t), this.radios && this._updateChecked();
            }
            get name() {
              return this._name;
            }
            set name(t) {
              (this._name = t), this.radios && this._updateNames();
            }
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              (this._disabled = t), this.radios && this._updateDisabled();
            }
            ngAfterContentInit() {
              this._updateNames(),
                this._updateDisabled(),
                this.radios.changes
                  .pipe(
                    fA(this.radios),
                    nr((t) => Sn(Promise.resolve(t))),
                    Cb(this._destroy$),
                  )
                  .subscribe(() => this._updateRadiosState());
            }
            ngOnDestroy() {
              this._destroy$.next(), this._destroy$.complete();
            }
            _updateRadiosState() {
              this._updateNames(),
                this._updateChecked(),
                this._updateDisabled();
            }
            _updateNames() {
              this.radios.forEach((t) => t._updateName(this.name));
            }
            _updateChecked() {
              this.radios.forEach((t) => {
                t._updateChecked(t.value === this._value);
              });
            }
            _updateDisabled() {
              this.radios.forEach((t) =>
                t._updateDisabledState(this._disabled),
              );
            }
            registerOnChange(t) {
              this.onChange = t;
            }
            registerOnTouched(t) {
              this.onTouched = t;
            }
            setDisabledState(t) {
              (this._disabled = t), this._updateDisabled();
            }
            writeValue(t) {
              this.value = t;
            }
          }
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(
              n,
              "\u0275dir",
              Ue({
                type: n,
                selectors: [["", "mdbRadioGroup", ""]],
                contentQueries: function (t, i, r) {
                  if (
                    (1 & t &&
                      (function Y_(n, e, t, i) {
                        const r = vt();
                        if (r.firstCreatePass) {
                          const s = Nn();
                          mT(r, new hT(e, t, i), s.index),
                            (function lz(n, e) {
                              const t =
                                n.contentQueries || (n.contentQueries = []);
                              e !== (t.length ? t[t.length - 1] : -1) &&
                                t.push(n.queries.length - 1, e);
                            })(r, n),
                            2 == (2 & t) && (r.staticContentQueries = !0);
                        }
                        pT(r, ne(), t);
                      })(r, qQ, 5),
                    2 & t)
                  ) {
                    let s;
                    Kr((s = Qr())) && (i.radios = s);
                  }
                },
                inputs: { value: "value", name: "name", disabled: "disabled" },
                features: [Ht([XQ])],
              }),
            ),
            n
          );
        })(),
        ZQ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci, Yp] })),
            n
          );
        })();
      const KQ = ["input"],
        QQ = ["thumb"],
        JQ = ["thumbValue"],
        eJ = function (n) {
          return { "thumb-active": n };
        },
        tJ = { provide: Ni, useExisting: Ot(() => nJ), multi: !0 };
      let nJ = (() => {
          class n {
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              this._disabled = ed(t);
            }
            get default() {
              return this._default;
            }
            set default(t) {
              this._default = t;
            }
            onchange(t) {
              this.onChange(t.target.value);
            }
            onInput() {
              this.rangeValueChange.emit({ value: this.value }),
                this.focusRangeInput();
            }
            constructor(t) {
              L(this, "_cdRef", void 0),
                L(this, "input", void 0),
                L(this, "thumb", void 0),
                L(this, "thumbValue", void 0),
                L(this, "id", void 0),
                L(this, "required", void 0),
                L(this, "name", void 0),
                L(this, "value", void 0),
                L(this, "_disabled", void 0),
                L(this, "label", void 0),
                L(this, "min", 0),
                L(this, "max", 100),
                L(this, "step", void 0),
                L(this, "_default", void 0),
                L(this, "defaultRangeCounterClass", void 0),
                L(this, "rangeValueChange", new Rt()),
                L(this, "visibility", !1),
                L(this, "thumbStyle", void 0),
                L(this, "onChange", (i) => {}),
                L(this, "onTouched", () => {}),
                (this._cdRef = t);
            }
            ngAfterViewInit() {
              this.thumbPositionUpdate();
            }
            focusRangeInput() {
              this.input.nativeElement.focus(), (this.visibility = !0);
            }
            blurRangeInput() {
              this.input.nativeElement.blur(), (this.visibility = !1);
            }
            thumbPositionUpdate() {
              const t = this.input.nativeElement,
                i = t.value,
                r = t.min ? t.min : 0,
                o = Number((100 * (i - r)) / ((t.max ? t.max : 100) - r));
              (this.value = i),
                (this.thumbStyle = {
                  left: `calc(${o}% + (${8 - 0.15 * o}px))`,
                });
            }
            writeValue(t) {
              (this.value = t),
                this._cdRef.markForCheck(),
                setTimeout(() => {
                  this.thumbPositionUpdate();
                }, 0);
            }
            registerOnChange(t) {
              this.onChange = t;
            }
            registerOnTouched(t) {
              this.onTouched = t;
            }
            setDisabledState(t) {
              this.disabled = t;
            }
          }
          return (
            L(n, "ngAcceptInputType_default", void 0),
            L(n, "ngAcceptInputType_disabled", void 0),
            L(n, "\u0275fac", function (t) {
              return new (t || n)(re(tu));
            }),
            L(
              n,
              "\u0275cmp",
              Hi({
                type: n,
                selectors: [["mdb-range"]],
                viewQuery: function (t, i) {
                  if ((1 & t && (So(KQ, 5), So(QQ, 5), So(JQ, 5)), 2 & t)) {
                    let r;
                    Kr((r = Qr())) && (i.input = r.first),
                      Kr((r = Qr())) && (i.thumb = r.first),
                      Kr((r = Qr())) && (i.thumbValue = r.first);
                  }
                },
                hostBindings: function (t, i) {
                  1 & t &&
                    Fn("change", function (s) {
                      return i.onchange(s);
                    })("input", function () {
                      return i.onInput();
                    });
                },
                inputs: {
                  id: "id",
                  required: "required",
                  name: "name",
                  value: "value",
                  disabled: "disabled",
                  label: "label",
                  min: "min",
                  max: "max",
                  step: "step",
                  default: "default",
                  defaultRangeCounterClass: "defaultRangeCounterClass",
                },
                outputs: { rangeValueChange: "rangeValueChange" },
                features: [Ht([tJ])],
                decls: 10,
                vars: 14,
                consts: [
                  ["for", "id", 1, "form-label"],
                  [1, "range"],
                  [
                    "type",
                    "range",
                    "min",
                    "0",
                    "max",
                    "5",
                    1,
                    "form-range",
                    3,
                    "name",
                    "disabled",
                    "id",
                    "min",
                    "max",
                    "step",
                    "value",
                    "input",
                    "blur",
                    "mousedown",
                    "mouseup",
                    "touchstart",
                    "touchend",
                  ],
                  ["input", ""],
                  [1, "thumb", 3, "ngStyle", "ngClass"],
                  ["thumb", ""],
                  [1, "thumb-value"],
                  ["thumbValue", ""],
                ],
                template: function (t, i) {
                  1 & t &&
                    (tt(0, "label", 0),
                    Nt(1),
                    ot(),
                    tt(2, "div", 1)(3, "input", 2, 3),
                    Fn("input", function () {
                      return i.thumbPositionUpdate();
                    })("blur", function () {
                      return i.blurRangeInput();
                    })("mousedown", function () {
                      return i.focusRangeInput();
                    })("mouseup", function () {
                      return i.blurRangeInput();
                    })("touchstart", function () {
                      return i.focusRangeInput();
                    })("touchend", function () {
                      return i.blurRangeInput();
                    }),
                    ot(),
                    tt(5, "span", 4, 5)(7, "span", 6, 7),
                    Nt(9),
                    ot()()()),
                    2 & t &&
                      (Wi(1),
                      Ka(i.label),
                      Wi(2),
                      yo("name", i.name)("disabled", i.disabled)("id", i.id)(
                        "min",
                        i.min,
                      )("max", i.max)("step", i.step)("value", i.value)(
                        "id",
                        i.id,
                      ),
                      Wi(2),
                      yo("ngStyle", i.thumbStyle)(
                        "ngClass",
                        B_(12, eJ, i.visibility),
                      ),
                      Wi(4),
                      Ka(i.value));
                },
                dependencies: [Iv, FD],
                encapsulation: 2,
                changeDetection: 0,
              }),
            ),
            n
          );
        })(),
        iJ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci, Yp] })),
            n
          );
        })(),
        rJ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({})),
            n
          );
        })(),
        sJ = (() => {
          class n {
            constructor() {
              L(this, "scrollSpys", []),
                L(this, "activeSubject", new en()),
                L(this, "active$", this.activeSubject);
            }
            addScrollspy(t) {
              this.scrollSpys.push(t);
            }
            removeScrollspy(t) {
              const i = this.scrollSpys.findIndex((r) => r.id === t);
              this.scrollSpys.splice(i, 1);
            }
            updateActiveState(t, i) {
              const r = this.scrollSpys.find((o) => o.id === t);
              if (!r) return;
              const s = r.links.find((o) => o.id === i);
              this.setActiveLink(s);
            }
            removeActiveState(t, i) {
              const r = this.scrollSpys.find((o) => o.id === t);
              if (!r) return;
              const s = r.links.find((o) => o.id === i);
              s && ((s.active = !1), s.detectChanges());
            }
            setActiveLink(t) {
              t &&
                ((t.active = !0),
                t.detectChanges(),
                this.activeSubject.next(t));
            }
            removeActiveLinks(t) {
              const i = this.scrollSpys.find((r) => r.id === t);
              i &&
                i.links.forEach((r) => {
                  (r.active = !1), r.detectChanges();
                });
            }
          }
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275prov", Ee({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        oJ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ providers: [sJ] })),
            n
          );
        })();
      new ve("MdbTabContentDirective"), new ve("MdbTabTitleDirective");
      let hJ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci, Db] })),
            n
          );
        })(),
        fJ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci, em] })),
            n
          );
        })(),
        pJ = (() => {
          class n {}
          return (
            L(n, "\u0275fac", function (t) {
              return new (t || n)();
            }),
            L(n, "\u0275mod", Et({ type: n })),
            L(n, "\u0275inj", bt({ imports: [Ci] })),
            n
          );
        })();
      class dN {}
      class mJ {}
      const ys = "*";
      function hN(n, e = null) {
        return { type: 2, steps: n, options: e };
      }
      function fN(n) {
        return { type: 6, styles: n, offset: null };
      }
      class ld {
        constructor(e = 0, t = 0) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._originalOnDoneFns = []),
            (this._originalOnStartFns = []),
            (this._started = !1),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._position = 0),
            (this.parentPlayer = null),
            (this.totalTime = e + t);
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        onStart(e) {
          this._originalOnStartFns.push(e), this._onStartFns.push(e);
        }
        onDone(e) {
          this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        init() {}
        play() {
          this.hasStarted() || (this._onStart(), this.triggerMicrotask()),
            (this._started = !0);
        }
        triggerMicrotask() {
          queueMicrotask(() => this._onFinish());
        }
        _onStart() {
          this._onStartFns.forEach((e) => e()), (this._onStartFns = []);
        }
        pause() {}
        restart() {}
        finish() {
          this._onFinish();
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this.hasStarted() || this._onStart(),
            this.finish(),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          (this._started = !1),
            (this._finished = !1),
            (this._onStartFns = this._originalOnStartFns),
            (this._onDoneFns = this._originalOnDoneFns);
        }
        setPosition(e) {
          this._position = this.totalTime ? e * this.totalTime : 1;
        }
        getPosition() {
          return this.totalTime ? this._position / this.totalTime : 1;
        }
        triggerCallback(e) {
          const t = "start" == e ? this._onStartFns : this._onDoneFns;
          t.forEach((i) => i()), (t.length = 0);
        }
      }
      class pN {
        constructor(e) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._onDestroyFns = []),
            (this.parentPlayer = null),
            (this.totalTime = 0),
            (this.players = e);
          let t = 0,
            i = 0,
            r = 0;
          const s = this.players.length;
          0 == s
            ? queueMicrotask(() => this._onFinish())
            : this.players.forEach((o) => {
                o.onDone(() => {
                  ++t == s && this._onFinish();
                }),
                  o.onDestroy(() => {
                    ++i == s && this._onDestroy();
                  }),
                  o.onStart(() => {
                    ++r == s && this._onStart();
                  });
              }),
            (this.totalTime = this.players.reduce(
              (o, a) => Math.max(o, a.totalTime),
              0,
            ));
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        init() {
          this.players.forEach((e) => e.init());
        }
        onStart(e) {
          this._onStartFns.push(e);
        }
        _onStart() {
          this.hasStarted() ||
            ((this._started = !0),
            this._onStartFns.forEach((e) => e()),
            (this._onStartFns = []));
        }
        onDone(e) {
          this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this.parentPlayer || this.init(),
            this._onStart(),
            this.players.forEach((e) => e.play());
        }
        pause() {
          this.players.forEach((e) => e.pause());
        }
        restart() {
          this.players.forEach((e) => e.restart());
        }
        finish() {
          this._onFinish(), this.players.forEach((e) => e.finish());
        }
        destroy() {
          this._onDestroy();
        }
        _onDestroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._onFinish(),
            this.players.forEach((e) => e.destroy()),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          this.players.forEach((e) => e.reset()),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1);
        }
        setPosition(e) {
          const t = e * this.totalTime;
          this.players.forEach((i) => {
            const r = i.totalTime ? Math.min(1, t / i.totalTime) : 1;
            i.setPosition(r);
          });
        }
        getPosition() {
          const e = this.players.reduce(
            (t, i) => (null === t || i.totalTime > t.totalTime ? i : t),
            null,
          );
          return null != e ? e.getPosition() : 0;
        }
        beforeDestroy() {
          this.players.forEach((e) => {
            e.beforeDestroy && e.beforeDestroy();
          });
        }
        triggerCallback(e) {
          const t = "start" == e ? this._onStartFns : this._onDoneFns;
          t.forEach((i) => i()), (t.length = 0);
        }
      }
      function mN(n) {
        return new Y(3e3, !1);
      }
      function to(n) {
        switch (n.length) {
          case 0:
            return new ld();
          case 1:
            return n[0];
          default:
            return new pN(n);
        }
      }
      function gN(n, e, t = new Map(), i = new Map()) {
        const r = [],
          s = [];
        let o = -1,
          a = null;
        if (
          (e.forEach((l) => {
            const c = l.get("offset"),
              u = c == o,
              d = (u && a) || new Map();
            l.forEach((h, f) => {
              let p = f,
                _ = h;
              if ("offset" !== f)
                switch (((p = n.normalizePropertyName(p, r)), _)) {
                  case "!":
                    _ = t.get(f);
                    break;
                  case ys:
                    _ = i.get(f);
                    break;
                  default:
                    _ = n.normalizeStyleValue(f, p, _, r);
                }
              d.set(p, _);
            }),
              u || s.push(d),
              (a = d),
              (o = c);
          }),
          r.length)
        )
          throw (function UJ(n) {
            return new Y(3502, !1);
          })();
        return s;
      }
      function Ob(n, e, t, i) {
        switch (e) {
          case "start":
            n.onStart(() => i(t && Nb(t, "start", n)));
            break;
          case "done":
            n.onDone(() => i(t && Nb(t, "done", n)));
            break;
          case "destroy":
            n.onDestroy(() => i(t && Nb(t, "destroy", n)));
        }
      }
      function Nb(n, e, t) {
        const s = Lb(
            n.element,
            n.triggerName,
            n.fromState,
            n.toState,
            e || n.phaseName,
            t.totalTime ?? n.totalTime,
            !!t.disabled,
          ),
          o = n._data;
        return null != o && (s._data = o), s;
      }
      function Lb(n, e, t, i, r = "", s = 0, o) {
        return {
          element: n,
          triggerName: e,
          fromState: t,
          toState: i,
          phaseName: r,
          totalTime: s,
          disabled: !!o,
        };
      }
      function Li(n, e, t) {
        let i = n.get(e);
        return i || n.set(e, (i = t)), i;
      }
      function _N(n) {
        const e = n.indexOf(":");
        return [n.substring(1, e), n.slice(e + 1)];
      }
      const ZJ = (() =>
        typeof document > "u" ? null : document.documentElement)();
      function Fb(n) {
        const e = n.parentNode || n.host || null;
        return e === ZJ ? null : e;
      }
      let sa = null,
        vN = !1;
      function yN(n, e) {
        for (; e; ) {
          if (e === n) return !0;
          e = Fb(e);
        }
        return !1;
      }
      function bN(n, e, t) {
        if (t) return Array.from(n.querySelectorAll(e));
        const i = n.querySelector(e);
        return i ? [i] : [];
      }
      let MN = (() => {
          class n {
            validateStyleProperty(t) {
              return (function QJ(n) {
                sa ||
                  ((sa =
                    (function JJ() {
                      return typeof document < "u" ? document.body : null;
                    })() || {}),
                  (vN = !!sa.style && "WebkitAppearance" in sa.style));
                let e = !0;
                return (
                  sa.style &&
                    !(function KJ(n) {
                      return "ebkit" == n.substring(1, 6);
                    })(n) &&
                    ((e = n in sa.style),
                    !e &&
                      vN &&
                      (e =
                        "Webkit" + n.charAt(0).toUpperCase() + n.slice(1) in
                        sa.style)),
                  e
                );
              })(t);
            }
            matchesElement(t, i) {
              return !1;
            }
            containsElement(t, i) {
              return yN(t, i);
            }
            getParentElement(t) {
              return Fb(t);
            }
            query(t, i, r) {
              return bN(t, i, r);
            }
            computeStyle(t, i, r) {
              return r || "";
            }
            animate(t, i, r, s, o, a = [], l) {
              return new ld(r, s);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        kb = (() => {
          class n {}
          return (n.NOOP = new MN()), n;
        })();
      const eee = 1e3,
        Ub = "ng-enter",
        nm = "ng-leave",
        im = "ng-trigger",
        rm = ".ng-trigger",
        wN = "ng-animating",
        Bb = ".ng-animating";
      function bs(n) {
        if ("number" == typeof n) return n;
        const e = n.match(/^(-?[\.\d]+)(m?s)/);
        return !e || e.length < 2 ? 0 : Vb(parseFloat(e[1]), e[2]);
      }
      function Vb(n, e) {
        return "s" === e ? n * eee : n;
      }
      function sm(n, e, t) {
        return n.hasOwnProperty("duration")
          ? n
          : (function nee(n, e, t) {
              let r,
                s = 0,
                o = "";
              if ("string" == typeof n) {
                const a = n.match(
                  /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i,
                );
                if (null === a)
                  return e.push(mN()), { duration: 0, delay: 0, easing: "" };
                r = Vb(parseFloat(a[1]), a[2]);
                const l = a[3];
                null != l && (s = Vb(parseFloat(l), a[4]));
                const c = a[5];
                c && (o = c);
              } else r = n;
              if (!t) {
                let a = !1,
                  l = e.length;
                r < 0 &&
                  (e.push(
                    (function gJ() {
                      return new Y(3100, !1);
                    })(),
                  ),
                  (a = !0)),
                  s < 0 &&
                    (e.push(
                      (function _J() {
                        return new Y(3101, !1);
                      })(),
                    ),
                    (a = !0)),
                  a && e.splice(l, 0, mN());
              }
              return { duration: r, delay: s, easing: o };
            })(n, e, t);
      }
      function cd(n, e = {}) {
        return (
          Object.keys(n).forEach((t) => {
            e[t] = n[t];
          }),
          e
        );
      }
      function EN(n) {
        const e = new Map();
        return (
          Object.keys(n).forEach((t) => {
            e.set(t, n[t]);
          }),
          e
        );
      }
      function no(n, e = new Map(), t) {
        if (t) for (let [i, r] of t) e.set(i, r);
        for (let [i, r] of n) e.set(i, r);
        return e;
      }
      function Br(n, e, t) {
        e.forEach((i, r) => {
          const s = zb(r);
          t && !t.has(r) && t.set(r, n.style[s]), (n.style[s] = i);
        });
      }
      function oa(n, e) {
        e.forEach((t, i) => {
          const r = zb(i);
          n.style[r] = "";
        });
      }
      function ud(n) {
        return Array.isArray(n) ? (1 == n.length ? n[0] : hN(n)) : n;
      }
      const Hb = new RegExp("{{\\s*(.+?)\\s*}}", "g");
      function xN(n) {
        let e = [];
        if ("string" == typeof n) {
          let t;
          for (; (t = Hb.exec(n)); ) e.push(t[1]);
          Hb.lastIndex = 0;
        }
        return e;
      }
      function dd(n, e, t) {
        const i = n.toString(),
          r = i.replace(Hb, (s, o) => {
            let a = e[o];
            return (
              null == a &&
                (t.push(
                  (function yJ(n) {
                    return new Y(3003, !1);
                  })(),
                ),
                (a = "")),
              a.toString()
            );
          });
        return r == i ? n : r;
      }
      function om(n) {
        const e = [];
        let t = n.next();
        for (; !t.done; ) e.push(t.value), (t = n.next());
        return e;
      }
      const see = /-+([a-z0-9])/g;
      function zb(n) {
        return n.replace(see, (...e) => e[1].toUpperCase());
      }
      function Fi(n, e, t) {
        switch (e.type) {
          case 7:
            return n.visitTrigger(e, t);
          case 0:
            return n.visitState(e, t);
          case 1:
            return n.visitTransition(e, t);
          case 2:
            return n.visitSequence(e, t);
          case 3:
            return n.visitGroup(e, t);
          case 4:
            return n.visitAnimate(e, t);
          case 5:
            return n.visitKeyframes(e, t);
          case 6:
            return n.visitStyle(e, t);
          case 8:
            return n.visitReference(e, t);
          case 9:
            return n.visitAnimateChild(e, t);
          case 10:
            return n.visitAnimateRef(e, t);
          case 11:
            return n.visitQuery(e, t);
          case 12:
            return n.visitStagger(e, t);
          default:
            throw (function bJ(n) {
              return new Y(3004, !1);
            })();
        }
      }
      function TN(n, e) {
        return window.getComputedStyle(n)[e];
      }
      const am = "*";
      function lee(n, e) {
        const t = [];
        return (
          "string" == typeof n
            ? n.split(/\s*,\s*/).forEach((i) =>
                (function cee(n, e, t) {
                  if (":" == n[0]) {
                    const l = (function uee(n, e) {
                      switch (n) {
                        case ":enter":
                          return "void => *";
                        case ":leave":
                          return "* => void";
                        case ":increment":
                          return (t, i) => parseFloat(i) > parseFloat(t);
                        case ":decrement":
                          return (t, i) => parseFloat(i) < parseFloat(t);
                        default:
                          return (
                            e.push(
                              (function NJ(n) {
                                return new Y(3016, !1);
                              })(),
                            ),
                            "* => *"
                          );
                      }
                    })(n, t);
                    if ("function" == typeof l) return void e.push(l);
                    n = l;
                  }
                  const i = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                  if (null == i || i.length < 4)
                    return (
                      t.push(
                        (function OJ(n) {
                          return new Y(3015, !1);
                        })(),
                      ),
                      e
                    );
                  const r = i[1],
                    s = i[2],
                    o = i[3];
                  e.push(DN(r, o));
                  "<" == s[0] && !(r == am && o == am) && e.push(DN(o, r));
                })(i, t, e),
              )
            : t.push(n),
          t
        );
      }
      const lm = new Set(["true", "1"]),
        cm = new Set(["false", "0"]);
      function DN(n, e) {
        const t = lm.has(n) || cm.has(n),
          i = lm.has(e) || cm.has(e);
        return (r, s) => {
          let o = n == am || n == r,
            a = e == am || e == s;
          return (
            !o && t && "boolean" == typeof r && (o = r ? lm.has(n) : cm.has(n)),
            !a && i && "boolean" == typeof s && (a = s ? lm.has(e) : cm.has(e)),
            o && a
          );
        };
      }
      const dee = new RegExp("s*:selfs*,?", "g");
      function Gb(n, e, t, i) {
        return new hee(n).build(e, t, i);
      }
      class hee {
        constructor(e) {
          this._driver = e;
        }
        build(e, t, i) {
          const r = new mee(t);
          return this._resetContextStyleTimingState(r), Fi(this, ud(e), r);
        }
        _resetContextStyleTimingState(e) {
          (e.currentQuerySelector = ""),
            (e.collectedStyles = new Map()),
            e.collectedStyles.set("", new Map()),
            (e.currentTime = 0);
        }
        visitTrigger(e, t) {
          let i = (t.queryCount = 0),
            r = (t.depCount = 0);
          const s = [],
            o = [];
          return (
            "@" == e.name.charAt(0) &&
              t.errors.push(
                (function SJ() {
                  return new Y(3006, !1);
                })(),
              ),
            e.definitions.forEach((a) => {
              if ((this._resetContextStyleTimingState(t), 0 == a.type)) {
                const l = a,
                  c = l.name;
                c
                  .toString()
                  .split(/\s*,\s*/)
                  .forEach((u) => {
                    (l.name = u), s.push(this.visitState(l, t));
                  }),
                  (l.name = c);
              } else if (1 == a.type) {
                const l = this.visitTransition(a, t);
                (i += l.queryCount), (r += l.depCount), o.push(l);
              } else
                t.errors.push(
                  (function wJ() {
                    return new Y(3007, !1);
                  })(),
                );
            }),
            {
              type: 7,
              name: e.name,
              states: s,
              transitions: o,
              queryCount: i,
              depCount: r,
              options: null,
            }
          );
        }
        visitState(e, t) {
          const i = this.visitStyle(e.styles, t),
            r = (e.options && e.options.params) || null;
          if (i.containsDynamicStyles) {
            const s = new Set(),
              o = r || {};
            i.styles.forEach((a) => {
              a instanceof Map &&
                a.forEach((l) => {
                  xN(l).forEach((c) => {
                    o.hasOwnProperty(c) || s.add(c);
                  });
                });
            }),
              s.size &&
                (om(s.values()),
                t.errors.push(
                  (function EJ(n, e) {
                    return new Y(3008, !1);
                  })(),
                ));
          }
          return {
            type: 0,
            name: e.name,
            style: i,
            options: r ? { params: r } : null,
          };
        }
        visitTransition(e, t) {
          (t.queryCount = 0), (t.depCount = 0);
          const i = Fi(this, ud(e.animation), t);
          return {
            type: 1,
            matchers: lee(e.expr, t.errors),
            animation: i,
            queryCount: t.queryCount,
            depCount: t.depCount,
            options: aa(e.options),
          };
        }
        visitSequence(e, t) {
          return {
            type: 2,
            steps: e.steps.map((i) => Fi(this, i, t)),
            options: aa(e.options),
          };
        }
        visitGroup(e, t) {
          const i = t.currentTime;
          let r = 0;
          const s = e.steps.map((o) => {
            t.currentTime = i;
            const a = Fi(this, o, t);
            return (r = Math.max(r, t.currentTime)), a;
          });
          return (
            (t.currentTime = r), { type: 3, steps: s, options: aa(e.options) }
          );
        }
        visitAnimate(e, t) {
          const i = (function _ee(n, e) {
            if (n.hasOwnProperty("duration")) return n;
            if ("number" == typeof n) return Wb(sm(n, e).duration, 0, "");
            const t = n;
            if (
              t
                .split(/\s+/)
                .some((s) => "{" == s.charAt(0) && "{" == s.charAt(1))
            ) {
              const s = Wb(0, 0, "");
              return (s.dynamic = !0), (s.strValue = t), s;
            }
            const r = sm(t, e);
            return Wb(r.duration, r.delay, r.easing);
          })(e.timings, t.errors);
          t.currentAnimateTimings = i;
          let r,
            s = e.styles ? e.styles : fN({});
          if (5 == s.type) r = this.visitKeyframes(s, t);
          else {
            let o = e.styles,
              a = !1;
            if (!o) {
              a = !0;
              const c = {};
              i.easing && (c.easing = i.easing), (o = fN(c));
            }
            t.currentTime += i.duration + i.delay;
            const l = this.visitStyle(o, t);
            (l.isEmptyStep = a), (r = l);
          }
          return (
            (t.currentAnimateTimings = null),
            { type: 4, timings: i, style: r, options: null }
          );
        }
        visitStyle(e, t) {
          const i = this._makeStyleAst(e, t);
          return this._validateStyleAst(i, t), i;
        }
        _makeStyleAst(e, t) {
          const i = [],
            r = Array.isArray(e.styles) ? e.styles : [e.styles];
          for (let a of r)
            "string" == typeof a
              ? a === ys
                ? i.push(a)
                : t.errors.push(new Y(3002, !1))
              : i.push(EN(a));
          let s = !1,
            o = null;
          return (
            i.forEach((a) => {
              if (
                a instanceof Map &&
                (a.has("easing") && ((o = a.get("easing")), a.delete("easing")),
                !s)
              )
                for (let l of a.values())
                  if (l.toString().indexOf("{{") >= 0) {
                    s = !0;
                    break;
                  }
            }),
            {
              type: 6,
              styles: i,
              easing: o,
              offset: e.offset,
              containsDynamicStyles: s,
              options: null,
            }
          );
        }
        _validateStyleAst(e, t) {
          const i = t.currentAnimateTimings;
          let r = t.currentTime,
            s = t.currentTime;
          i && s > 0 && (s -= i.duration + i.delay),
            e.styles.forEach((o) => {
              "string" != typeof o &&
                o.forEach((a, l) => {
                  const c = t.collectedStyles.get(t.currentQuerySelector),
                    u = c.get(l);
                  let d = !0;
                  u &&
                    (s != r &&
                      s >= u.startTime &&
                      r <= u.endTime &&
                      (t.errors.push(
                        (function xJ(n, e, t, i, r) {
                          return new Y(3010, !1);
                        })(),
                      ),
                      (d = !1)),
                    (s = u.startTime)),
                    d && c.set(l, { startTime: s, endTime: r }),
                    t.options &&
                      (function ree(n, e, t) {
                        const i = e.params || {},
                          r = xN(n);
                        r.length &&
                          r.forEach((s) => {
                            i.hasOwnProperty(s) ||
                              t.push(
                                (function vJ(n) {
                                  return new Y(3001, !1);
                                })(),
                              );
                          });
                      })(a, t.options, t.errors);
                });
            });
        }
        visitKeyframes(e, t) {
          const i = { type: 5, styles: [], options: null };
          if (!t.currentAnimateTimings)
            return (
              t.errors.push(
                (function TJ() {
                  return new Y(3011, !1);
                })(),
              ),
              i
            );
          let s = 0;
          const o = [];
          let a = !1,
            l = !1,
            c = 0;
          const u = e.steps.map((m) => {
            const y = this._makeStyleAst(m, t);
            let v =
                null != y.offset
                  ? y.offset
                  : (function gee(n) {
                      if ("string" == typeof n) return null;
                      let e = null;
                      if (Array.isArray(n))
                        n.forEach((t) => {
                          if (t instanceof Map && t.has("offset")) {
                            const i = t;
                            (e = parseFloat(i.get("offset"))),
                              i.delete("offset");
                          }
                        });
                      else if (n instanceof Map && n.has("offset")) {
                        const t = n;
                        (e = parseFloat(t.get("offset"))), t.delete("offset");
                      }
                      return e;
                    })(y.styles),
              b = 0;
            return (
              null != v && (s++, (b = y.offset = v)),
              (l = l || b < 0 || b > 1),
              (a = a || b < c),
              (c = b),
              o.push(b),
              y
            );
          });
          l &&
            t.errors.push(
              (function DJ() {
                return new Y(3012, !1);
              })(),
            ),
            a &&
              t.errors.push(
                (function AJ() {
                  return new Y(3200, !1);
                })(),
              );
          const d = e.steps.length;
          let h = 0;
          s > 0 && s < d
            ? t.errors.push(
                (function IJ() {
                  return new Y(3202, !1);
                })(),
              )
            : 0 == s && (h = 1 / (d - 1));
          const f = d - 1,
            p = t.currentTime,
            _ = t.currentAnimateTimings,
            g = _.duration;
          return (
            u.forEach((m, y) => {
              const v = h > 0 ? (y == f ? 1 : h * y) : o[y],
                b = v * g;
              (t.currentTime = p + _.delay + b),
                (_.duration = b),
                this._validateStyleAst(m, t),
                (m.offset = v),
                i.styles.push(m);
            }),
            i
          );
        }
        visitReference(e, t) {
          return {
            type: 8,
            animation: Fi(this, ud(e.animation), t),
            options: aa(e.options),
          };
        }
        visitAnimateChild(e, t) {
          return t.depCount++, { type: 9, options: aa(e.options) };
        }
        visitAnimateRef(e, t) {
          return {
            type: 10,
            animation: this.visitReference(e.animation, t),
            options: aa(e.options),
          };
        }
        visitQuery(e, t) {
          const i = t.currentQuerySelector,
            r = e.options || {};
          t.queryCount++, (t.currentQuery = e);
          const [s, o] = (function fee(n) {
            const e = !!n.split(/\s*,\s*/).find((t) => ":self" == t);
            return (
              e && (n = n.replace(dee, "")),
              (n = n
                .replace(/@\*/g, rm)
                .replace(/@\w+/g, (t) => rm + "-" + t.slice(1))
                .replace(/:animating/g, Bb)),
              [n, e]
            );
          })(e.selector);
          (t.currentQuerySelector = i.length ? i + " " + s : s),
            Li(t.collectedStyles, t.currentQuerySelector, new Map());
          const a = Fi(this, ud(e.animation), t);
          return (
            (t.currentQuery = null),
            (t.currentQuerySelector = i),
            {
              type: 11,
              selector: s,
              limit: r.limit || 0,
              optional: !!r.optional,
              includeSelf: o,
              animation: a,
              originalSelector: e.selector,
              options: aa(e.options),
            }
          );
        }
        visitStagger(e, t) {
          t.currentQuery ||
            t.errors.push(
              (function RJ() {
                return new Y(3013, !1);
              })(),
            );
          const i =
            "full" === e.timings
              ? { duration: 0, delay: 0, easing: "full" }
              : sm(e.timings, t.errors, !0);
          return {
            type: 12,
            animation: Fi(this, ud(e.animation), t),
            timings: i,
            options: null,
          };
        }
      }
      class mee {
        constructor(e) {
          (this.errors = e),
            (this.queryCount = 0),
            (this.depCount = 0),
            (this.currentTransition = null),
            (this.currentQuery = null),
            (this.currentQuerySelector = null),
            (this.currentAnimateTimings = null),
            (this.currentTime = 0),
            (this.collectedStyles = new Map()),
            (this.options = null),
            (this.unsupportedCSSPropertiesFound = new Set());
        }
      }
      function aa(n) {
        return (
          n
            ? (n = cd(n)).params &&
              (n.params = (function pee(n) {
                return n ? cd(n) : null;
              })(n.params))
            : (n = {}),
          n
        );
      }
      function Wb(n, e, t) {
        return { duration: n, delay: e, easing: t };
      }
      function $b(n, e, t, i, r, s, o = null, a = !1) {
        return {
          type: 1,
          element: n,
          keyframes: e,
          preStyleProps: t,
          postStyleProps: i,
          duration: r,
          delay: s,
          totalTime: r + s,
          easing: o,
          subTimeline: a,
        };
      }
      class um {
        constructor() {
          this._map = new Map();
        }
        get(e) {
          return this._map.get(e) || [];
        }
        append(e, t) {
          let i = this._map.get(e);
          i || this._map.set(e, (i = [])), i.push(...t);
        }
        has(e) {
          return this._map.has(e);
        }
        clear() {
          this._map.clear();
        }
      }
      const bee = new RegExp(":enter", "g"),
        See = new RegExp(":leave", "g");
      function jb(n, e, t, i, r, s = new Map(), o = new Map(), a, l, c = []) {
        return new wee().buildKeyframes(n, e, t, i, r, s, o, a, l, c);
      }
      class wee {
        buildKeyframes(e, t, i, r, s, o, a, l, c, u = []) {
          c = c || new um();
          const d = new qb(e, t, c, r, s, u, []);
          d.options = l;
          const h = l.delay ? bs(l.delay) : 0;
          d.currentTimeline.delayNextStep(h),
            d.currentTimeline.setStyles([o], null, d.errors, l),
            Fi(this, i, d);
          const f = d.timelines.filter((p) => p.containsAnimation());
          if (f.length && a.size) {
            let p;
            for (let _ = f.length - 1; _ >= 0; _--) {
              const g = f[_];
              if (g.element === t) {
                p = g;
                break;
              }
            }
            p &&
              !p.allowOnlyTimelineStyles() &&
              p.setStyles([a], null, d.errors, l);
          }
          return f.length
            ? f.map((p) => p.buildKeyframes())
            : [$b(t, [], [], [], 0, h, "", !1)];
        }
        visitTrigger(e, t) {}
        visitState(e, t) {}
        visitTransition(e, t) {}
        visitAnimateChild(e, t) {
          const i = t.subInstructions.get(t.element);
          if (i) {
            const r = t.createSubContext(e.options),
              s = t.currentTimeline.currentTime,
              o = this._visitSubInstructions(i, r, r.options);
            s != o && t.transformIntoNewTimeline(o);
          }
          t.previousNode = e;
        }
        visitAnimateRef(e, t) {
          const i = t.createSubContext(e.options);
          i.transformIntoNewTimeline(),
            this._applyAnimationRefDelays(
              [e.options, e.animation.options],
              t,
              i,
            ),
            this.visitReference(e.animation, i),
            t.transformIntoNewTimeline(i.currentTimeline.currentTime),
            (t.previousNode = e);
        }
        _applyAnimationRefDelays(e, t, i) {
          for (const r of e) {
            const s = r?.delay;
            if (s) {
              const o =
                "number" == typeof s ? s : bs(dd(s, r?.params ?? {}, t.errors));
              i.delayNextStep(o);
            }
          }
        }
        _visitSubInstructions(e, t, i) {
          let s = t.currentTimeline.currentTime;
          const o = null != i.duration ? bs(i.duration) : null,
            a = null != i.delay ? bs(i.delay) : null;
          return (
            0 !== o &&
              e.forEach((l) => {
                const c = t.appendInstructionToTimeline(l, o, a);
                s = Math.max(s, c.duration + c.delay);
              }),
            s
          );
        }
        visitReference(e, t) {
          t.updateOptions(e.options, !0),
            Fi(this, e.animation, t),
            (t.previousNode = e);
        }
        visitSequence(e, t) {
          const i = t.subContextCount;
          let r = t;
          const s = e.options;
          if (
            s &&
            (s.params || s.delay) &&
            ((r = t.createSubContext(s)),
            r.transformIntoNewTimeline(),
            null != s.delay)
          ) {
            6 == r.previousNode.type &&
              (r.currentTimeline.snapshotCurrentStyles(),
              (r.previousNode = dm));
            const o = bs(s.delay);
            r.delayNextStep(o);
          }
          e.steps.length &&
            (e.steps.forEach((o) => Fi(this, o, r)),
            r.currentTimeline.applyStylesToKeyframe(),
            r.subContextCount > i && r.transformIntoNewTimeline()),
            (t.previousNode = e);
        }
        visitGroup(e, t) {
          const i = [];
          let r = t.currentTimeline.currentTime;
          const s = e.options && e.options.delay ? bs(e.options.delay) : 0;
          e.steps.forEach((o) => {
            const a = t.createSubContext(e.options);
            s && a.delayNextStep(s),
              Fi(this, o, a),
              (r = Math.max(r, a.currentTimeline.currentTime)),
              i.push(a.currentTimeline);
          }),
            i.forEach((o) => t.currentTimeline.mergeTimelineCollectedStyles(o)),
            t.transformIntoNewTimeline(r),
            (t.previousNode = e);
        }
        _visitTiming(e, t) {
          if (e.dynamic) {
            const i = e.strValue;
            return sm(t.params ? dd(i, t.params, t.errors) : i, t.errors);
          }
          return { duration: e.duration, delay: e.delay, easing: e.easing };
        }
        visitAnimate(e, t) {
          const i = (t.currentAnimateTimings = this._visitTiming(e.timings, t)),
            r = t.currentTimeline;
          i.delay && (t.incrementTime(i.delay), r.snapshotCurrentStyles());
          const s = e.style;
          5 == s.type
            ? this.visitKeyframes(s, t)
            : (t.incrementTime(i.duration),
              this.visitStyle(s, t),
              r.applyStylesToKeyframe()),
            (t.currentAnimateTimings = null),
            (t.previousNode = e);
        }
        visitStyle(e, t) {
          const i = t.currentTimeline,
            r = t.currentAnimateTimings;
          !r && i.hasCurrentStyleProperties() && i.forwardFrame();
          const s = (r && r.easing) || e.easing;
          e.isEmptyStep
            ? i.applyEmptyStep(s)
            : i.setStyles(e.styles, s, t.errors, t.options),
            (t.previousNode = e);
        }
        visitKeyframes(e, t) {
          const i = t.currentAnimateTimings,
            r = t.currentTimeline.duration,
            s = i.duration,
            a = t.createSubContext().currentTimeline;
          (a.easing = i.easing),
            e.styles.forEach((l) => {
              a.forwardTime((l.offset || 0) * s),
                a.setStyles(l.styles, l.easing, t.errors, t.options),
                a.applyStylesToKeyframe();
            }),
            t.currentTimeline.mergeTimelineCollectedStyles(a),
            t.transformIntoNewTimeline(r + s),
            (t.previousNode = e);
        }
        visitQuery(e, t) {
          const i = t.currentTimeline.currentTime,
            r = e.options || {},
            s = r.delay ? bs(r.delay) : 0;
          s &&
            (6 === t.previousNode.type ||
              (0 == i && t.currentTimeline.hasCurrentStyleProperties())) &&
            (t.currentTimeline.snapshotCurrentStyles(), (t.previousNode = dm));
          let o = i;
          const a = t.invokeQuery(
            e.selector,
            e.originalSelector,
            e.limit,
            e.includeSelf,
            !!r.optional,
            t.errors,
          );
          t.currentQueryTotal = a.length;
          let l = null;
          a.forEach((c, u) => {
            t.currentQueryIndex = u;
            const d = t.createSubContext(e.options, c);
            s && d.delayNextStep(s),
              c === t.element && (l = d.currentTimeline),
              Fi(this, e.animation, d),
              d.currentTimeline.applyStylesToKeyframe(),
              (o = Math.max(o, d.currentTimeline.currentTime));
          }),
            (t.currentQueryIndex = 0),
            (t.currentQueryTotal = 0),
            t.transformIntoNewTimeline(o),
            l &&
              (t.currentTimeline.mergeTimelineCollectedStyles(l),
              t.currentTimeline.snapshotCurrentStyles()),
            (t.previousNode = e);
        }
        visitStagger(e, t) {
          const i = t.parentContext,
            r = t.currentTimeline,
            s = e.timings,
            o = Math.abs(s.duration),
            a = o * (t.currentQueryTotal - 1);
          let l = o * t.currentQueryIndex;
          switch (s.duration < 0 ? "reverse" : s.easing) {
            case "reverse":
              l = a - l;
              break;
            case "full":
              l = i.currentStaggerTime;
          }
          const u = t.currentTimeline;
          l && u.delayNextStep(l);
          const d = u.currentTime;
          Fi(this, e.animation, t),
            (t.previousNode = e),
            (i.currentStaggerTime =
              r.currentTime - d + (r.startTime - i.currentTimeline.startTime));
        }
      }
      const dm = {};
      class qb {
        constructor(e, t, i, r, s, o, a, l) {
          (this._driver = e),
            (this.element = t),
            (this.subInstructions = i),
            (this._enterClassName = r),
            (this._leaveClassName = s),
            (this.errors = o),
            (this.timelines = a),
            (this.parentContext = null),
            (this.currentAnimateTimings = null),
            (this.previousNode = dm),
            (this.subContextCount = 0),
            (this.options = {}),
            (this.currentQueryIndex = 0),
            (this.currentQueryTotal = 0),
            (this.currentStaggerTime = 0),
            (this.currentTimeline = l || new hm(this._driver, t, 0)),
            a.push(this.currentTimeline);
        }
        get params() {
          return this.options.params;
        }
        updateOptions(e, t) {
          if (!e) return;
          const i = e;
          let r = this.options;
          null != i.duration && (r.duration = bs(i.duration)),
            null != i.delay && (r.delay = bs(i.delay));
          const s = i.params;
          if (s) {
            let o = r.params;
            o || (o = this.options.params = {}),
              Object.keys(s).forEach((a) => {
                (!t || !o.hasOwnProperty(a)) &&
                  (o[a] = dd(s[a], o, this.errors));
              });
          }
        }
        _copyOptions() {
          const e = {};
          if (this.options) {
            const t = this.options.params;
            if (t) {
              const i = (e.params = {});
              Object.keys(t).forEach((r) => {
                i[r] = t[r];
              });
            }
          }
          return e;
        }
        createSubContext(e = null, t, i) {
          const r = t || this.element,
            s = new qb(
              this._driver,
              r,
              this.subInstructions,
              this._enterClassName,
              this._leaveClassName,
              this.errors,
              this.timelines,
              this.currentTimeline.fork(r, i || 0),
            );
          return (
            (s.previousNode = this.previousNode),
            (s.currentAnimateTimings = this.currentAnimateTimings),
            (s.options = this._copyOptions()),
            s.updateOptions(e),
            (s.currentQueryIndex = this.currentQueryIndex),
            (s.currentQueryTotal = this.currentQueryTotal),
            (s.parentContext = this),
            this.subContextCount++,
            s
          );
        }
        transformIntoNewTimeline(e) {
          return (
            (this.previousNode = dm),
            (this.currentTimeline = this.currentTimeline.fork(this.element, e)),
            this.timelines.push(this.currentTimeline),
            this.currentTimeline
          );
        }
        appendInstructionToTimeline(e, t, i) {
          const r = {
              duration: t ?? e.duration,
              delay: this.currentTimeline.currentTime + (i ?? 0) + e.delay,
              easing: "",
            },
            s = new Eee(
              this._driver,
              e.element,
              e.keyframes,
              e.preStyleProps,
              e.postStyleProps,
              r,
              e.stretchStartingKeyframe,
            );
          return this.timelines.push(s), r;
        }
        incrementTime(e) {
          this.currentTimeline.forwardTime(this.currentTimeline.duration + e);
        }
        delayNextStep(e) {
          e > 0 && this.currentTimeline.delayNextStep(e);
        }
        invokeQuery(e, t, i, r, s, o) {
          let a = [];
          if ((r && a.push(this.element), e.length > 0)) {
            e = (e = e.replace(bee, "." + this._enterClassName)).replace(
              See,
              "." + this._leaveClassName,
            );
            let c = this._driver.query(this.element, e, 1 != i);
            0 !== i &&
              (c = i < 0 ? c.slice(c.length + i, c.length) : c.slice(0, i)),
              a.push(...c);
          }
          return (
            !s &&
              0 == a.length &&
              o.push(
                (function PJ(n) {
                  return new Y(3014, !1);
                })(),
              ),
            a
          );
        }
      }
      class hm {
        constructor(e, t, i, r) {
          (this._driver = e),
            (this.element = t),
            (this.startTime = i),
            (this._elementTimelineStylesLookup = r),
            (this.duration = 0),
            (this.easing = null),
            (this._previousKeyframe = new Map()),
            (this._currentKeyframe = new Map()),
            (this._keyframes = new Map()),
            (this._styleSummary = new Map()),
            (this._localTimelineStyles = new Map()),
            (this._pendingStyles = new Map()),
            (this._backFill = new Map()),
            (this._currentEmptyStepKeyframe = null),
            this._elementTimelineStylesLookup ||
              (this._elementTimelineStylesLookup = new Map()),
            (this._globalTimelineStyles =
              this._elementTimelineStylesLookup.get(t)),
            this._globalTimelineStyles ||
              ((this._globalTimelineStyles = this._localTimelineStyles),
              this._elementTimelineStylesLookup.set(
                t,
                this._localTimelineStyles,
              )),
            this._loadKeyframe();
        }
        containsAnimation() {
          switch (this._keyframes.size) {
            case 0:
              return !1;
            case 1:
              return this.hasCurrentStyleProperties();
            default:
              return !0;
          }
        }
        hasCurrentStyleProperties() {
          return this._currentKeyframe.size > 0;
        }
        get currentTime() {
          return this.startTime + this.duration;
        }
        delayNextStep(e) {
          const t = 1 === this._keyframes.size && this._pendingStyles.size;
          this.duration || t
            ? (this.forwardTime(this.currentTime + e),
              t && this.snapshotCurrentStyles())
            : (this.startTime += e);
        }
        fork(e, t) {
          return (
            this.applyStylesToKeyframe(),
            new hm(
              this._driver,
              e,
              t || this.currentTime,
              this._elementTimelineStylesLookup,
            )
          );
        }
        _loadKeyframe() {
          this._currentKeyframe &&
            (this._previousKeyframe = this._currentKeyframe),
            (this._currentKeyframe = this._keyframes.get(this.duration)),
            this._currentKeyframe ||
              ((this._currentKeyframe = new Map()),
              this._keyframes.set(this.duration, this._currentKeyframe));
        }
        forwardFrame() {
          (this.duration += 1), this._loadKeyframe();
        }
        forwardTime(e) {
          this.applyStylesToKeyframe(),
            (this.duration = e),
            this._loadKeyframe();
        }
        _updateStyle(e, t) {
          this._localTimelineStyles.set(e, t),
            this._globalTimelineStyles.set(e, t),
            this._styleSummary.set(e, { time: this.currentTime, value: t });
        }
        allowOnlyTimelineStyles() {
          return this._currentEmptyStepKeyframe !== this._currentKeyframe;
        }
        applyEmptyStep(e) {
          e && this._previousKeyframe.set("easing", e);
          for (let [t, i] of this._globalTimelineStyles)
            this._backFill.set(t, i || ys), this._currentKeyframe.set(t, ys);
          this._currentEmptyStepKeyframe = this._currentKeyframe;
        }
        setStyles(e, t, i, r) {
          t && this._previousKeyframe.set("easing", t);
          const s = (r && r.params) || {},
            o = (function Cee(n, e) {
              const t = new Map();
              let i;
              return (
                n.forEach((r) => {
                  if ("*" === r) {
                    i = i || e.keys();
                    for (let s of i) t.set(s, ys);
                  } else no(r, t);
                }),
                t
              );
            })(e, this._globalTimelineStyles);
          for (let [a, l] of o) {
            const c = dd(l, s, i);
            this._pendingStyles.set(a, c),
              this._localTimelineStyles.has(a) ||
                this._backFill.set(a, this._globalTimelineStyles.get(a) ?? ys),
              this._updateStyle(a, c);
          }
        }
        applyStylesToKeyframe() {
          0 != this._pendingStyles.size &&
            (this._pendingStyles.forEach((e, t) => {
              this._currentKeyframe.set(t, e);
            }),
            this._pendingStyles.clear(),
            this._localTimelineStyles.forEach((e, t) => {
              this._currentKeyframe.has(t) || this._currentKeyframe.set(t, e);
            }));
        }
        snapshotCurrentStyles() {
          for (let [e, t] of this._localTimelineStyles)
            this._pendingStyles.set(e, t), this._updateStyle(e, t);
        }
        getFinalKeyframe() {
          return this._keyframes.get(this.duration);
        }
        get properties() {
          const e = [];
          for (let t in this._currentKeyframe) e.push(t);
          return e;
        }
        mergeTimelineCollectedStyles(e) {
          e._styleSummary.forEach((t, i) => {
            const r = this._styleSummary.get(i);
            (!r || t.time > r.time) && this._updateStyle(i, t.value);
          });
        }
        buildKeyframes() {
          this.applyStylesToKeyframe();
          const e = new Set(),
            t = new Set(),
            i = 1 === this._keyframes.size && 0 === this.duration;
          let r = [];
          this._keyframes.forEach((a, l) => {
            const c = no(a, new Map(), this._backFill);
            c.forEach((u, d) => {
              "!" === u ? e.add(d) : u === ys && t.add(d);
            }),
              i || c.set("offset", l / this.duration),
              r.push(c);
          });
          const s = e.size ? om(e.values()) : [],
            o = t.size ? om(t.values()) : [];
          if (i) {
            const a = r[0],
              l = new Map(a);
            a.set("offset", 0), l.set("offset", 1), (r = [a, l]);
          }
          return $b(
            this.element,
            r,
            s,
            o,
            this.duration,
            this.startTime,
            this.easing,
            !1,
          );
        }
      }
      class Eee extends hm {
        constructor(e, t, i, r, s, o, a = !1) {
          super(e, t, o.delay),
            (this.keyframes = i),
            (this.preStyleProps = r),
            (this.postStyleProps = s),
            (this._stretchStartingKeyframe = a),
            (this.timings = {
              duration: o.duration,
              delay: o.delay,
              easing: o.easing,
            });
        }
        containsAnimation() {
          return this.keyframes.length > 1;
        }
        buildKeyframes() {
          let e = this.keyframes,
            { delay: t, duration: i, easing: r } = this.timings;
          if (this._stretchStartingKeyframe && t) {
            const s = [],
              o = i + t,
              a = t / o,
              l = no(e[0]);
            l.set("offset", 0), s.push(l);
            const c = no(e[0]);
            c.set("offset", RN(a)), s.push(c);
            const u = e.length - 1;
            for (let d = 1; d <= u; d++) {
              let h = no(e[d]);
              const f = h.get("offset");
              h.set("offset", RN((t + f * i) / o)), s.push(h);
            }
            (i = o), (t = 0), (r = ""), (e = s);
          }
          return $b(
            this.element,
            e,
            this.preStyleProps,
            this.postStyleProps,
            i,
            t,
            r,
            !0,
          );
        }
      }
      function RN(n, e = 3) {
        const t = Math.pow(10, e - 1);
        return Math.round(n * t) / t;
      }
      class Xb {}
      const xee = new Set([
        "width",
        "height",
        "minWidth",
        "minHeight",
        "maxWidth",
        "maxHeight",
        "left",
        "top",
        "bottom",
        "right",
        "fontSize",
        "outlineWidth",
        "outlineOffset",
        "paddingTop",
        "paddingLeft",
        "paddingBottom",
        "paddingRight",
        "marginTop",
        "marginLeft",
        "marginBottom",
        "marginRight",
        "borderRadius",
        "borderWidth",
        "borderTopWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderBottomWidth",
        "textIndent",
        "perspective",
      ]);
      class Tee extends Xb {
        normalizePropertyName(e, t) {
          return zb(e);
        }
        normalizeStyleValue(e, t, i, r) {
          let s = "";
          const o = i.toString().trim();
          if (xee.has(t) && 0 !== i && "0" !== i)
            if ("number" == typeof i) s = "px";
            else {
              const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
              a &&
                0 == a[1].length &&
                r.push(
                  (function MJ(n, e) {
                    return new Y(3005, !1);
                  })(),
                );
            }
          return o + s;
        }
      }
      function PN(n, e, t, i, r, s, o, a, l, c, u, d, h) {
        return {
          type: 0,
          element: n,
          triggerName: e,
          isRemovalTransition: r,
          fromState: t,
          fromStyles: s,
          toState: i,
          toStyles: o,
          timelines: a,
          queriedElements: l,
          preStyleProps: c,
          postStyleProps: u,
          totalTime: d,
          errors: h,
        };
      }
      const Yb = {};
      class ON {
        constructor(e, t, i) {
          (this._triggerName = e), (this.ast = t), (this._stateStyles = i);
        }
        match(e, t, i, r) {
          return (function Dee(n, e, t, i, r) {
            return n.some((s) => s(e, t, i, r));
          })(this.ast.matchers, e, t, i, r);
        }
        buildStyles(e, t, i) {
          let r = this._stateStyles.get("*");
          return (
            void 0 !== e && (r = this._stateStyles.get(e?.toString()) || r),
            r ? r.buildStyles(t, i) : new Map()
          );
        }
        build(e, t, i, r, s, o, a, l, c, u) {
          const d = [],
            h = (this.ast.options && this.ast.options.params) || Yb,
            p = this.buildStyles(i, (a && a.params) || Yb, d),
            _ = (l && l.params) || Yb,
            g = this.buildStyles(r, _, d),
            m = new Set(),
            y = new Map(),
            v = new Map(),
            b = "void" === r,
            S = { params: Aee(_, h), delay: this.ast.options?.delay },
            E = u ? [] : jb(e, t, this.ast.animation, s, o, p, g, S, c, d);
          let x = 0;
          if (
            (E.forEach((M) => {
              x = Math.max(M.duration + M.delay, x);
            }),
            d.length)
          )
            return PN(t, this._triggerName, i, r, b, p, g, [], [], y, v, x, d);
          E.forEach((M) => {
            const C = M.element,
              $ = Li(y, C, new Set());
            M.preStyleProps.forEach((V) => $.add(V));
            const ie = Li(v, C, new Set());
            M.postStyleProps.forEach((V) => ie.add(V)), C !== t && m.add(C);
          });
          const P = om(m.values());
          return PN(t, this._triggerName, i, r, b, p, g, E, P, y, v, x);
        }
      }
      function Aee(n, e) {
        const t = cd(e);
        for (const i in n) n.hasOwnProperty(i) && null != n[i] && (t[i] = n[i]);
        return t;
      }
      class Iee {
        constructor(e, t, i) {
          (this.styles = e), (this.defaultParams = t), (this.normalizer = i);
        }
        buildStyles(e, t) {
          const i = new Map(),
            r = cd(this.defaultParams);
          return (
            Object.keys(e).forEach((s) => {
              const o = e[s];
              null !== o && (r[s] = o);
            }),
            this.styles.styles.forEach((s) => {
              "string" != typeof s &&
                s.forEach((o, a) => {
                  o && (o = dd(o, r, t));
                  const l = this.normalizer.normalizePropertyName(a, t);
                  (o = this.normalizer.normalizeStyleValue(a, l, o, t)),
                    i.set(a, o);
                });
            }),
            i
          );
        }
      }
      class Pee {
        constructor(e, t, i) {
          (this.name = e),
            (this.ast = t),
            (this._normalizer = i),
            (this.transitionFactories = []),
            (this.states = new Map()),
            t.states.forEach((r) => {
              this.states.set(
                r.name,
                new Iee(r.style, (r.options && r.options.params) || {}, i),
              );
            }),
            NN(this.states, "true", "1"),
            NN(this.states, "false", "0"),
            t.transitions.forEach((r) => {
              this.transitionFactories.push(new ON(e, r, this.states));
            }),
            (this.fallbackTransition = (function Oee(n, e, t) {
              return new ON(
                n,
                {
                  type: 1,
                  animation: { type: 2, steps: [], options: null },
                  matchers: [(o, a) => !0],
                  options: null,
                  queryCount: 0,
                  depCount: 0,
                },
                e,
              );
            })(e, this.states));
        }
        get containsQueries() {
          return this.ast.queryCount > 0;
        }
        matchTransition(e, t, i, r) {
          return (
            this.transitionFactories.find((o) => o.match(e, t, i, r)) || null
          );
        }
        matchStyles(e, t, i) {
          return this.fallbackTransition.buildStyles(e, t, i);
        }
      }
      function NN(n, e, t) {
        n.has(e)
          ? n.has(t) || n.set(t, n.get(e))
          : n.has(t) && n.set(e, n.get(t));
      }
      const Nee = new um();
      class Lee {
        constructor(e, t, i) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = i),
            (this._animations = new Map()),
            (this._playersById = new Map()),
            (this.players = []);
        }
        register(e, t) {
          const i = [],
            s = Gb(this._driver, t, i, []);
          if (i.length)
            throw (function BJ(n) {
              return new Y(3503, !1);
            })();
          this._animations.set(e, s);
        }
        _buildPlayer(e, t, i) {
          const r = e.element,
            s = gN(this._normalizer, e.keyframes, t, i);
          return this._driver.animate(
            r,
            s,
            e.duration,
            e.delay,
            e.easing,
            [],
            !0,
          );
        }
        create(e, t, i = {}) {
          const r = [],
            s = this._animations.get(e);
          let o;
          const a = new Map();
          if (
            (s
              ? ((o = jb(
                  this._driver,
                  t,
                  s,
                  Ub,
                  nm,
                  new Map(),
                  new Map(),
                  i,
                  Nee,
                  r,
                )),
                o.forEach((u) => {
                  const d = Li(a, u.element, new Map());
                  u.postStyleProps.forEach((h) => d.set(h, null));
                }))
              : (r.push(
                  (function VJ() {
                    return new Y(3300, !1);
                  })(),
                ),
                (o = [])),
            r.length)
          )
            throw (function HJ(n) {
              return new Y(3504, !1);
            })();
          a.forEach((u, d) => {
            u.forEach((h, f) => {
              u.set(f, this._driver.computeStyle(d, f, ys));
            });
          });
          const c = to(
            o.map((u) => {
              const d = a.get(u.element);
              return this._buildPlayer(u, new Map(), d);
            }),
          );
          return (
            this._playersById.set(e, c),
            c.onDestroy(() => this.destroy(e)),
            this.players.push(c),
            c
          );
        }
        destroy(e) {
          const t = this._getPlayer(e);
          t.destroy(), this._playersById.delete(e);
          const i = this.players.indexOf(t);
          i >= 0 && this.players.splice(i, 1);
        }
        _getPlayer(e) {
          const t = this._playersById.get(e);
          if (!t)
            throw (function zJ(n) {
              return new Y(3301, !1);
            })();
          return t;
        }
        listen(e, t, i, r) {
          const s = Lb(t, "", "", "");
          return Ob(this._getPlayer(e), i, s, r), () => {};
        }
        command(e, t, i, r) {
          if ("register" == i) return void this.register(e, r[0]);
          if ("create" == i) return void this.create(e, t, r[0] || {});
          const s = this._getPlayer(e);
          switch (i) {
            case "play":
              s.play();
              break;
            case "pause":
              s.pause();
              break;
            case "reset":
              s.reset();
              break;
            case "restart":
              s.restart();
              break;
            case "finish":
              s.finish();
              break;
            case "init":
              s.init();
              break;
            case "setPosition":
              s.setPosition(parseFloat(r[0]));
              break;
            case "destroy":
              this.destroy(e);
          }
        }
      }
      const LN = "ng-animate-queued",
        Zb = "ng-animate-disabled",
        Vee = [],
        FN = {
          namespaceId: "",
          setForRemoval: !1,
          setForMove: !1,
          hasAnimation: !1,
          removedBeforeQueried: !1,
        },
        Hee = {
          namespaceId: "",
          setForMove: !1,
          setForRemoval: !1,
          hasAnimation: !1,
          removedBeforeQueried: !0,
        },
        vr = "__ng_removed";
      class Kb {
        get params() {
          return this.options.params;
        }
        constructor(e, t = "") {
          this.namespaceId = t;
          const i = e && e.hasOwnProperty("value");
          if (
            ((this.value = (function $ee(n) {
              return n ?? null;
            })(i ? e.value : e)),
            i)
          ) {
            const s = cd(e);
            delete s.value, (this.options = s);
          } else this.options = {};
          this.options.params || (this.options.params = {});
        }
        absorbOptions(e) {
          const t = e.params;
          if (t) {
            const i = this.options.params;
            Object.keys(t).forEach((r) => {
              null == i[r] && (i[r] = t[r]);
            });
          }
        }
      }
      const hd = "void",
        Qb = new Kb(hd);
      class zee {
        constructor(e, t, i) {
          (this.id = e),
            (this.hostElement = t),
            (this._engine = i),
            (this.players = []),
            (this._triggers = new Map()),
            (this._queue = []),
            (this._elementListeners = new Map()),
            (this._hostClassName = "ng-tns-" + e),
            er(t, this._hostClassName);
        }
        listen(e, t, i, r) {
          if (!this._triggers.has(t))
            throw (function GJ(n, e) {
              return new Y(3302, !1);
            })();
          if (null == i || 0 == i.length)
            throw (function WJ(n) {
              return new Y(3303, !1);
            })();
          if (
            !(function jee(n) {
              return "start" == n || "done" == n;
            })(i)
          )
            throw (function $J(n, e) {
              return new Y(3400, !1);
            })();
          const s = Li(this._elementListeners, e, []),
            o = { name: t, phase: i, callback: r };
          s.push(o);
          const a = Li(this._engine.statesByElement, e, new Map());
          return (
            a.has(t) || (er(e, im), er(e, im + "-" + t), a.set(t, Qb)),
            () => {
              this._engine.afterFlush(() => {
                const l = s.indexOf(o);
                l >= 0 && s.splice(l, 1), this._triggers.has(t) || a.delete(t);
              });
            }
          );
        }
        register(e, t) {
          return !this._triggers.has(e) && (this._triggers.set(e, t), !0);
        }
        _getTrigger(e) {
          const t = this._triggers.get(e);
          if (!t)
            throw (function jJ(n) {
              return new Y(3401, !1);
            })();
          return t;
        }
        trigger(e, t, i, r = !0) {
          const s = this._getTrigger(t),
            o = new Jb(this.id, t, e);
          let a = this._engine.statesByElement.get(e);
          a ||
            (er(e, im),
            er(e, im + "-" + t),
            this._engine.statesByElement.set(e, (a = new Map())));
          let l = a.get(t);
          const c = new Kb(i, this.id);
          if (
            (!(i && i.hasOwnProperty("value")) &&
              l &&
              c.absorbOptions(l.options),
            a.set(t, c),
            l || (l = Qb),
            c.value !== hd && l.value === c.value)
          ) {
            if (
              !(function Yee(n, e) {
                const t = Object.keys(n),
                  i = Object.keys(e);
                if (t.length != i.length) return !1;
                for (let r = 0; r < t.length; r++) {
                  const s = t[r];
                  if (!e.hasOwnProperty(s) || n[s] !== e[s]) return !1;
                }
                return !0;
              })(l.params, c.params)
            ) {
              const _ = [],
                g = s.matchStyles(l.value, l.params, _),
                m = s.matchStyles(c.value, c.params, _);
              _.length
                ? this._engine.reportError(_)
                : this._engine.afterFlush(() => {
                    oa(e, g), Br(e, m);
                  });
            }
            return;
          }
          const h = Li(this._engine.playersByElement, e, []);
          h.forEach((_) => {
            _.namespaceId == this.id &&
              _.triggerName == t &&
              _.queued &&
              _.destroy();
          });
          let f = s.matchTransition(l.value, c.value, e, c.params),
            p = !1;
          if (!f) {
            if (!r) return;
            (f = s.fallbackTransition), (p = !0);
          }
          return (
            this._engine.totalQueuedPlayers++,
            this._queue.push({
              element: e,
              triggerName: t,
              transition: f,
              fromState: l,
              toState: c,
              player: o,
              isFallbackTransition: p,
            }),
            p ||
              (er(e, LN),
              o.onStart(() => {
                rc(e, LN);
              })),
            o.onDone(() => {
              let _ = this.players.indexOf(o);
              _ >= 0 && this.players.splice(_, 1);
              const g = this._engine.playersByElement.get(e);
              if (g) {
                let m = g.indexOf(o);
                m >= 0 && g.splice(m, 1);
              }
            }),
            this.players.push(o),
            h.push(o),
            o
          );
        }
        deregister(e) {
          this._triggers.delete(e),
            this._engine.statesByElement.forEach((t) => t.delete(e)),
            this._elementListeners.forEach((t, i) => {
              this._elementListeners.set(
                i,
                t.filter((r) => r.name != e),
              );
            });
        }
        clearElementCache(e) {
          this._engine.statesByElement.delete(e),
            this._elementListeners.delete(e);
          const t = this._engine.playersByElement.get(e);
          t &&
            (t.forEach((i) => i.destroy()),
            this._engine.playersByElement.delete(e));
        }
        _signalRemovalForInnerTriggers(e, t) {
          const i = this._engine.driver.query(e, rm, !0);
          i.forEach((r) => {
            if (r[vr]) return;
            const s = this._engine.fetchNamespacesByElement(r);
            s.size
              ? s.forEach((o) => o.triggerLeaveAnimation(r, t, !1, !0))
              : this.clearElementCache(r);
          }),
            this._engine.afterFlushAnimationsDone(() =>
              i.forEach((r) => this.clearElementCache(r)),
            );
        }
        triggerLeaveAnimation(e, t, i, r) {
          const s = this._engine.statesByElement.get(e),
            o = new Map();
          if (s) {
            const a = [];
            if (
              (s.forEach((l, c) => {
                if ((o.set(c, l.value), this._triggers.has(c))) {
                  const u = this.trigger(e, c, hd, r);
                  u && a.push(u);
                }
              }),
              a.length)
            )
              return (
                this._engine.markElementAsRemoved(this.id, e, !0, t, o),
                i && to(a).onDone(() => this._engine.processLeaveNode(e)),
                !0
              );
          }
          return !1;
        }
        prepareLeaveAnimationListeners(e) {
          const t = this._elementListeners.get(e),
            i = this._engine.statesByElement.get(e);
          if (t && i) {
            const r = new Set();
            t.forEach((s) => {
              const o = s.name;
              if (r.has(o)) return;
              r.add(o);
              const l = this._triggers.get(o).fallbackTransition,
                c = i.get(o) || Qb,
                u = new Kb(hd),
                d = new Jb(this.id, o, e);
              this._engine.totalQueuedPlayers++,
                this._queue.push({
                  element: e,
                  triggerName: o,
                  transition: l,
                  fromState: c,
                  toState: u,
                  player: d,
                  isFallbackTransition: !0,
                });
            });
          }
        }
        removeNode(e, t) {
          const i = this._engine;
          if (
            (e.childElementCount && this._signalRemovalForInnerTriggers(e, t),
            this.triggerLeaveAnimation(e, t, !0))
          )
            return;
          let r = !1;
          if (i.totalAnimations) {
            const s = i.players.length ? i.playersByQueriedElement.get(e) : [];
            if (s && s.length) r = !0;
            else {
              let o = e;
              for (; (o = o.parentNode); )
                if (i.statesByElement.get(o)) {
                  r = !0;
                  break;
                }
            }
          }
          if ((this.prepareLeaveAnimationListeners(e), r))
            i.markElementAsRemoved(this.id, e, !1, t);
          else {
            const s = e[vr];
            (!s || s === FN) &&
              (i.afterFlush(() => this.clearElementCache(e)),
              i.destroyInnerAnimations(e),
              i._onRemovalComplete(e, t));
          }
        }
        insertNode(e, t) {
          er(e, this._hostClassName);
        }
        drainQueuedTransitions(e) {
          const t = [];
          return (
            this._queue.forEach((i) => {
              const r = i.player;
              if (r.destroyed) return;
              const s = i.element,
                o = this._elementListeners.get(s);
              o &&
                o.forEach((a) => {
                  if (a.name == i.triggerName) {
                    const l = Lb(
                      s,
                      i.triggerName,
                      i.fromState.value,
                      i.toState.value,
                    );
                    (l._data = e), Ob(i.player, a.phase, l, a.callback);
                  }
                }),
                r.markedForDestroy
                  ? this._engine.afterFlush(() => {
                      r.destroy();
                    })
                  : t.push(i);
            }),
            (this._queue = []),
            t.sort((i, r) => {
              const s = i.transition.ast.depCount,
                o = r.transition.ast.depCount;
              return 0 == s || 0 == o
                ? s - o
                : this._engine.driver.containsElement(i.element, r.element)
                ? 1
                : -1;
            })
          );
        }
        destroy(e) {
          this.players.forEach((t) => t.destroy()),
            this._signalRemovalForInnerTriggers(this.hostElement, e);
        }
      }
      class Gee {
        _onRemovalComplete(e, t) {
          this.onRemovalComplete(e, t);
        }
        constructor(e, t, i) {
          (this.bodyNode = e),
            (this.driver = t),
            (this._normalizer = i),
            (this.players = []),
            (this.newHostElements = new Map()),
            (this.playersByElement = new Map()),
            (this.playersByQueriedElement = new Map()),
            (this.statesByElement = new Map()),
            (this.disabledNodes = new Set()),
            (this.totalAnimations = 0),
            (this.totalQueuedPlayers = 0),
            (this._namespaceLookup = {}),
            (this._namespaceList = []),
            (this._flushFns = []),
            (this._whenQuietFns = []),
            (this.namespacesByHostElement = new Map()),
            (this.collectedEnterElements = []),
            (this.collectedLeaveElements = []),
            (this.onRemovalComplete = (r, s) => {});
        }
        get queuedPlayers() {
          const e = [];
          return (
            this._namespaceList.forEach((t) => {
              t.players.forEach((i) => {
                i.queued && e.push(i);
              });
            }),
            e
          );
        }
        createNamespace(e, t) {
          const i = new zee(e, t, this);
          return (
            this.bodyNode && this.driver.containsElement(this.bodyNode, t)
              ? this._balanceNamespaceList(i, t)
              : (this.newHostElements.set(t, i), this.collectEnterElement(t)),
            (this._namespaceLookup[e] = i)
          );
        }
        _balanceNamespaceList(e, t) {
          const i = this._namespaceList,
            r = this.namespacesByHostElement;
          if (i.length - 1 >= 0) {
            let o = !1,
              a = this.driver.getParentElement(t);
            for (; a; ) {
              const l = r.get(a);
              if (l) {
                const c = i.indexOf(l);
                i.splice(c + 1, 0, e), (o = !0);
                break;
              }
              a = this.driver.getParentElement(a);
            }
            o || i.unshift(e);
          } else i.push(e);
          return r.set(t, e), e;
        }
        register(e, t) {
          let i = this._namespaceLookup[e];
          return i || (i = this.createNamespace(e, t)), i;
        }
        registerTrigger(e, t, i) {
          let r = this._namespaceLookup[e];
          r && r.register(t, i) && this.totalAnimations++;
        }
        destroy(e, t) {
          e &&
            (this.afterFlush(() => {}),
            this.afterFlushAnimationsDone(() => {
              const i = this._fetchNamespace(e);
              this.namespacesByHostElement.delete(i.hostElement);
              const r = this._namespaceList.indexOf(i);
              r >= 0 && this._namespaceList.splice(r, 1),
                i.destroy(t),
                delete this._namespaceLookup[e];
            }));
        }
        _fetchNamespace(e) {
          return this._namespaceLookup[e];
        }
        fetchNamespacesByElement(e) {
          const t = new Set(),
            i = this.statesByElement.get(e);
          if (i)
            for (let r of i.values())
              if (r.namespaceId) {
                const s = this._fetchNamespace(r.namespaceId);
                s && t.add(s);
              }
          return t;
        }
        trigger(e, t, i, r) {
          if (fm(t)) {
            const s = this._fetchNamespace(e);
            if (s) return s.trigger(t, i, r), !0;
          }
          return !1;
        }
        insertNode(e, t, i, r) {
          if (!fm(t)) return;
          const s = t[vr];
          if (s && s.setForRemoval) {
            (s.setForRemoval = !1), (s.setForMove = !0);
            const o = this.collectedLeaveElements.indexOf(t);
            o >= 0 && this.collectedLeaveElements.splice(o, 1);
          }
          if (e) {
            const o = this._fetchNamespace(e);
            o && o.insertNode(t, i);
          }
          r && this.collectEnterElement(t);
        }
        collectEnterElement(e) {
          this.collectedEnterElements.push(e);
        }
        markElementAsDisabled(e, t) {
          t
            ? this.disabledNodes.has(e) ||
              (this.disabledNodes.add(e), er(e, Zb))
            : this.disabledNodes.has(e) &&
              (this.disabledNodes.delete(e), rc(e, Zb));
        }
        removeNode(e, t, i) {
          if (fm(t)) {
            const r = e ? this._fetchNamespace(e) : null;
            r ? r.removeNode(t, i) : this.markElementAsRemoved(e, t, !1, i);
            const s = this.namespacesByHostElement.get(t);
            s && s.id !== e && s.removeNode(t, i);
          } else this._onRemovalComplete(t, i);
        }
        markElementAsRemoved(e, t, i, r, s) {
          this.collectedLeaveElements.push(t),
            (t[vr] = {
              namespaceId: e,
              setForRemoval: r,
              hasAnimation: i,
              removedBeforeQueried: !1,
              previousTriggersValues: s,
            });
        }
        listen(e, t, i, r, s) {
          return fm(t) ? this._fetchNamespace(e).listen(t, i, r, s) : () => {};
        }
        _buildInstruction(e, t, i, r, s) {
          return e.transition.build(
            this.driver,
            e.element,
            e.fromState.value,
            e.toState.value,
            i,
            r,
            e.fromState.options,
            e.toState.options,
            t,
            s,
          );
        }
        destroyInnerAnimations(e) {
          let t = this.driver.query(e, rm, !0);
          t.forEach((i) => this.destroyActiveAnimationsForElement(i)),
            0 != this.playersByQueriedElement.size &&
              ((t = this.driver.query(e, Bb, !0)),
              t.forEach((i) => this.finishActiveQueriedAnimationOnElement(i)));
        }
        destroyActiveAnimationsForElement(e) {
          const t = this.playersByElement.get(e);
          t &&
            t.forEach((i) => {
              i.queued ? (i.markedForDestroy = !0) : i.destroy();
            });
        }
        finishActiveQueriedAnimationOnElement(e) {
          const t = this.playersByQueriedElement.get(e);
          t && t.forEach((i) => i.finish());
        }
        whenRenderingDone() {
          return new Promise((e) => {
            if (this.players.length) return to(this.players).onDone(() => e());
            e();
          });
        }
        processLeaveNode(e) {
          const t = e[vr];
          if (t && t.setForRemoval) {
            if (((e[vr] = FN), t.namespaceId)) {
              this.destroyInnerAnimations(e);
              const i = this._fetchNamespace(t.namespaceId);
              i && i.clearElementCache(e);
            }
            this._onRemovalComplete(e, t.setForRemoval);
          }
          e.classList?.contains(Zb) && this.markElementAsDisabled(e, !1),
            this.driver.query(e, ".ng-animate-disabled", !0).forEach((i) => {
              this.markElementAsDisabled(i, !1);
            });
        }
        flush(e = -1) {
          let t = [];
          if (
            (this.newHostElements.size &&
              (this.newHostElements.forEach((i, r) =>
                this._balanceNamespaceList(i, r),
              ),
              this.newHostElements.clear()),
            this.totalAnimations && this.collectedEnterElements.length)
          )
            for (let i = 0; i < this.collectedEnterElements.length; i++)
              er(this.collectedEnterElements[i], "ng-star-inserted");
          if (
            this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)
          ) {
            const i = [];
            try {
              t = this._flushAnimations(i, e);
            } finally {
              for (let r = 0; r < i.length; r++) i[r]();
            }
          } else
            for (let i = 0; i < this.collectedLeaveElements.length; i++)
              this.processLeaveNode(this.collectedLeaveElements[i]);
          if (
            ((this.totalQueuedPlayers = 0),
            (this.collectedEnterElements.length = 0),
            (this.collectedLeaveElements.length = 0),
            this._flushFns.forEach((i) => i()),
            (this._flushFns = []),
            this._whenQuietFns.length)
          ) {
            const i = this._whenQuietFns;
            (this._whenQuietFns = []),
              t.length
                ? to(t).onDone(() => {
                    i.forEach((r) => r());
                  })
                : i.forEach((r) => r());
          }
        }
        reportError(e) {
          throw (function qJ(n) {
            return new Y(3402, !1);
          })();
        }
        _flushAnimations(e, t) {
          const i = new um(),
            r = [],
            s = new Map(),
            o = [],
            a = new Map(),
            l = new Map(),
            c = new Map(),
            u = new Set();
          this.disabledNodes.forEach((F) => {
            u.add(F);
            const N = this.driver.query(F, ".ng-animate-queued", !0);
            for (let k = 0; k < N.length; k++) u.add(N[k]);
          });
          const d = this.bodyNode,
            h = Array.from(this.statesByElement.keys()),
            f = BN(h, this.collectedEnterElements),
            p = new Map();
          let _ = 0;
          f.forEach((F, N) => {
            const k = Ub + _++;
            p.set(N, k), F.forEach((q) => er(q, k));
          });
          const g = [],
            m = new Set(),
            y = new Set();
          for (let F = 0; F < this.collectedLeaveElements.length; F++) {
            const N = this.collectedLeaveElements[F],
              k = N[vr];
            k &&
              k.setForRemoval &&
              (g.push(N),
              m.add(N),
              k.hasAnimation
                ? this.driver
                    .query(N, ".ng-star-inserted", !0)
                    .forEach((q) => m.add(q))
                : y.add(N));
          }
          const v = new Map(),
            b = BN(h, Array.from(m));
          b.forEach((F, N) => {
            const k = nm + _++;
            v.set(N, k), F.forEach((q) => er(q, k));
          }),
            e.push(() => {
              f.forEach((F, N) => {
                const k = p.get(N);
                F.forEach((q) => rc(q, k));
              }),
                b.forEach((F, N) => {
                  const k = v.get(N);
                  F.forEach((q) => rc(q, k));
                }),
                g.forEach((F) => {
                  this.processLeaveNode(F);
                });
            });
          const S = [],
            E = [];
          for (let F = this._namespaceList.length - 1; F >= 0; F--)
            this._namespaceList[F].drainQueuedTransitions(t).forEach((k) => {
              const q = k.player,
                ee = k.element;
              if ((S.push(q), this.collectedEnterElements.length)) {
                const Me = ee[vr];
                if (Me && Me.setForMove) {
                  if (
                    Me.previousTriggersValues &&
                    Me.previousTriggersValues.has(k.triggerName)
                  ) {
                    const Re = Me.previousTriggersValues.get(k.triggerName),
                      Je = this.statesByElement.get(k.element);
                    if (Je && Je.has(k.triggerName)) {
                      const Ft = Je.get(k.triggerName);
                      (Ft.value = Re), Je.set(k.triggerName, Ft);
                    }
                  }
                  return void q.destroy();
                }
              }
              const U = !d || !this.driver.containsElement(d, ee),
                K = v.get(ee),
                fe = p.get(ee),
                le = this._buildInstruction(k, i, fe, K, U);
              if (le.errors && le.errors.length) return void E.push(le);
              if (U)
                return (
                  q.onStart(() => oa(ee, le.fromStyles)),
                  q.onDestroy(() => Br(ee, le.toStyles)),
                  void r.push(q)
                );
              if (k.isFallbackTransition)
                return (
                  q.onStart(() => oa(ee, le.fromStyles)),
                  q.onDestroy(() => Br(ee, le.toStyles)),
                  void r.push(q)
                );
              const be = [];
              le.timelines.forEach((Me) => {
                (Me.stretchStartingKeyframe = !0),
                  this.disabledNodes.has(Me.element) || be.push(Me);
              }),
                (le.timelines = be),
                i.append(ee, le.timelines),
                o.push({ instruction: le, player: q, element: ee }),
                le.queriedElements.forEach((Me) => Li(a, Me, []).push(q)),
                le.preStyleProps.forEach((Me, Re) => {
                  if (Me.size) {
                    let Je = l.get(Re);
                    Je || l.set(Re, (Je = new Set())),
                      Me.forEach((Ft, Be) => Je.add(Be));
                  }
                }),
                le.postStyleProps.forEach((Me, Re) => {
                  let Je = c.get(Re);
                  Je || c.set(Re, (Je = new Set())),
                    Me.forEach((Ft, Be) => Je.add(Be));
                });
            });
          if (E.length) {
            const F = [];
            E.forEach((N) => {
              F.push(
                (function XJ(n, e) {
                  return new Y(3505, !1);
                })(),
              );
            }),
              S.forEach((N) => N.destroy()),
              this.reportError(F);
          }
          const x = new Map(),
            P = new Map();
          o.forEach((F) => {
            const N = F.element;
            i.has(N) &&
              (P.set(N, N),
              this._beforeAnimationBuild(
                F.player.namespaceId,
                F.instruction,
                x,
              ));
          }),
            r.forEach((F) => {
              const N = F.element;
              this._getPreviousPlayers(
                N,
                !1,
                F.namespaceId,
                F.triggerName,
                null,
              ).forEach((q) => {
                Li(x, N, []).push(q), q.destroy();
              });
            });
          const M = g.filter((F) => HN(F, l, c)),
            C = new Map();
          UN(C, this.driver, y, c, ys).forEach((F) => {
            HN(F, l, c) && M.push(F);
          });
          const ie = new Map();
          f.forEach((F, N) => {
            UN(ie, this.driver, new Set(F), l, "!");
          }),
            M.forEach((F) => {
              const N = C.get(F),
                k = ie.get(F);
              C.set(
                F,
                new Map([...(N?.entries() ?? []), ...(k?.entries() ?? [])]),
              );
            });
          const V = [],
            z = [],
            W = {};
          o.forEach((F) => {
            const { element: N, player: k, instruction: q } = F;
            if (i.has(N)) {
              if (u.has(N))
                return (
                  k.onDestroy(() => Br(N, q.toStyles)),
                  (k.disabled = !0),
                  k.overrideTotalTime(q.totalTime),
                  void r.push(k)
                );
              let ee = W;
              if (P.size > 1) {
                let K = N;
                const fe = [];
                for (; (K = K.parentNode); ) {
                  const le = P.get(K);
                  if (le) {
                    ee = le;
                    break;
                  }
                  fe.push(K);
                }
                fe.forEach((le) => P.set(le, ee));
              }
              const U = this._buildAnimation(k.namespaceId, q, x, s, ie, C);
              if ((k.setRealPlayer(U), ee === W)) V.push(k);
              else {
                const K = this.playersByElement.get(ee);
                K && K.length && (k.parentPlayer = to(K)), r.push(k);
              }
            } else
              oa(N, q.fromStyles),
                k.onDestroy(() => Br(N, q.toStyles)),
                z.push(k),
                u.has(N) && r.push(k);
          }),
            z.forEach((F) => {
              const N = s.get(F.element);
              if (N && N.length) {
                const k = to(N);
                F.setRealPlayer(k);
              }
            }),
            r.forEach((F) => {
              F.parentPlayer ? F.syncPlayerEvents(F.parentPlayer) : F.destroy();
            });
          for (let F = 0; F < g.length; F++) {
            const N = g[F],
              k = N[vr];
            if ((rc(N, nm), k && k.hasAnimation)) continue;
            let q = [];
            if (a.size) {
              let U = a.get(N);
              U && U.length && q.push(...U);
              let K = this.driver.query(N, Bb, !0);
              for (let fe = 0; fe < K.length; fe++) {
                let le = a.get(K[fe]);
                le && le.length && q.push(...le);
              }
            }
            const ee = q.filter((U) => !U.destroyed);
            ee.length ? qee(this, N, ee) : this.processLeaveNode(N);
          }
          return (
            (g.length = 0),
            V.forEach((F) => {
              this.players.push(F),
                F.onDone(() => {
                  F.destroy();
                  const N = this.players.indexOf(F);
                  this.players.splice(N, 1);
                }),
                F.play();
            }),
            V
          );
        }
        afterFlush(e) {
          this._flushFns.push(e);
        }
        afterFlushAnimationsDone(e) {
          this._whenQuietFns.push(e);
        }
        _getPreviousPlayers(e, t, i, r, s) {
          let o = [];
          if (t) {
            const a = this.playersByQueriedElement.get(e);
            a && (o = a);
          } else {
            const a = this.playersByElement.get(e);
            if (a) {
              const l = !s || s == hd;
              a.forEach((c) => {
                c.queued || (!l && c.triggerName != r) || o.push(c);
              });
            }
          }
          return (
            (i || r) &&
              (o = o.filter(
                (a) =>
                  !((i && i != a.namespaceId) || (r && r != a.triggerName)),
              )),
            o
          );
        }
        _beforeAnimationBuild(e, t, i) {
          const s = t.element,
            o = t.isRemovalTransition ? void 0 : e,
            a = t.isRemovalTransition ? void 0 : t.triggerName;
          for (const l of t.timelines) {
            const c = l.element,
              u = c !== s,
              d = Li(i, c, []);
            this._getPreviousPlayers(c, u, o, a, t.toState).forEach((f) => {
              const p = f.getRealPlayer();
              p.beforeDestroy && p.beforeDestroy(), f.destroy(), d.push(f);
            });
          }
          oa(s, t.fromStyles);
        }
        _buildAnimation(e, t, i, r, s, o) {
          const a = t.triggerName,
            l = t.element,
            c = [],
            u = new Set(),
            d = new Set(),
            h = t.timelines.map((p) => {
              const _ = p.element;
              u.add(_);
              const g = _[vr];
              if (g && g.removedBeforeQueried)
                return new ld(p.duration, p.delay);
              const m = _ !== l,
                y = (function Xee(n) {
                  const e = [];
                  return VN(n, e), e;
                })((i.get(_) || Vee).map((x) => x.getRealPlayer())).filter(
                  (x) => !!x.element && x.element === _,
                ),
                v = s.get(_),
                b = o.get(_),
                S = gN(this._normalizer, p.keyframes, v, b),
                E = this._buildPlayer(p, S, y);
              if ((p.subTimeline && r && d.add(_), m)) {
                const x = new Jb(e, a, _);
                x.setRealPlayer(E), c.push(x);
              }
              return E;
            });
          c.forEach((p) => {
            Li(this.playersByQueriedElement, p.element, []).push(p),
              p.onDone(() =>
                (function Wee(n, e, t) {
                  let i = n.get(e);
                  if (i) {
                    if (i.length) {
                      const r = i.indexOf(t);
                      i.splice(r, 1);
                    }
                    0 == i.length && n.delete(e);
                  }
                  return i;
                })(this.playersByQueriedElement, p.element, p),
              );
          }),
            u.forEach((p) => er(p, wN));
          const f = to(h);
          return (
            f.onDestroy(() => {
              u.forEach((p) => rc(p, wN)), Br(l, t.toStyles);
            }),
            d.forEach((p) => {
              Li(r, p, []).push(f);
            }),
            f
          );
        }
        _buildPlayer(e, t, i) {
          return t.length > 0
            ? this.driver.animate(
                e.element,
                t,
                e.duration,
                e.delay,
                e.easing,
                i,
              )
            : new ld(e.duration, e.delay);
        }
      }
      class Jb {
        constructor(e, t, i) {
          (this.namespaceId = e),
            (this.triggerName = t),
            (this.element = i),
            (this._player = new ld()),
            (this._containsRealPlayer = !1),
            (this._queuedCallbacks = new Map()),
            (this.destroyed = !1),
            (this.parentPlayer = null),
            (this.markedForDestroy = !1),
            (this.disabled = !1),
            (this.queued = !0),
            (this.totalTime = 0);
        }
        setRealPlayer(e) {
          this._containsRealPlayer ||
            ((this._player = e),
            this._queuedCallbacks.forEach((t, i) => {
              t.forEach((r) => Ob(e, i, void 0, r));
            }),
            this._queuedCallbacks.clear(),
            (this._containsRealPlayer = !0),
            this.overrideTotalTime(e.totalTime),
            (this.queued = !1));
        }
        getRealPlayer() {
          return this._player;
        }
        overrideTotalTime(e) {
          this.totalTime = e;
        }
        syncPlayerEvents(e) {
          const t = this._player;
          t.triggerCallback && e.onStart(() => t.triggerCallback("start")),
            e.onDone(() => this.finish()),
            e.onDestroy(() => this.destroy());
        }
        _queueEvent(e, t) {
          Li(this._queuedCallbacks, e, []).push(t);
        }
        onDone(e) {
          this.queued && this._queueEvent("done", e), this._player.onDone(e);
        }
        onStart(e) {
          this.queued && this._queueEvent("start", e), this._player.onStart(e);
        }
        onDestroy(e) {
          this.queued && this._queueEvent("destroy", e),
            this._player.onDestroy(e);
        }
        init() {
          this._player.init();
        }
        hasStarted() {
          return !this.queued && this._player.hasStarted();
        }
        play() {
          !this.queued && this._player.play();
        }
        pause() {
          !this.queued && this._player.pause();
        }
        restart() {
          !this.queued && this._player.restart();
        }
        finish() {
          this._player.finish();
        }
        destroy() {
          (this.destroyed = !0), this._player.destroy();
        }
        reset() {
          !this.queued && this._player.reset();
        }
        setPosition(e) {
          this.queued || this._player.setPosition(e);
        }
        getPosition() {
          return this.queued ? 0 : this._player.getPosition();
        }
        triggerCallback(e) {
          const t = this._player;
          t.triggerCallback && t.triggerCallback(e);
        }
      }
      function fm(n) {
        return n && 1 === n.nodeType;
      }
      function kN(n, e) {
        const t = n.style.display;
        return (n.style.display = e ?? "none"), t;
      }
      function UN(n, e, t, i, r) {
        const s = [];
        t.forEach((l) => s.push(kN(l)));
        const o = [];
        i.forEach((l, c) => {
          const u = new Map();
          l.forEach((d) => {
            const h = e.computeStyle(c, d, r);
            u.set(d, h), (!h || 0 == h.length) && ((c[vr] = Hee), o.push(c));
          }),
            n.set(c, u);
        });
        let a = 0;
        return t.forEach((l) => kN(l, s[a++])), o;
      }
      function BN(n, e) {
        const t = new Map();
        if ((n.forEach((a) => t.set(a, [])), 0 == e.length)) return t;
        const r = new Set(e),
          s = new Map();
        function o(a) {
          if (!a) return 1;
          let l = s.get(a);
          if (l) return l;
          const c = a.parentNode;
          return (l = t.has(c) ? c : r.has(c) ? 1 : o(c)), s.set(a, l), l;
        }
        return (
          e.forEach((a) => {
            const l = o(a);
            1 !== l && t.get(l).push(a);
          }),
          t
        );
      }
      function er(n, e) {
        n.classList?.add(e);
      }
      function rc(n, e) {
        n.classList?.remove(e);
      }
      function qee(n, e, t) {
        to(t).onDone(() => n.processLeaveNode(e));
      }
      function VN(n, e) {
        for (let t = 0; t < n.length; t++) {
          const i = n[t];
          i instanceof pN ? VN(i.players, e) : e.push(i);
        }
      }
      function HN(n, e, t) {
        const i = t.get(n);
        if (!i) return !1;
        let r = e.get(n);
        return r ? i.forEach((s) => r.add(s)) : e.set(n, i), t.delete(n), !0;
      }
      class pm {
        constructor(e, t, i) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = i),
            (this._triggerCache = {}),
            (this.onRemovalComplete = (r, s) => {}),
            (this._transitionEngine = new Gee(e, t, i)),
            (this._timelineEngine = new Lee(e, t, i)),
            (this._transitionEngine.onRemovalComplete = (r, s) =>
              this.onRemovalComplete(r, s));
        }
        registerTrigger(e, t, i, r, s) {
          const o = e + "-" + r;
          let a = this._triggerCache[o];
          if (!a) {
            const l = [],
              u = Gb(this._driver, s, l, []);
            if (l.length)
              throw (function kJ(n, e) {
                return new Y(3404, !1);
              })();
            (a = (function Ree(n, e, t) {
              return new Pee(n, e, t);
            })(r, u, this._normalizer)),
              (this._triggerCache[o] = a);
          }
          this._transitionEngine.registerTrigger(t, r, a);
        }
        register(e, t) {
          this._transitionEngine.register(e, t);
        }
        destroy(e, t) {
          this._transitionEngine.destroy(e, t);
        }
        onInsert(e, t, i, r) {
          this._transitionEngine.insertNode(e, t, i, r);
        }
        onRemove(e, t, i) {
          this._transitionEngine.removeNode(e, t, i);
        }
        disableAnimations(e, t) {
          this._transitionEngine.markElementAsDisabled(e, t);
        }
        process(e, t, i, r) {
          if ("@" == i.charAt(0)) {
            const [s, o] = _N(i);
            this._timelineEngine.command(s, t, o, r);
          } else this._transitionEngine.trigger(e, t, i, r);
        }
        listen(e, t, i, r, s) {
          if ("@" == i.charAt(0)) {
            const [o, a] = _N(i);
            return this._timelineEngine.listen(o, t, a, s);
          }
          return this._transitionEngine.listen(e, t, i, r, s);
        }
        flush(e = -1) {
          this._transitionEngine.flush(e);
        }
        get players() {
          return [
            ...this._transitionEngine.players,
            ...this._timelineEngine.players,
          ];
        }
        whenRenderingDone() {
          return this._transitionEngine.whenRenderingDone();
        }
        afterFlushAnimationsDone(e) {
          this._transitionEngine.afterFlushAnimationsDone(e);
        }
      }
      let Kee = (() => {
        class n {
          constructor(t, i, r) {
            (this._element = t),
              (this._startStyles = i),
              (this._endStyles = r),
              (this._state = 0);
            let s = n.initialStylesByElement.get(t);
            s || n.initialStylesByElement.set(t, (s = new Map())),
              (this._initialStyles = s);
          }
          start() {
            this._state < 1 &&
              (this._startStyles &&
                Br(this._element, this._startStyles, this._initialStyles),
              (this._state = 1));
          }
          finish() {
            this.start(),
              this._state < 2 &&
                (Br(this._element, this._initialStyles),
                this._endStyles &&
                  (Br(this._element, this._endStyles),
                  (this._endStyles = null)),
                (this._state = 1));
          }
          destroy() {
            this.finish(),
              this._state < 3 &&
                (n.initialStylesByElement.delete(this._element),
                this._startStyles &&
                  (oa(this._element, this._startStyles),
                  (this._endStyles = null)),
                this._endStyles &&
                  (oa(this._element, this._endStyles),
                  (this._endStyles = null)),
                Br(this._element, this._initialStyles),
                (this._state = 3));
          }
        }
        return (n.initialStylesByElement = new WeakMap()), n;
      })();
      function eM(n) {
        let e = null;
        return (
          n.forEach((t, i) => {
            (function Qee(n) {
              return "display" === n || "position" === n;
            })(i) && ((e = e || new Map()), e.set(i, t));
          }),
          e
        );
      }
      class zN {
        constructor(e, t, i, r) {
          (this.element = e),
            (this.keyframes = t),
            (this.options = i),
            (this._specialStyles = r),
            (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._initialized = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._originalOnDoneFns = []),
            (this._originalOnStartFns = []),
            (this.time = 0),
            (this.parentPlayer = null),
            (this.currentSnapshot = new Map()),
            (this._duration = i.duration),
            (this._delay = i.delay || 0),
            (this.time = this._duration + this._delay);
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        init() {
          this._buildPlayer(), this._preparePlayerBeforeStart();
        }
        _buildPlayer() {
          if (this._initialized) return;
          this._initialized = !0;
          const e = this.keyframes;
          (this.domPlayer = this._triggerWebAnimation(
            this.element,
            e,
            this.options,
          )),
            (this._finalKeyframe = e.length ? e[e.length - 1] : new Map()),
            this.domPlayer.addEventListener("finish", () => this._onFinish());
        }
        _preparePlayerBeforeStart() {
          this._delay ? this._resetDomPlayerState() : this.domPlayer.pause();
        }
        _convertKeyframesToObject(e) {
          const t = [];
          return (
            e.forEach((i) => {
              t.push(Object.fromEntries(i));
            }),
            t
          );
        }
        _triggerWebAnimation(e, t, i) {
          return e.animate(this._convertKeyframesToObject(t), i);
        }
        onStart(e) {
          this._originalOnStartFns.push(e), this._onStartFns.push(e);
        }
        onDone(e) {
          this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        play() {
          this._buildPlayer(),
            this.hasStarted() ||
              (this._onStartFns.forEach((e) => e()),
              (this._onStartFns = []),
              (this._started = !0),
              this._specialStyles && this._specialStyles.start()),
            this.domPlayer.play();
        }
        pause() {
          this.init(), this.domPlayer.pause();
        }
        finish() {
          this.init(),
            this._specialStyles && this._specialStyles.finish(),
            this._onFinish(),
            this.domPlayer.finish();
        }
        reset() {
          this._resetDomPlayerState(),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._onStartFns = this._originalOnStartFns),
            (this._onDoneFns = this._originalOnDoneFns);
        }
        _resetDomPlayerState() {
          this.domPlayer && this.domPlayer.cancel();
        }
        restart() {
          this.reset(), this.play();
        }
        hasStarted() {
          return this._started;
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._resetDomPlayerState(),
            this._onFinish(),
            this._specialStyles && this._specialStyles.destroy(),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        setPosition(e) {
          void 0 === this.domPlayer && this.init(),
            (this.domPlayer.currentTime = e * this.time);
        }
        getPosition() {
          return this.domPlayer.currentTime / this.time;
        }
        get totalTime() {
          return this._delay + this._duration;
        }
        beforeDestroy() {
          const e = new Map();
          this.hasStarted() &&
            this._finalKeyframe.forEach((i, r) => {
              "offset" !== r &&
                e.set(r, this._finished ? i : TN(this.element, r));
            }),
            (this.currentSnapshot = e);
        }
        triggerCallback(e) {
          const t = "start" === e ? this._onStartFns : this._onDoneFns;
          t.forEach((i) => i()), (t.length = 0);
        }
      }
      class Jee {
        validateStyleProperty(e) {
          return !0;
        }
        validateAnimatableStyleProperty(e) {
          return !0;
        }
        matchesElement(e, t) {
          return !1;
        }
        containsElement(e, t) {
          return yN(e, t);
        }
        getParentElement(e) {
          return Fb(e);
        }
        query(e, t, i) {
          return bN(e, t, i);
        }
        computeStyle(e, t, i) {
          return window.getComputedStyle(e)[t];
        }
        animate(e, t, i, r, s, o = []) {
          const l = {
            duration: i,
            delay: r,
            fill: 0 == r ? "both" : "forwards",
          };
          s && (l.easing = s);
          const c = new Map(),
            u = o.filter((f) => f instanceof zN);
          (function oee(n, e) {
            return 0 === n || 0 === e;
          })(i, r) &&
            u.forEach((f) => {
              f.currentSnapshot.forEach((p, _) => c.set(_, p));
            });
          let d = (function iee(n) {
            return n.length
              ? n[0] instanceof Map
                ? n
                : n.map((e) => EN(e))
              : [];
          })(t).map((f) => no(f));
          d = (function aee(n, e, t) {
            if (t.size && e.length) {
              let i = e[0],
                r = [];
              if (
                (t.forEach((s, o) => {
                  i.has(o) || r.push(o), i.set(o, s);
                }),
                r.length)
              )
                for (let s = 1; s < e.length; s++) {
                  let o = e[s];
                  r.forEach((a) => o.set(a, TN(n, a)));
                }
            }
            return e;
          })(e, d, c);
          const h = (function Zee(n, e) {
            let t = null,
              i = null;
            return (
              Array.isArray(e) && e.length
                ? ((t = eM(e[0])), e.length > 1 && (i = eM(e[e.length - 1])))
                : e instanceof Map && (t = eM(e)),
              t || i ? new Kee(n, t, i) : null
            );
          })(e, d);
          return new zN(e, d, l, h);
        }
      }
      let ete = (() => {
        class n extends dN {
          constructor(t, i) {
            super(),
              (this._nextAnimationId = 0),
              (this._renderer = t.createRenderer(i.body, {
                id: "0",
                encapsulation: Vi.None,
                styles: [],
                data: { animation: [] },
              }));
          }
          build(t) {
            const i = this._nextAnimationId.toString();
            this._nextAnimationId++;
            const r = Array.isArray(t) ? hN(t) : t;
            return (
              GN(this._renderer, null, i, "register", [r]),
              new tte(i, this._renderer)
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se(Nc), se(kt));
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class tte extends mJ {
        constructor(e, t) {
          super(), (this._id = e), (this._renderer = t);
        }
        create(e, t) {
          return new nte(this._id, e, t || {}, this._renderer);
        }
      }
      class nte {
        constructor(e, t, i, r) {
          (this.id = e),
            (this.element = t),
            (this._renderer = r),
            (this.parentPlayer = null),
            (this._started = !1),
            (this.totalTime = 0),
            this._command("create", i);
        }
        _listen(e, t) {
          return this._renderer.listen(this.element, `@@${this.id}:${e}`, t);
        }
        _command(e, ...t) {
          return GN(this._renderer, this.element, this.id, e, t);
        }
        onDone(e) {
          this._listen("done", e);
        }
        onStart(e) {
          this._listen("start", e);
        }
        onDestroy(e) {
          this._listen("destroy", e);
        }
        init() {
          this._command("init");
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this._command("play"), (this._started = !0);
        }
        pause() {
          this._command("pause");
        }
        restart() {
          this._command("restart");
        }
        finish() {
          this._command("finish");
        }
        destroy() {
          this._command("destroy");
        }
        reset() {
          this._command("reset"), (this._started = !1);
        }
        setPosition(e) {
          this._command("setPosition", e);
        }
        getPosition() {
          return this._renderer.engine.players[+this.id]?.getPosition() ?? 0;
        }
      }
      function GN(n, e, t, i, r) {
        return n.setProperty(e, `@@${t}:${i}`, r);
      }
      const WN = "@.disabled";
      let ite = (() => {
        class n {
          constructor(t, i, r) {
            (this.delegate = t),
              (this.engine = i),
              (this._zone = r),
              (this._currentId = 0),
              (this._microtaskId = 1),
              (this._animationCallbacksBuffer = []),
              (this._rendererCache = new Map()),
              (this._cdRecurDepth = 0),
              (i.onRemovalComplete = (s, o) => {
                const a = o?.parentNode(s);
                a && o.removeChild(a, s);
              });
          }
          createRenderer(t, i) {
            const s = this.delegate.createRenderer(t, i);
            if (!(t && i && i.data && i.data.animation)) {
              let u = this._rendererCache.get(s);
              return (
                u ||
                  ((u = new $N("", s, this.engine, () =>
                    this._rendererCache.delete(s),
                  )),
                  this._rendererCache.set(s, u)),
                u
              );
            }
            const o = i.id,
              a = i.id + "-" + this._currentId;
            this._currentId++, this.engine.register(a, t);
            const l = (u) => {
              Array.isArray(u)
                ? u.forEach(l)
                : this.engine.registerTrigger(o, a, t, u.name, u);
            };
            return (
              i.data.animation.forEach(l), new rte(this, a, s, this.engine)
            );
          }
          begin() {
            this._cdRecurDepth++, this.delegate.begin && this.delegate.begin();
          }
          _scheduleCountTask() {
            queueMicrotask(() => {
              this._microtaskId++;
            });
          }
          scheduleListenerCallback(t, i, r) {
            t >= 0 && t < this._microtaskId
              ? this._zone.run(() => i(r))
              : (0 == this._animationCallbacksBuffer.length &&
                  queueMicrotask(() => {
                    this._zone.run(() => {
                      this._animationCallbacksBuffer.forEach((s) => {
                        const [o, a] = s;
                        o(a);
                      }),
                        (this._animationCallbacksBuffer = []);
                    });
                  }),
                this._animationCallbacksBuffer.push([i, r]));
          }
          end() {
            this._cdRecurDepth--,
              0 == this._cdRecurDepth &&
                this._zone.runOutsideAngular(() => {
                  this._scheduleCountTask(),
                    this.engine.flush(this._microtaskId);
                }),
              this.delegate.end && this.delegate.end();
          }
          whenRenderingDone() {
            return this.engine.whenRenderingDone();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(se(Nc), se(pm), se(yt));
          }),
          (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class $N {
        constructor(e, t, i, r) {
          (this.namespaceId = e),
            (this.delegate = t),
            (this.engine = i),
            (this._onDestroy = r);
        }
        get data() {
          return this.delegate.data;
        }
        destroyNode(e) {
          this.delegate.destroyNode?.(e);
        }
        destroy() {
          this.engine.destroy(this.namespaceId, this.delegate),
            this.engine.afterFlushAnimationsDone(() => {
              queueMicrotask(() => {
                this.delegate.destroy();
              });
            }),
            this._onDestroy?.();
        }
        createElement(e, t) {
          return this.delegate.createElement(e, t);
        }
        createComment(e) {
          return this.delegate.createComment(e);
        }
        createText(e) {
          return this.delegate.createText(e);
        }
        appendChild(e, t) {
          this.delegate.appendChild(e, t),
            this.engine.onInsert(this.namespaceId, t, e, !1);
        }
        insertBefore(e, t, i, r = !0) {
          this.delegate.insertBefore(e, t, i),
            this.engine.onInsert(this.namespaceId, t, e, r);
        }
        removeChild(e, t, i) {
          this.engine.onRemove(this.namespaceId, t, this.delegate);
        }
        selectRootElement(e, t) {
          return this.delegate.selectRootElement(e, t);
        }
        parentNode(e) {
          return this.delegate.parentNode(e);
        }
        nextSibling(e) {
          return this.delegate.nextSibling(e);
        }
        setAttribute(e, t, i, r) {
          this.delegate.setAttribute(e, t, i, r);
        }
        removeAttribute(e, t, i) {
          this.delegate.removeAttribute(e, t, i);
        }
        addClass(e, t) {
          this.delegate.addClass(e, t);
        }
        removeClass(e, t) {
          this.delegate.removeClass(e, t);
        }
        setStyle(e, t, i, r) {
          this.delegate.setStyle(e, t, i, r);
        }
        removeStyle(e, t, i) {
          this.delegate.removeStyle(e, t, i);
        }
        setProperty(e, t, i) {
          "@" == t.charAt(0) && t == WN
            ? this.disableAnimations(e, !!i)
            : this.delegate.setProperty(e, t, i);
        }
        setValue(e, t) {
          this.delegate.setValue(e, t);
        }
        listen(e, t, i) {
          return this.delegate.listen(e, t, i);
        }
        disableAnimations(e, t) {
          this.engine.disableAnimations(e, t);
        }
      }
      class rte extends $N {
        constructor(e, t, i, r, s) {
          super(t, i, r, s), (this.factory = e), (this.namespaceId = t);
        }
        setProperty(e, t, i) {
          "@" == t.charAt(0)
            ? "." == t.charAt(1) && t == WN
              ? this.disableAnimations(e, (i = void 0 === i || !!i))
              : this.engine.process(this.namespaceId, e, t.slice(1), i)
            : this.delegate.setProperty(e, t, i);
        }
        listen(e, t, i) {
          if ("@" == t.charAt(0)) {
            const r = (function ste(n) {
              switch (n) {
                case "body":
                  return document.body;
                case "document":
                  return document;
                case "window":
                  return window;
                default:
                  return n;
              }
            })(e);
            let s = t.slice(1),
              o = "";
            return (
              "@" != s.charAt(0) &&
                ([s, o] = (function ote(n) {
                  const e = n.indexOf(".");
                  return [n.substring(0, e), n.slice(e + 1)];
                })(s)),
              this.engine.listen(this.namespaceId, r, s, o, (a) => {
                this.factory.scheduleListenerCallback(a._data || -1, i, a);
              })
            );
          }
          return this.delegate.listen(e, t, i);
        }
      }
      const jN = [
          { provide: dN, useClass: ete },
          {
            provide: Xb,
            useFactory: function lte() {
              return new Tee();
            },
          },
          {
            provide: pm,
            useClass: (() => {
              class n extends pm {
                constructor(t, i, r, s) {
                  super(t.body, i, r);
                }
                ngOnDestroy() {
                  this.flush();
                }
              }
              return (
                (n.ɵfac = function (t) {
                  return new (t || n)(se(kt), se(kb), se(Xb), se(Ps));
                }),
                (n.ɵprov = Ee({ token: n, factory: n.ɵfac })),
                n
              );
            })(),
          },
          {
            provide: Nc,
            useFactory: function cte(n, e, t) {
              return new ite(n, e, t);
            },
            deps: [zv, pm, yt],
          },
        ],
        tM = [
          { provide: kb, useFactory: () => new Jee() },
          { provide: Gg, useValue: "BrowserAnimations" },
          ...jN,
        ],
        qN = [
          { provide: kb, useClass: MN },
          { provide: Gg, useValue: "NoopAnimations" },
          ...jN,
        ];
      let ute = (() => {
          class n {
            static withConfig(t) {
              return { ngModule: n, providers: t.disableAnimations ? qN : tM };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n })),
            (n.ɵinj = bt({ providers: tM, imports: [iA] })),
            n
          );
        })(),
        dte = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = Et({ type: n, bootstrap: [Ej] })),
            (n.ɵinj = bt({
              imports: [
                iA,
                cZ,
                hZ,
                mZ,
                bK,
                E1,
                dQ,
                hQ,
                $Q,
                jQ,
                ZQ,
                iJ,
                rJ,
                oJ,
                hJ,
                fJ,
                pJ,
                ute,
              ],
            })),
            n
          );
        })();
      H5()
        .bootstrapModule(dte)
        .catch((n) => console.error(n));
    },
  },
  (gt) => {
    gt((gt.s = 141));
  },
]);
